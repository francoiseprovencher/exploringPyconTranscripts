01:17:35  >> GOOD MORNING, EVERYONE.
01:17:36  HOW Y'ALL DOING?
01:17:38  THAT WAS REALLY SAD.
01:17:41  LIKE, HOW Y'ALL DOING?
01:17:45  >> WHOO!
01:17:47  >> YEAH, MUCH MUCH BETTER.
01:17:48  ALL RIGHT.
01:17:49  SO, OUR NEXT TALK, WHICH IS GOING TO BE AWESOME,
01:17:51  IS BY ASHEESH LAROIA AND PHILIP JAMES.
01:17:55  THEY ARE LONGTIME PYTHON FRIENDS.
01:17:59  THEY'RE GOING TO BE TELLING US WHAT HAPPENS WHEN
01:18:01  YOU RUN PYTHON.
01:18:02  THEY WORK AT EVENTBRITE.
01:18:05  [ APPLAUSE ]
01:18:06  >> THANKS.
01:18:07  AS HE SAID, MY NAME IS PHILIP JAMES, I WORK AT
01:18:11  EVENTBRITE AS A SOFTWARE ENGINEER ON THE ORGANIZER
01:18:13  GROWTH TEAM.
01:18:14  YES, WE ARE HIRING.
01:18:15  I'VE BEEN USING PYTHON FOR ABOUT SEVEN YEARS, EVER
01:18:17  SINCE A FRIEND WHO'S IN DATABASES INTRODUCED ME TO
01:18:21  THE LANGUAGE, BUT IT WASN'T UNTIL I SAW HOW EASY
01:18:23  IT WAS TO BUILD A WEB ABSENT PYTHON THAT I REALLY
01:18:27  GOT EXCITED AND I'VE BEEN BUILDING THINGS EVER
01:18:28  SINCE.
01:18:29  >> HI, MY NAME IS ASHEESH, I'M A SOFTWARE ENGINEER
01:18:32  AND A COMMUNITY ENGINEER AT SANDSTORM NOW.
01:18:35  AND I FIRST GOT INTO PYTHON BECAUSE I WANTED TO
01:18:39  WRITE SOME CODE TO TAKE MY HIGH SCHOOL NEWSPAPER'S
01:18:42  PAGE MAKER FILES AND MAKE A WEBSITE OUT OF THEM.
01:18:45  AND I HAD READ THAT PYTHON WAS A GREAT LANGUAGE
01:18:47  FOR THIS KIND OF THING.
01:18:49  SO I TRIED TO INSTALL PYTHON ON THE COMPUTER LAB
01:18:51  MACHINE IN THE HIGH SCHOOL NEWSPAPER OFFICE.
01:18:54  IT DIDN'T WORK.
01:18:54  SO THEN I USED UNPATCHED WINDOWS SECURITY
01:18:58  VULNERABILITY TO GET LOCAL SYSTEM AND INSTALL
01:19:01  PYTHON.
01:19:01  AND THEN FOR THE REST OF THE YEAR, I WAS ABLE TO
01:19:03  MAKE SOME CODE TO MAKE A WEBSITE.
01:19:06   [ APPLAUSE ]
01:19:07  >> AND WE'RE HERE TO TALK ABOUT WHAT HAPPENS WHEN
01:19:11  YOU TYPE PYTHON AND PRESS ENTER.
01:19:13  SO WHAT IS IT DOES HAPPEN?
01:19:15  YOU TYPE PYTHON.
01:19:16  YOU PRESS ENTER.
01:19:17  SOME MAGIC HAPPENS.
01:19:18  THE SHELL IS DISPLAYED.
01:19:20  AND THAT'S THE END OF THE TALK.
01:19:21  THANKS, EVERYBODY, IT WAS REALLY GREAT TO HAVE
01:19:23  YOU.
01:19:23  >> THANKS SO MUCH.
01:19:24  [ Laughter ]
01:19:24  >> REALLY, WE'RE GOING TO BE TALKING ABOUT THE
01:19:26  PYTHON PROCESS AND HOW IT AS A UNIX PROCESS
01:19:31  INTERACTS WITH THE REST OF THE OPERATING SYSTEM
01:19:33  AND HOW USER INTERACT WITH THAT PROCESS.
01:19:35  IF YOU ARE EXPECTING A TALK ABOUT CPYTHON
01:19:38  INTERNALS, SORRY, THIS IS THE WRONG TALK.
01:19:39  THIS IS ABOUT THE ACTUAL PYTHON PROCESS AS AN
01:19:42  ABSTRACTION AND HOW IT INTERACTS WITH EVERYTHING
01:19:44  ELSE.
01:19:45  SO, WE'RE GOING TO START WITH THE SHELL.
01:19:47  THIS IS THE BASH SHELL.
01:19:49  AND WE'RE GOING TO TYPE PYTHON.
01:19:51  NOW, WHEN WE TYPE PYTHON AND PRESS ENTER, THE
01:19:54  FIRST THING THAT THE SHELL NEEDS TO DO IS FIND THE
01:19:57  PYTHON EXECUTABLE.
01:19:58  AND THE WAY THAT IT DOES THIS IS BY LOOKING IN AN
01:20:01  ENVIRONMENT VARIABLE CALLED THE PATH.
01:20:03  WE CAN PRINT THE PATH TO OUR SHELL BY USING THE
01:20:06  COMMAND ECHO PATH.
01:20:08  ALL ENVIRONMENT VARIABLES ARE STRINGS, BUT THIS IS
01:20:11  A STRING THAT BEHAVES LIKE A LIST BECAUSE OF THAT
01:20:13  COLON SEPARATOR BETWEEN THE ELEMENTS.
01:20:16  SO, IF WE TYPE PYTHON AND PRESS ENTER, THE SHELL
01:20:19  IS GOING TO START LOOKING FOR THE PYTHON
01:20:22  EXECUTABLE IN THE PARTS OF THE PATH IN ORDER.
01:20:25  IT'S GOING TO START IN SLASH HOME, SLASH PAUL
01:20:29  PROTEUS SLASH BIN.
01:20:31  IT DOESN'T FIND PYTHON.
01:20:33  IT MOVES TO USER BIN, BECAUSE THIS IS WHERE THE
01:20:35  PYTHON BINARY, BIN FOR BINARY, LIVES, IT GOES,
01:20:39  SUCCESS, I HAVE FOUND IT.
01:20:40  NOW, WE SAY THAT THE SHELL IS LOOKING FOR AN
01:20:43  EXECUTABLE, BUT WHAT DOES THAT MEAN?
01:20:45  THAT MEANS IT'S LOOKING FOR A TYPE OF FILE THAT
01:20:48  THE KERNEL KNOWS HOW TO EXECUTE.
01:20:50  THERE ARE MANY TYPES OF FILES THAT CAN BE EXECUTED
01:20:52  BY THE KERNEL.
01:20:54  BUT THE MECHANISM FOR FINDING THEM IS ALL THE
01:20:56  SAME.
01:20:56  SO IF WE WANTED TO FIGURE OUT HOW THE SHELL KNOWS
01:21:02  THAT THE PYTHON EXECUTABLE IS EXECUTABLE, WE COULD
01:21:05  TRY LOOKING AT THE RAW HEX.
01:21:07  AND IF WE LOOK AT THE BEGINNING OF THE FILE, WE
01:21:10  SEE THAT 7F454C46, OR ELF, WE CAN GET MORE
01:21:16  INFORMATION WITH THE FILE COMMAND AND SEE THE USER
01:21:19  BIN PYTHON IS AN ELF64 BIT LSB EXECUTABLE.
01:21:23  ELF STANDS FOR EXECUTABLE AND LINKABLE FORMAT
01:21:29  FILE.
01:21:31  AND WHEN THE SHELL HAS FOUND, IT KNOWS, THIS THING
01:21:34  IS EXECUTABLE, IT MATCHES THE COMMAND THAT THE
01:21:36  USER GAVE ME, I'M GOING TO TRY TO EXECUTE THIS.
01:21:38  IF THE ALGORITHM FOR FINDING THE FILES WAS WRITTEN
01:21:41  IN PYTHON, IT WOULD LOOK A LOT LIKE THIS.
01:21:44  THIS ISN'T THE ACTUAL CODE, BECAUSE THE BASH SHELL
01:21:46  IS WRITTEN IN C, BUT IF YOU WANTED TO BUILD A
01:21:48  SHELL IN PYTHON, THIS MIGHT BE WHAT YOU USE.
01:21:50  SO, NOW THE BASH PROCESS HAS FOUND PYTHON AND
01:21:56  WANTS TO START IT.
01:21:57  IF WE LOOK AT THE SHELL AGAIN, IT MIGHT USE
01:22:01  SOMETHING LIKE EXEC PYTHON, WHICH IS A WAY OF
01:22:04  TAKING A COMMAND AND RUNNING IT RIGHT IN THE
01:22:06  SESSION THAT YOU'RE CURRENTLY RUNNING.
01:22:08  AND, SO, IT WOULD START PYTHON, GREAT.
01:22:10  THIS LOOKS LIKE IT MIGHT BE WHAT YOU WANT.
01:22:12  BUT THERE'S A PROBLEM.
01:22:14  IF PYTHON QUITS FOR WHATEVER REASON, EXITS OR
01:22:17  SOMETHING EXTERNAL CAUSES IT TO EXIT, THEN THAT
01:22:20  PROCESS WOULD JUST BE DEAD.
01:22:23  YOU MAY HAVE SEEN SOMETHING LIKE THIS ON YOUR
01:22:25  MACHINE WHEN YOUR PROCESS EXITS IN THE TERMINAL.
01:22:29  THIS ISN'T WHAT WE WANT.
01:22:31  WHAT WE WANT IS FOR THE BASH PROCESS TO MAKE A
01:22:34  COPY OF ITSELF THROUGH A SYSTEM CALL CALLED FORK.
01:22:38  A SYSTEM CALL IS A MECHANISM THAT A PROGRAM CAN
01:22:41  USE TO TALK TO THE OPERATING SYSTEM AND DO KERNEL
01:22:44  FUNCTIONS, FUNCTIONS THAT NEED THE KERNEL'S HELP.
01:22:47  SO BASH CALLS THE FORK SYSTEM CALL.
01:22:50  AND CREATES A COPY OF ITSELF.
01:22:51  YOU CAN SEE THE PROCESS I.D. HAS CHANGED FROM 1221
01:22:55  TO 1222.
01:22:56  IT THEN CALLS EXECUTE ON THE PYTHON BINARY THAT IT
01:23:03  FOUND EARLIER AND THE CHILD BECOMES PYTHON.
01:23:06  SO, WE CAN VISUALIZE THIS CHANGE OF FORKING AND
01:23:13  EXECUTING, WHICH, BY THE WAY, IS HOW ALL PROCESSES
01:23:15  ON A UNIX SYSTEM, AND HERE WE'RE TALKING ABOUT
01:23:19  LINUX AND MAC, HOW ALL THE PROCESSES ARE STARTED
01:23:21  THROUGH ANOTHER PROGRAM CALLED PSTREE.
01:23:25  IF WE WERE TO RUN PSTREE, WE WOULD SEE THE FLOW,
01:23:29  THE TREE OF ALL THE PROCESSES ON OUR SYSTEM.
01:23:31  WE'VE TAKEN SOME OUT TO MAKE IT EASIER TO LOOK AT,
01:23:33  BUT YOU CAN SEE, IT STARTS WITH INIT WHICH THEN
01:23:36  FORKS AND EXECS ALL THE OTHER PROGRAMS IN THE
01:23:39  SYSTEM, DOWN TO THE SHH DAEMON, WHICH WE'RE USING
01:23:44  TO LOG INTO THE MACHINE, WHICH CREATES BASH, WHICH
01:23:46  CREATES PYTHON AND PSTREE.
01:23:48  QUICK REVIEW.
01:23:49  PROCESS CREATION, FIND THE BINARY IN THE PATH
01:23:52  ENVIRONMENT VARIABLE.
01:23:54  FORK THE CURRENT PROCESS.
01:23:55  AND EXEC THE FOUND BINARY INTO THE NEW PROCESS.
01:23:58  NOW, IF WE HAD PASSED SOME ARGUMENTS TO THE PYTHON
01:24:04  COMMAND, WE'D SEE SOMETHING LIKE THIS.
01:24:07  PYTHON DASH V GIVES YOU A LIST OF ALL THE IMPORTS
01:24:11  THAT IT'S GOING TO FIND WHEN IT TRIES TO LOAD THE
01:24:14  INTERACTIVE SHELL.
01:24:16  BASH SEES THOSE ARGUMENTS FIRST, TOKENIZES THE
01:24:21  LIST OF ARGUMENTS AND PASSES THAT THROUGH THE EXEC
01:24:24  COMMAND TO THE NEW PROGRAM THAT IT'S STARTING.
01:24:27  WHAT'S INTERESTING TO NOTE IS THAT EVEN THE FIRST
01:24:30  ELEMENT OF THE LIST IS THE NAME OF THE PROGRAM.
01:24:34  SO HERE WE SEE THAT IF WE WERE TO PASS PYTHON DASH
01:24:37  V, THEN OUR PYTHON PROCESS WOULD HAVE AN ARG V
01:24:40  LIST OF PYTHON AND DASH V.
01:24:43  IF WE LOOK AT JUST OUR STANDARD PYTHON PROCESS,
01:24:45  WITH NO OPTIONS, ARG V IS STILL POPULATED WITH THE
01:24:49  NAME OF THE COMMAND.
01:24:51  SO NOW WE HAVE A PYTHON PROCESS, WE HAVE A SHELL,
01:24:54  BUT HOW DO WE INTERACT WITH THAT SHELL?
01:24:57  HOW DO WE HANDLE INPUT AND OUTPUT?
01:24:59  FOR THAT I'M GOING TO TURN IT OVER TO ASHEESH.
01:25:01  >> THANKS, PHILIP.
01:25:03  SO TO TELL YOU SOMETHING ABOUT HOW INPUT AND
01:25:06  OUTPUT WORKS WITH UNIX PROCESSES, I'M GOING TO
01:25:09  START BY SHOWING YOU A PHOTOGRAPH OF A 1950s
01:25:12  DEVICE CALLED A TELETYPE.
01:25:13  THIS TELETYPE IS A PIECE OF HARDWARE CALLED A
01:25:17  TELETYPE BECAUSE WHEN YOU TYPE ON THE KEYBOARD,
01:25:20  WHAT YOU TYPE FLOWS OUT A MODEM LINE, A PHONE
01:25:23  LINE, THROUGH THE BACK OF THIS DEVICE, GOES TO
01:25:26  SOME COMPUTER FAR AWAY, WHATEVER YOU TYPE IT SEES,
01:25:30  AND WHEN IT WANTS TO TALK TO TO YOU, IF YOU'VE
01:25:33  TYPED SOMETHING THAT REQUIRES A RESPONSE, WHEN IT
01:25:39  KNOWS WHAT TO TELL YOU, IT WILL PRINT THAT ON THIS
01:25:41  PIECE OF PAPER AT THE TOP OF YOUR TELETYPE.
01:25:43  THIS IS, HONEST TO GOODNESS, PAPER TERMINALS.
01:25:46  NOWADAYS WE DON'T HAVE TERMINALS.
01:25:48  WE HAVE TERMINAL EMULATORS.
01:25:50  BECAUSE IT'S MUCH CHEAPER TO HAVE SOFTWARE THAN
01:25:52  TELETYPES.
01:25:53  BUT THERE'S STILL SOFTWARE IN THE OPERATING SYSTEM
01:25:55  THAT MODELS THIS TELETYPE DEVICE.
01:25:58  IN LINUX, THAT'S CALLED A PSEUDO-TTY LAYER, TTY
01:26:03  FOR TELETYPE, AND A COOL THING ABOUT UNIX SYSTEMS
01:26:09  IS THAT YOU COULD, IN THE 1970s, WHEN UNIX
01:26:12  BEGAN, CONNECT MULTIPLE OF THESE TELETYPE DEVICES
01:26:15  TO THE SAME UNIX SYSTEM.
01:26:16  SO DIFFERENT PEOPLE COULD BE SHARING ACCESS, THEY
01:26:18  COULD BE TYPING COMMANDS, ALL SEPARATELY, PAPER
01:26:21  COULD BE SPILLING OUT, ALL SEPARATELY.
01:26:24  AND NOWADAYS THAT'S SIMULATED BY THESE
01:26:27  PSEUDO-TELETYPE DEVICES HAVING INDIVIDUAL FILES IN
01:26:30  THIS DIRECTORY DEV PTS.
01:26:34  LET'S SAY THAT THE TERMINAL WINDOW WHICH WE'LL
01:26:37  OPEN, WHICH WE'LL DO THE REST OF THIS INPUT/OUTPUT
01:26:40  DISCUSSION IS NUMBERED DEV PTS3.
01:26:45  SO, THE NEXT THING WE'LL DO IS TYPE 2 PLUS 2 AND
01:26:49  PRESS ENTER, AND PRESS ENTER, INTO PYTHON.
01:26:53  TO VISUALIZE HOW THAT WORKS, PYTHON NOT ONLY HAS A
01:26:57  PID, IT ALSO HAS A SET OF FILE DESCRIPTORS, FILE
01:27:01  DESCRIPTOR NUMBER 0 IS WHERE THE NUMBER 2 WILL
01:27:04  APPEAR AND THAT'S COMMONLY NAMED STANDARDIN.
01:27:09  SO, STANDARD IN IS REALLY JUST A NAME FOR THE
01:27:12  NUMBER 0 IN THIS CONTEXT OF FILE DESCRIPTORS.
01:27:16  AND A FILE DESCRIPTOR IS A FINDING FROM THIS
01:27:19  NUMBER TO THE OPEN FILE OBJECT INSIDE THE
01:27:22  OPERATING TESTIMONY KERNEL, IN OUR CASE, IT'S OPEN
01:27:25  AND BOUND TO THE PSEUDO-TELETYPE DEVICE PROVIDED
01:27:27  BY THE OPERATING SYSTEM.
01:27:29  SO WHEN WE PRESS 2 ON THE KEYBOARD, THAT FLOWS
01:27:31  INTO THIS LAYER, WHICH INSIDE THE OPERATING SYSTEM
01:27:34  MIMICS THAT 1950 TELETYPE DEVICE AND THE LAYER
01:27:39  PASSES THAT 2 TO THIS FILE DESCRIPTOR 0 THAT
01:27:46  PYTHON HAS READ.
01:27:47  AND SO, THAT'S HOW THE EVENT WILL FLOW INTO THE
01:27:51  PYTHON PROCESS.
01:27:53  THAT'S A VISUAL AND I'LL SHOW YOU WHAT THAT'S LIKE
01:27:56  IF WE USE STRACES.
01:27:58  HOW MANY WENT TO JULIA'S TALK?
01:28:00  SOME OF YOU MAY NOW HAVE A COPY OF HER STRACE.
01:28:05  AND STRACE IS A PROGRAM THAT WE CAN USE TO WATCH
01:28:07  ALL THESE SYSTEM CALLS A PROGRAM MAKES, AND SYSTEM
01:28:10  CALLS ARE CALLS A PROGRAM MAKES THAT REQUIRE THE
01:28:13  ASSISTANCE OF THE OPERATING SYSTEM KERNEL TO BE
01:28:15  COMPLETED.
01:28:16  SO, WHEN WE STRACE PYTHON, HOW MANY OF YOU HAVE
01:28:19  STRACED PYTHON?
01:28:20  OKAY, OKAY.
01:28:21  WELL, YOU SHOULD DO THAT SOME MORE, WHEN YOU'RE
01:28:22  DONE WITH THIS TALK.
01:28:24  IT PRINTS OUT A LOT OF STUFF.
01:28:25  BUT EVENT IT WILL PRINT OUT READ OF 0.
01:28:27  AND THE FACT THAT THIS CALL DOESN'T HAVE A CLOSE
01:28:30  PAREN WHEN PRINTED OUT BY STRACE, MEANS THAT THE
01:28:33  CALL HASN'T FINISHED.
01:28:34  READ IS BLOCKING, IT'S WAITING, IT WILL NEVER
01:28:38  TERMINATE UNTIL SOMETHING HAPPENS AND IN OUR CASE,
01:28:42  SOMETHING DOES HAPPEN, WE'LL PRESS 2.
01:28:43  SO THAT WILL FLOW INTO THIS TERM LAYER.
01:28:48  AND READABLE RETURN, THE BYTE 2, AS A STRING, AND
01:28:52  THE NUMBER 1, WHICH INDICATES HOW MANY BYTES IT
01:28:55  RETURNED.
01:28:55  SO, PYTHON WILL PROCESS THAT AND EVENTUALLY DECIDE
01:28:59  THAT THAT'S NOT A FULL PYTHON EXPRESSION THAT IT
01:29:01  WANTS TO EVALUATE YET, SO IT WILL CALL READ AGAIN
01:29:03  ON FILE DESCRIPTOR 0.
01:29:05  WE CAN PRESS PLUS.
01:29:06  THAT WILL FLOW INTO THE PYTHON PROCESS.
01:29:09  AND HAVING DONE THAT, IF WE PRESS 2 AND THEN ENTER
01:29:16  AGAIN, THE MORE DATA WILL FLOW INTO THE PYTHON
01:29:19  PROCESS AND AT THIS POINT, PYTHON WILL DO SOME
01:29:22  COMPUTATION BECAUSE IT'S READY TO EVALUATE ALL
01:29:25  THIS STUFF.
01:29:26  PYTHON'S INTERACTIVE SHELL EXISTS TO READ DATA,
01:29:31  WAIT FOR A NEW LINE, EVALUATE THAT, AND PRINT THE
01:29:33  RESPONSE.
01:29:34  AND I'LL SHOW YOU SOME PSEUDOCODE NOW THAT
01:29:37  EXPLAINS HOW THAT MIGHT WORK.
01:29:39  THE PYTHON INTERACTIVE PROMPT IS ACTUALLY WRITTEN
01:29:41  IN C, NOT IN PYTHON, BUT IF IT WERE WRITTEN IN
01:29:43  PYTHON, IT WOULD LOOK A LOT LIKE THIS.
01:29:46  PYTHON IS GOING TO LOOP FOREVER.
01:29:47  GRABBING ONE CHARACTER AT A TIME FROM SYSOP.
01:29:53  WHICH IS TO SAY, FILE DESCRIPTOR 0 FROM THE C
01:29:55  PERSPECTIVE.
01:29:56  CHECKS IF THAT CHARACTER'S A NEW LINE, AND IF SO,
01:29:58  EVALUATES ALL THE DATA IT'S SEEN SO FAR.
01:30:00  THIS IS KNOWN AS THE READ EVAL PRINT LOOP OR REPL,
01:30:07  IF YOU'VE HEARD PEOPLE TALK ABOUT THE REPL AND NOT
01:30:10  KNOWN WHAT THAT WAS ABOUT, NOW YOU KNOW.
01:30:13  READ EVAL, I DIDN'T HAVE A WORD THAT WAS LOOP.
01:30:17  SO THAT'S HOW PYTHON GETS DATA.
01:30:19  BUT I HAVEN'T YET SAID HOW PYTHON SHOWS THAT DATA
01:30:21  TO YOU.
01:30:22  I HAVE USED THE WORD PRINT HERE.
01:30:25  AS AN HOMAGE TO THE PAPER TERMINALS THAT WE SAW
01:30:28  BEFORE.
01:30:28  PYTHON, IT TURNS OUT, HAS MORE FILE DESCRIPTORS
01:30:32  THAN JUST THE NUMBER 0.
01:30:34  IT WAKES UP WITH AT LEAST THREE FILE DESCRIPTORS,
01:30:36  NUMBER 0, 1, AND 2.
01:30:38  FILE NUMBER 0 IS STANDARDIN.
01:30:42  FILE DESCRIPTOR 1 IS STANDARD OUT AND THAT'S WHERE
01:30:45  PRINT WILL GO.
01:30:46  THAT'S WHAT SYS SET OUT IS BOUND TO IN THE FIRST
01:30:49  PLACE, FILE DESCRIPTOR 2 IS STANDARD ERROR.
01:30:52  ALL THREE OF THESE ARE BOUND TO THE SAME TERMINAL.
01:30:54  BUT IT'S USEFUL, RIGHT, BECAUSE IF YOU WANT TO BE
01:30:56  TYPING INTO ONE TERMINAL, YOU DON'T WANT THE
01:30:58  OUTPUT TO GO A DIFFERENT TERMINAL WINDOW BY
01:31:01  DEFAULT.
01:31:01  SO, THAT'S PYTHON'S FIRST THREE FILE DESCRIPTORS,
01:31:05  BUT IT'S ALSO BASH'S FIRST THREE FILE DESCRIPTORS.
01:31:08  BECAUSE BASH IS THE IF I CAN THING INTO WHICH WE
01:31:11  TYPED PYTHON, THAT FORK, EXEC PYTHON.
01:31:14  AND, SO, WHEN I SEE A DIAGRAM LIKE THIS, I WONDER,
01:31:19  WHEN I TYPE 2 PLUS 2 AND TYPE ENTER, I WONDER, WHO
01:31:22  WILL WIN?
01:31:23  WHO WILL GET THE EVENT?
01:31:24  BASH 0 IS THE TERMINAL.
01:31:26  PYTHON 0 IS THE TERMINAL.
01:31:28  AND THE ANSWER IS THAT BASH SCRUPULOUSLY REFUSES
01:31:31  TO READ FROM FILE DESCRIPTOR 0 WHEN IT'S RUNNING
01:31:34  PYTHON BECAUSE THAT WOULD JUST BE RUDE.
01:31:36  THE POINT IS TO INTERACT WITH PYTHON, NOT TO
01:31:38  INTERACT WITH BASH.
01:31:40  THERE'S A COLLECTION OF CONCEPTS AROUND THIS THAT
01:31:42  CAN BE SUMMARIZED AS PYTHON IS THE FOREGROUND
01:31:45  PROCESS AND THAT'S WHY BASH MAKES SURE YOUR DATA
01:31:49  GOES THERE.
01:31:50  SO, THAT'S THE BASICS OF INPUT AND OUTPUT.
01:31:54  THERE'S A COUPLE OF SPECIAL TYPES OF INPUT WORTH
01:31:57  GOING INTO.
01:31:57  ONE OF MY FAVORITES IS CONTROL C.
01:32:01  SO, CONTROL C IS A CHARACTER SEQUENCE LIKE ANY
01:32:05  OTHER, AND THE WAY THAT TERMINALS WORK, IT'S SORT
01:32:08  OF A SIGNAL EVENT, SO LIKE ANY OTHER EVENT ON THE
01:32:13  KEYBOARD THAT YOU TYPE INTO YOUR TERMINAL WINDOW,
01:32:15  IT GOES TO THE SUBSYSTEM IN THE KERNEL.
01:32:19  BUT TERMIOS KNOWS THAT CONTROL C IS A BIT SPECIAL.
01:32:22  CONTROL C IS NORMALLY USED TO INTERRUPT A PROGRAM.
01:32:24  SO TERMIOS KNOWS IT NEEDS TO FIND A PROGRAM TO
01:32:29  WHICH IT CAN SEND AN INTERRUPT SIGNAL, WHICH WE
01:32:32  ABBREVIATE HERE AS SIGINT, NOT SINGLE
01:32:38  INTELLIGENCE.
01:32:39  AND THE INTERRUPT SINGAL, BECAUSE PYTHON IS THE
01:32:42  FOREGROUND PROCESS, GET PASSED TO THE PYTHON
01:32:44  INTERPRETER.
01:32:45  BY DEFAULT, WHAT THIS WOULD DO IS CAUSE PYTHON TO
01:32:48  QUIT, BUT PYTHON DOESN'T WANT TO QUIT WHEN YOU DO
01:32:50  CONTROL C.
01:32:50  IT WANTS TO RAISE AN EXCEPTION, A PYTHON
01:32:53  EXCEPTION, SO IT'S BOUND SOME SPECIAL CODE TO THE
01:32:57  INTERRUPT SIGNAL, CALLED A SIGNAL HANDLER.
01:33:02  YOU'VE PROBABLY TYPED CONTROL C INTO A PYTHON
01:33:05  INTERPRETER AND GOTTEN OUTPUT LIKE THIS.
01:33:06  WHEN YOU PRESS CONTROL C, YOU SEE KEYBOARD
01:33:09  INTERRUPT.
01:33:09  AND THAT'S BECAUSE PYTHON HAS SOME CODE INSIDE IT
01:33:12  THAT TURNS THAT SIGNAL FROM C INTO EFFECTIVELY
01:33:18  RAISE KEYBOARD INTERRUPT IN THE PYTHON PROCESS.
01:33:20  DOING THIS CONTROL C THING ISN'T REALLY NORMAL
01:33:25  INPUT.
01:33:25  IT'S THIS CRAZY SIDEWAYS INPUT WHERE THE OPERATING
01:33:28  SYSTEM STOPS THE PROGRAM ENTIRELY, FREEZES IT, AND
01:33:31  THEN CALLS WHATEVER FUNCTION PYTHON BOUND AS A
01:33:35  SIGNAL HANDLER.
01:33:36  SO IT'S ACTUALLY A LOT OF WORK TO BIND THE SIGNALS
01:33:38  AND HANDLE THEM CORRECTLY AND WE CAN ALL BE
01:33:40  GRATEFUL THAT PYTHON DOES THAT RIGHT.
01:33:42  SO, THERE ARE AT LEAST TWO SIGNALS THAT PYTHON
01:33:45  BINDS ONE BY THE HANDLER TO.
01:33:48  ONE IS SIG INTERRUPT AS WE SAW, THE OTHER IS
01:33:51  SIGPIPE, AND THAT'S A SIGNAL THAT THE OPERATING
01:33:54  SYSTEM WILL PASS IT UNDER SOME CIRCUMSTANCES
01:33:56  RELATED TO SUBPROCESSES.
01:33:57  THE REASON PYTHON BINDS THAT IS SO THAT IT CAN
01:34:00  CONVERT THIS SIGPIPE SIGNAL INTO AN APPROPRIATE
01:34:03  PYTHON EVENT FOR THE REST OF THE PYTHON
01:34:05  INTERPRETER.
01:34:07  THE ALTERNATIVE IS YOU WRITE THE CODE HALF IN C,
01:34:11  HALF IN PYTHON AND THAT WOULD BE SUPER CONFUSING.
01:34:14  SO THAT'S CONTROL C.
01:34:15  CONTROL D IS SIMILAR BUT DIFFERENT.
01:34:20  SO, LIKE ANYTHING ELSE, WHEN WE TYPE CONTROL D, IT
01:34:23  GOES TO THE TERMIOS LAYER.
01:34:25  HERE I'M GOING TO SHOW YOU WHAT WOULD HAPPEN IF WE
01:34:26  HAVE A PROGRAM CALLED CAT, NOT THE PROGRAM PYTHON.
01:34:30  BY DEFAULT, TERMIOS BEHAVIOR IS TO, INSTEAD OF
01:34:33  PASSING CONTROL D AS A BYTE SEQUENCE TO FILE
01:34:37  DESCRIPTOR 0, THE DEFAULT BEHAVIOR OF CONTROL D IS
01:34:40  THAT IT MEANS END OF FILE.
01:34:42  SO, FOR A SIMPLE PROGRAM LIKE CAT THAT DOESN'T
01:34:46  CAREFULLY RECONFIGURE THE TERMIOS LAYER, WHAT WILL
01:34:49  HAPPEN IS THE TERMIOS LAYER WILL CLOSE THAT FILE
01:34:51  DESCRIPTOR 0 AND CAT WILL SAY, WELL, THAT'S ALL
01:34:54  THERE IS ON THE STANDARD INPUT, I'D BETTER EXIT.
01:34:57  THAT'S WHAT CAT WOULD DO.
01:34:58  BUT MAYBE YOU CAN SEE WHAT PYTHON WOULD DO.
01:35:02  WHEN YOU TYPE HELLO.
01:35:06  OKAY, GREAT.
01:35:06  WHEN YOU GIVE CONTROL D TO THE PYTHON PROCESS, IT
01:35:10  GOES THROUGH THE SAME TERMIOS LAYER, IT GOES TO
01:35:13  THE SAME FILE DESCRIPTOR, BUT PYTHON HANDLES THAT
01:35:16  DIFFERENTLY.
01:35:17  AS MANY OF YOU KNOW, IN A PYTHON INTERACTIVE
01:35:19  SHELL, CONTROL D IS HOW YOU EXIT THE PYTHON
01:35:22  PROGRAM.
01:35:23  NOW, THAT'S ONE OF THREE WAYS THAT YOU CAN EXIT.
01:35:26  AND I'M GOING TO SHOW YOU THOSE THREE WAYS.
01:35:28  AND I'M GOING TO SHOW YOU HOW THE OPERATING SYSTEM
01:35:31  THEY ALL RESULT IN THE SAME THING.
01:35:32  SO FIRST THERE'S CONTROL D, WHICH IS EQUIVALENT TO
01:35:35  DOING IMPORT SYS AND SYS.EXIT.
01:35:39  YOU MAY HAVE DONE THIS AS YOU HAD A SCRIPT YOU
01:35:41  WANTED TO EXIT OUTSIDE OF THE NORMAL PROCESS.
01:35:43  YOU CAN ALSO RAISE A SYSTEM EXIT.
01:35:46  AND WHAT'S INTERESTING ABOUT ALL THREE OF THESE,
01:35:49  WE WERE TO GO TO OUR STRACE PYTHON COMMAND AGAIN,
01:35:52  IN ALL THREE OF THESE CASES, WE WOULD SEE THE
01:35:55  SYSTEM CALLED EXIT 0 WITH NO RETURN STATEMENT.
01:35:58  AND WE WOULD GET DROPPED BACK TO A SHELL PROMPT.
01:36:02  NOW, IF WE WERE TO ECHO DOLLAR QUESTION MARK,
01:36:07  WHICH IS THE STATUS CODE OF THE PREVIOUS PROGRAM,
01:36:11  THE EXIT STATUS CODE, TO BE PRECISE, WE WOULD SEE
01:36:14  0.
01:36:14  0 IS THE STANDARD EXIT CODE FOR PROGRAM.
01:36:18  WHAT'S INTERESTING IS, IF WE WERE TO DO IMPORT SYS
01:36:21  AND SYS.EXIT 1, WE CAN ACTUALLY CHANGE THE EXIT
01:36:24  CODE OF THE PYTHON PROCESS.
01:36:26  SO, PROCESS EXITS, ECHO DOLLAR QUESTION MARK, AND
01:36:31  WE GET 1 AS THE RESULT.
01:36:33  SO LET'S DO A QUICK RECAP.
01:36:37  WE START WITH A BASH PROCESS.
01:36:39  THAT BASH PROCESS GETS THE COMMAND THAT WE WANT TO
01:36:42  RUN PYTHON.
01:36:43  IT SEARCHES ITS PATH, FINDS THE PYTHON EXECUTABLE,
01:36:46  AND THEN FORKS AND EXECS TO CREATE THE PYTHON
01:36:50  PROCESS.
01:36:50  WHICH HAS AN ARG V LIST OF PYTHON BECAUSE WE
01:36:54  DIDN'T GIVE IT ANY EXTRA PARAMETERS.
01:36:56  THE PYTHON PROCESS ALSO HAS A SET OF FILE
01:37:00  DESCRIPTORS, HERE'S 0, 1, 2, STANDARD IN, STANDARD
01:37:03  OUT AND STANDARD ERROR.
01:37:04  AND ADDITIONALLY, THE PYTHON PROCESS BINDS
01:37:09  HANDLERS TO SOME SIGNALS, SPECIFICALLY SIGPIPE AND
01:37:15  SIGINT.
01:37:17  WE'RE GOING TO POST THESE SLIDES ONLINE AND ALSO
01:37:19  THIS IS A GREAT TIME TO TAKE A PHOTO IF YOU WANT
01:37:21  TO TAKE A PHOTO.
01:37:23  THIS IS THE MODEL THAT REALLY HELPED US, THIS
01:37:25  ABSTRACTION REALLY HELPED US SOLIDIFY WHAT'S
01:37:28  HAPPENING WITH THE PYTHON PROCESS ON A UNIX
01:37:30  SYSTEM.
01:37:30  IT HELPED FUEL OUR CURIOSITY.
01:37:34  AND WE THINK THAT YOU SHOULD BE CURIOUS ABOUT THIS
01:37:37  KIND OF STUFF.
01:37:38  WE HOPE THAT YOU ARE SEEING SOME OF THE TALKS
01:37:40  ALREADY OR SOME OF THE TALKS IN THE FUTURE ABOUT
01:37:43  SYSTEMS PROGRAMMING AT PYCON.
01:37:45  WE'D LIKE TO SAY THAT WHEN WE SUBMITTED THE
01:37:47  PROPOSAL FOR THIS TALK, NEITHER OF US KNEW ENOUGH
01:37:50  TO GIVE THIS TALK FROM MEMORY, WE USED THE SAME
01:37:52  TOOLS THAT WE DEMOED HERE, PSTREE AND STRACE AND
01:37:56  FILE AND HEX DUMP, TO LEARN ENOUGH TO BE ABLE TO
01:37:59  GIVE THIS TALK.
01:37:59  SO, IF YOU ARE CURIOUS, AND WE HOPE YOU ARE
01:38:02  CURIOUS, THERE ARE SOME TALKS AT THIS PYCON TO
01:38:05  EXPLORE MORE, ONE IS SYSTEMS PROGRAMMING AS A
01:38:07  SWISS ARMY KNIFE, AND, UNFORTUNATELY, YOU NEED A
01:38:09  TIME MACHINE TO GO VISIT IT THIS MORNING.
01:38:11  BUT YOU CAN ALSO VIEW IT ON PYVIDEO.ORG WHEN IT'S
01:38:16  RELEASED.
01:38:16  ALSO EXPLORING IS NEVER BORING: UNDERSTANDING
01:38:19  CPYTHON WITHOUT READING THE CODE.
01:38:20  ALLISON KAPTUR IS DOING TWO TALKS THIS AFTERNOON
01:38:22  AND BOTH OF THEM ARE PROBABLY WORTH ATTENDING, IF
01:38:24  THIS IS INTERESTING TO YOU.
01:38:25  AND THEN TOMORROW, WHERE IN YOUR RAM IS PYTHON SAN
01:38:29  DIEGO.PY, IT'S GOT A GREAT TITLE AND IT SHOULD BE
01:38:33  A LOT OF FUN.
01:38:34  THERE ARE A COUPLE OF TITLES BY FRIENDS WE'RE
01:38:36  GOING TO SHOUT-OUT.
01:38:38  ONE WILL REQUIRE A TIME MACHINE, SECURITY TUTORIAL
01:38:41  THAT ASHEESH GAVE.
01:38:46  AND THEN FINDING SPAMMERS AND SCAMMERS THROUGH
01:38:48  RATE CHECKING WITH PYTHON AND REDIS.
01:38:51  MICA AND JAY WORK WITH ME AT EVENTBRITE AND DO
01:38:54  AMAZING STUFF ON THE INTEGRITY TEAM MAKING SURE
01:38:56  THAT NOBODY CAN STEAL MONEY OR SPAM EVERYBODY.
01:38:58  AND I THINK, AT THAT POINT, THAT IS ABOUT IT.
01:39:02  WE WILL OPEN IT UP FOR QUESTIONS AND THANK YOU
01:39:04  VERY MUCH FOR COMING.
01:39:05   [ APPLAUSE ]
01:39:06  >> THANK YOU VERY MUCH.
01:39:12  YOU KNOW THE DRILL FOR QUESTIONS, FOLKS.
01:39:14  YOU WANT TO LINE UP AT THE MICROPHONE IN THE
01:39:16  CENTER OF THE ROOM.
01:39:16  DO WE HAVE QUESTIONS?
01:39:18  >> OH, NO.
01:39:21  >> OH, GREAT.
01:39:22  >> UH-OH.
01:39:24  [ Laughter ]
01:39:26  >> AUDIENCE: HI, GUYS.
01:39:27  THANK YOU.
01:39:27  GREAT TALK.
01:39:27  THAT WAS VERY VERY GOOD.
01:39:28  THIS MAY BE UNFAIR QUESTIONS.
01:39:32  BUT I WONDER IF YOU KNOW ANYTHING ABOUT SOME OF
01:39:34  THE QUESTIONS THAT HAVE OCCURRED TO ME WHEN I'VE
01:39:36  BEEN LOOKING INTO THIS STUFF.
01:39:37  YOU COME ACROSS THE WORD TTY AND PTY AND WHAT IS
01:39:41  THE DIFFERENCE BETWEEN THOSE?
01:39:43  THERE ARE LIBRARIES IN THE STANDARD LIBRARIES FOR
01:39:45  PYTHON.
01:39:45  IF YOU KNOW THE DIFFERENCE OF THOSE I'M
01:39:47  INTERESTED.
01:39:47  >> WE'LL STOP YOU WITH THAT ONE.
01:39:51  >> AUDIENCE: OKAY.
01:39:51  I'LL WAIT.
01:39:52  >> OKAY.
01:39:52  SO, WHAT I REALLY SHOULD DO IS IMPORT THEM AND RUN
01:39:56  HELP ON THEM.
01:39:57  BUT I'LL TELL YOU WHAT MY GUESS IS FIRST.
01:39:58  BASED ON -- HOPEFULLY IS BASED ON THINGS YOU MIGHT
01:40:02  HAVE BEEN ABLE TO INFER FROM THIS TALK.
01:40:04  SO TTY IS ABOUT HOW TO CHANGE THE CONFIGURATION OF
01:40:11  THE TERMIOS SUBSYSTEM, SO, FOR EXAMPLE, I REMARKED
01:40:15  THAT CAT TERMIOS, CLOSES FILE DESCRIPTOR 0 WHEN
01:40:18  YOU DO CONTROL D.
01:40:19  FOR PYTHON, CONTROL D ACTUALLY FLOWS IN AS A BYTE
01:40:22  SEQUENCE.
01:40:23  0X04.
01:40:24  THOSE ARE THE KINDS OF THINGS I IMAGINE YOU COULD
01:40:28  CHANGE IF YOU DO IMPORT TTY.
01:40:30  IMPORT TTY MIGHT LET YOU DRAW THINGS AT DIFFERENT
01:40:32  LOCATIONS ON THE SCREEN.
01:40:34  I DON'T KNOW IF IT DOES.
01:40:36  IMPORT PTY, I IMAGINE WOULD LET YOU CREATE NEW
01:40:41  VIRTUAL TERMINALS IN THE OPERATING SYSTEM BECAUSE
01:40:44  PTY REFERS TO THE OPERATING SYSTEM'S ABSTRACT
01:40:47  LAYER THAT SIMULATES THE TTYs AND, SO, IT'S
01:40:51  ABOUT MANIPULATING THEM AT THAT LAYER.
01:40:52  THAT WOULD BE MY GUESS.
01:40:53  IF YOU FIND OUT THE ANSWER, THEN LET ME KNOW.
01:40:55  >> AUDIENCE: THAT SOUNDS CONSISTENT WITH WHAT I
01:40:57  KNOW.
01:40:57  THERE'S AN OS DOT 4 SYSTEM.
01:41:03  SO I GUESS THEY DO SLIGHTLY DIFFERENT THINGS.
01:41:05  >> YEAH, PRESUMABLY OS DOT 4, THE DIRECT WRAPPER
01:41:10  AROUND THE SYSTEM CALL OF FORK.
01:41:13  AND PTY.FORK DOES SOMETHING USEFUL WITH BREAKING
01:41:17  OUT THE TERMINALS.
01:41:19  >> AUDIENCE: DOES IT START NEW TERMINALS?
01:41:22  >> NO.
01:41:22  >> AUDIENCE: THERE IS ALSO A TERMIOS LIBRARY SO
01:41:25  MAYBE THERE'S SOME DIFFERENCES TO WHAT TTY DOES.
01:41:30  THE OTHER ONE WAS, YOU KNOW, PIPES.
01:41:32  I WONDER IF THERE'S ANYTHING YOU CAN TALK TO ABOUT
01:41:34  THAT.
01:41:35  BECAUSE WHEN THERE'S AN OS.PIPE CALL IN THE
01:41:38  STANDARD LIBRARY.
01:41:39  AND IT GIVES YOU BACK TWO FILE DESCRIPTORS.
01:41:41  IN FACT, I THINK THERE'S A SIMILAR THING IN THE
01:41:43  PTY MODULE IF YOU WANT TO CREATE A NEW PTY, YOU
01:41:46  GET THREE FILE DESCRIPTORS, I THINK.
01:41:48  >> RIGHT.
01:41:49  >> AUDIENCE: THERE'S ONE CALLED A MASTER AND ONE
01:41:50  CALLED A SLAVE AND I'M VERY CONFUSED.
01:41:52  >> SO, THIS IS A GREAT TIME FOR ME TO SAY THAT I
01:41:56  KNEW SO MUCH LESS ABOUT PTYs AND TTYs UNTIL I
01:42:00  READ NELSON'S BLOG POST SERIES, "AN INTRODUCTION
01:42:04  TO TERMIOS."
01:42:07  WHICH YOU CAN TOTALLY SEARCH FOR IN YOUR FAVORITE
01:42:09  SEARCH ENGINE.
01:42:11  THAT BLOG POST SERIES ANSWERS THIS QUESTION ABOUT
01:42:14  SLAVE VERSUS MASTER, PTY DEVICES.
01:42:17  IN SUMMARY, THOUGH, IF YOU ARE WRITING A TERMINAL
01:42:22  EMULATOR, LIKE TERMINAL.APP BUT IN PYTHON, YOU
01:42:26  WOULD NEED TO CREATE A MASTER PTY SO THAT YOU CAN
01:42:30  THEN PASS THAT OFF TO OTHER PROGRAMS WHEN THEY
01:42:34  RUN.
01:42:34  AND WHAT THEY GET ACCESS TO IS THE SLAVE, AS I
01:42:37  UNDERSTAND IT.
01:42:38  >> AUDIENCE: RIGHT.
01:42:39  THESE ARE VERY RELEVANT QUESTIONS IF YOU WERE
01:42:41  TRYING TO CREATE A TERMINAL EVENT SUCH AS PYTHON
01:42:44  ANYWHERE.COM.
01:42:45  >> I WAS WAITING FOR THE PLUG.
01:42:47  PYTHONANYWHERE.COM.
01:42:49  >> AUDIENCE: OH, GOSH, DID THAT HAPPEN?
01:42:52  IT'S BEEN REALLY GOOD.
01:42:53  >> THANKS.
01:42:53  >> ANY OTHER QUESTIONS?
01:42:55  THANK YOU VERY MUCH, EVERYONE.
01:42:56  THANK YOU, GENTLEMEN.
01:42:57   [ APPLAUSE ]
01:42:57  
