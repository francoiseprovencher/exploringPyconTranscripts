

          041015517CFSTRATTON

13:34:03  >>  WE'RE GOING TO GET STARTED IN ABOUT A
13:34:05  MINUTE, SO PLEASE TAKE YOUR SEATS.
13:35:17  IT'S 2:35 P.M., AND TIME TO GET STARTED.
13:35:20  OUR NEXT SPEAKER, FRANK STRATTON, LIKES ROCK
13:35:25  CLIMBING AND DEVELOPER TOOLS.
13:35:27  >>  THANK YOU.
13:35:30  THANK ALL OF YOU FOR BEING HERE.
13:35:31  SO MY TALK IS ABOUT SMART SERVICES AND SMART
13:35:35  CLIENTS.
13:35:36  BASICALLY, HOW WE AT BUILD SERVICES AND BUILD
13:35:43  CODE.
13:35:44  I'M FRANK STRATTON, CT AND CO-FOUNDER OF
13:35:48  RUNSCOPE.
13:35:49  I WANT TO TELL YOU ABOUT WHAT RUNSCOPE DOES.
13:35:51  WE BUILD TOOLS TO HELP SOLVE PROBLEMS.
13:35:56  IT'S A WAY TO BUILD TESTS AND MONITORING FOR
13:35:59  APIS.
13:35:59  AND THE IDEA HERE IS THAT YOU CAN CHAIN
13:36:02  TOGETHER IS SERIES OF HTTP REQUESTS INTO A TEST
13:36:05  AND THEN EXTRACT DATA FROM THOSE REQUESTS AND
13:36:08  USE THEM AS VARIABLES IN FOLLOWING REQUESTS.
13:36:12  COME BACK BASICALLY LETTING YOU KNOW THAT APIS
13:36:16  ARE UP AND RUNNING ON THE CRITERIA.
13:36:10  YOU CAN WRITE ASSERTIONS ON THE RESPONSES THAT
13:36:19  THE OTHER TOOL WE HAVE IS OUR TRAFFIC
13:36:20  INSPECTOR, WHICH ALLOWS YOU TO CAPTURE INFLIGHT
13:36:24  HTTP REQUESTS, AND IT GIVES YOU THIS REAL-TIME
13:36:27  STREAM TO HELP YOU DEBUG BETWEEN YOUR CLIENT
13:36:30  AND THE APIS THAT YOU'RE USING.
13:36:34  TIMING INFORMATION AND ALL THAT KIND OF STUFF.
13:36:36  THE TOOLS THAT WE BUILD TO DO THAT, WE HAVE
13:36:38  OVER 60 SERVICES NOW THAT ARE INDEPENDENTLY
13:36:42  DEPLOYABLE BUT ONLY AN ENGINEERING TEAM OF
13:36:44  EIGHT PEOPLE.
13:36:45  AND KIND OF VERY EARLY ON, WE HAD THIS KIND OF
13:36:49  VERY INTENTIONAL GOAL TO BUILD LOTS OF SMALL
13:36:51  SERVICES.
13:36:54  IN THE LAST YEAR OR SO, THE HOT BUZZ WORD IS
13:36:57  MICRO-SERVICES.
13:36:57  BUT THIS WAS A VERY CONSCIOUS DECISION FOR US.
13:37:01  AND PART OF THAT YOU MIGHT ASK IS WHY.
13:37:04  WHY HAVE ALL THESE MOVING PARTS, ALL THIS
13:37:06  COMPLEXITY EVEN WHEN YOU HAVE JUST A SMALL TEAM
13:37:09  OF TWO PEOPLE OR FIVE PEOPLE OR, YOU KNOW,
13:37:11  EIGHT PEOPLE.
13:37:11  AND SO FOR US, THE ANSWER TO THAT WAS REALLY
13:37:18  ABLE TO HANDLE THE GROWTH OF OUR COMPANY AS WE
13:37:20  GROW AS WELL AS SCALING THE TEAM AND MAKING
13:37:15  ABOUT BOTH SCALING THE INFRASTRUCTURE, BEING
13:37:23  SURE THAT OUR PROCESSES AND OUR WAY OF
13:37:25  DEVELOPING SOFTWARE CAN MAP TO THE TEAMS AND
13:37:29  THE COORDINATION AND THE AMOUNT OF OVERHEAD
13:37:32  THAT COMES WITH GROWTH.
13:37:33  SO A LOT HAS BEEN SAID ALREADY ABOUT
13:37:36  MICRO-SERVICES, WHAT THEY ARE, HOW THEY WORK.
13:37:38  THERE'S A LOT OF GOOD TALKS, A LOT OF GOOD
13:37:41  ARTICLES OUT THERE.
13:37:42  SO THIS TALK IS REALLY -- WE'LL TOUCH ON SOME
13:37:45  OF THOSE THINGS.
13:37:45  BUT REALLY I WANTED TO FOCUS ON KIND OF HOW WE
13:37:47  DO THINGS IN PRACTICE, WHAT TECHNOLOGIES WE
13:37:50  USE, AND HOW WE ORGANIZE OUR CODE TO MAKE ALL
13:37:53  THIS WORK TO A HIGH LEVEL.
13:37:59  ONE OF THE REASONS WE CHOSE THIS ARCHITECTURE
13:38:01  IS THAT MICRO-SERVICES BY DEFINITION ARE HIGHLY
13:38:04  INDEPENDENT SMALL COMPONENTS.
13:38:06  AND FOR US THAT MEANS BOTH INDEPENDENT CODE
13:38:09  BASES, INDEPENDENT DEPLOYABILITY AND HAVING
13:38:14  DIFFERENT TEAMS OWN DIFFERENT PARTS OF THE
13:38:16  STACK WITHOUT HAVING TO COORDINATE WITH EACH
13:38:19  OTHER.
13:38:22  MOVING PARTS.
13:38:23  YOU HAVE A LOT OF DIFFERENT THINGS CHANGING, A
13:38:20  NEEDLESS TO SAY, THAT MEANS THERE'S A LOT OF
13:38:25  LOT OF THINGS BEING SHIPPED TO PRODUCTION ALL
13:38:28  THE TIME, AND IT TAKES A LOT OF WORK TO MAKE
13:38:30  SURE THIS WORKS SMOOTHLY, AND IT DOESN'T FALL
13:38:32  APART.
13:38:33  SO I THINK THE BIGGEST LESSON THAT WE'VE
13:38:35  LEARNED OVER THE LAST TWO AND-A-HALF YEARS FOR
13:38:37  RUNNING MICRO-SERVICES ARCHITECTURE IS THAT IF
13:38:39  YOU DON'T INVEST IN INFRASTRUCTURE, DON'T
13:38:42  INVEST IN MICRO-SERVICES.
13:38:43  ANOTHER WAY OF THINKING ABOUT THIS IS THAT A
13:38:48  MICRO-SERVICES ARCHITECTURE IS TAKING THIS IDEA
13:38:50  OF WHAT A SERVICE-ORIENTED ARCHITECTURE IS AND
13:38:55  APPLYING THAT TO A DEVOPS BENT AND STRUCTURE
13:38:59  TOOLING AROUND THAT TO MAKE THIS ALL POSSIBLE.
13:39:02  TO GET INTO MORE CONCRETE EXAMPLES, KIND OF IN
13:39:05  THE BEGINNING, WE HAD OUR DASHBOARD, WHICH IS
13:39:07  OUR WEBSITE.
13:39:09  AND THEN WE WANTED TO BUILD ANOTHER SERVICE TO
13:39:11  ENCAPSULATE ALL OF OUR CUSTOMER DATA AND GIVE
13:39:15  US A DATA ACCESS LAYER.
13:39:17  SO WE CALL THAT SERVICE IDENTITY.
13:39:20  AND IDENTITY LETS YOU GET THAT ABOUT CUSTOMERS,
13:39:26  GET CONFIGURATION DATA.
13:39:29  AND SO KIND OF IN THIS WORLD WE'VE GOT THESE
13:39:23  ABOUT TEAMS, AND KIND OF JUST GENERALLY PUT AND
13:39:32  TWO SERVICES.
13:39:33  ONE OF THEM IS LIVING ON HOST 001 AND ONE OF
13:39:36  THEM IS LIVING ON HOW DO I ACTUALLY IMPLEMENT
13:39:42  THIS FUNCTION AND GET TEAMS.
13:39:43  SO THE MOST STRAIGHTFORWARD WAY OF DOING THAT
13:39:46  IS HEY WE'LL JUST USE REQUESTS, WE'LL JUST
13:39:48  INPUT REQUESTS, I'LL JUST BUILD A URL TO HOST
13:39:52  TWO/TEAMS AND THEN I'LL DO A GET REQUEST TO
13:39:56  THAT AND RETURN THE JSON THAT COMES BACK.
13:39:59  SO NOW THIS IS CODE AND IT WORKS KIND OF.
13:40:03  SO THE TRICKY THINGS HERE ARE WHEN YOU START TO
13:40:06  TALK, WHEN YOU'RE GOING FROM LIKE A MONOLITHIC
13:40:08  CODE BASE TO THIS SERVICE ORIENTED ARCHITECTURE
13:40:11  IS THAT THINGS ARE ALWAYS CHANGING, HOSTS THAT
13:40:14  YOU HAVE BEEN UP AND RUN SOMETIMES DIE AND YOU
13:40:18  HAVE TO CHANGE AND REPLACE HOSTS.
13:40:20  SO WHAT HAPPENS WHEN YOU MIGRATE FROM HOST TWO
13:40:25  TO HOST THREE.
13:40:26  NOW YOU'VE GOT TO CHANGE YOUR CODE AND DEPLOY
13:40:28  THAT JUST SO YOU CAN ADDRESS THAT IN YOUR
13:40:30  SERVICE.
13:40:31  KIND OF A BIGGER QUESTION HERE IS WHAT HAPPENS
13:40:34  SO IF YOU'VE GOT A LOCAL ENVIRONMENT, A TESTING
13:40:36  ENVIRONMENT, AND A PRODUCTION ENVIRONMENT, ALL
13:40:33  IF YOU HAVE MULTIPLE ENVIRONMENTS.
13:40:38  THOSE THINGS NEED TO TALK TO DIFFERENT HOSTS
13:40:42  WHETHER IT'S YOUR LOCAL HOST, YOUR TEST CLUSTER
13:40:45  OR WHETHER IT'S YOUR PRODUCTION CLUSTER.
13:40:47  SO KIND OF HARD CODING THESE HOST NAMES TURNS
13:40:50  INTO A BIG MESS.
13:40:52  SO WE WANTED TO AVOID ALL OF THAT.
13:40:54  BUT REALLY THE FIRST QUESTION THAT YOU HAVE TO
13:40:56  ANSWER WHEN HAVING ALL THESE SERVICES IS JUST
13:40:59  HOW DO YOU FIND THE SERVICE.
13:41:01  SO OUR ANSWER TO THAT QUESTION WAS SOMETHING WE
13:41:03  CALLED SMART CLIENT.
13:41:06  SMART CLIENT DOES A FEW THINGS.
13:41:08  SO FIRST IT'S A WRAPPER AROUND PYTHON REQUESTS.
13:41:13  SO YOU CAN JUST DROP IT IN WHEREVER YOU USE
13:41:15  REQUESTS AND IT JUST WORKS.
13:41:20  SO IT HAS THE SAME API, AND GIVES YOU THE SAME
13:41:23  RESPONSE OBJECTS.
13:41:24  SO THE NEXT THING INSTEAD OF HARD CODING ALL
13:41:26  THESE DIFFERENT HOST NAMES IN OUR CLUSTER, WE
13:41:28  WANTED TO GO A DIFFERENT APPROACH, AND THAT WAS
13:41:30  TO INVENT SOMETHING CALLED SERVICE URLS.  AND
13:41:34  SO SMART CLIENT ACCEPTS THESE THINGS THAT LOOK
13:41:41  SO IT STARTS WITH SERVICE:// AND THEN THE NAME
13:41:44  OF A SERVICE.
13:41:37  LIKE HTTP URLS BUT AREN'T REALLY.
13:41:45  SO THE NICE THING ABOUT THIS IS THAT THIS
13:41:47  SERVICE URL WORKS IN YOUR LOCAL ENVIRONMENT, IN
13:41:50  YOUR TESTING ENVIRONMENT AND YOUR PRODUCTION
13:41:52  ENVIRONMENT, AND YOU DON'T HAVE TO CHANGE OR
13:41:53  UPDATE ANY OF THE CODE TO MAKE THAT HAPPEN.
13:41:57  SO SMART CLIENT REALLY DOES KIND OF TRANSLATE
13:42:02  THAT SERVICE URL INTO AN ACTUAL SERVICE HOST
13:42:06  NAME AT RUN TIME.
13:42:08  THE NEXT THING IT DOES IS IT WILL DO
13:42:10  AUTOMATICALLY -- IT WILL AUTOMATICALLY RETRY,
13:42:14  GET, PUT, DELETE REQUESTS JUST IN CASE THERE'S
13:42:17  A TEMPORARY NETWORK OUTAGE, OR, IF YOU'RE LOAD
13:42:20  BALANCING ACROSS LOTS OF BACK ENDS, AND ONE OF
13:42:22  THOSE REQUESTS FAILS, IT MIGHT SUCCEED ON THE
13:42:26  NEXT ONE.
13:42:26  THE OTHER THING IT DOES IS IT HAS AN OPTION TO
13:42:28  LET YOU RUN ASYNCHRONOUSLY.
13:42:31  SO IF YOU HAVE LOTS OF CALLS YOU NEED TO MAKE
13:42:33  IN PARALLEL, YOU CAN FIRE THEM ALL AT ONCE AND
13:42:35  WAIT FOR THE RESPONSES TO COME BACK SO YOU'RE
13:42:36  NOT KIND OF BLOCKING AND WAITING FOR EACH ONE
13:42:40  OF THESE IN SERIAL.
13:42:43  WORK, AND WHAT IS THE MECHANISM THAT'S POWERING
13:42:47  ALL OF THIS.
13:42:41  SO NOW THE QUESTION IS HOW DOES THIS ACTUALLY
13:42:47  AND FOR US, THE ANSWER TO THAT QUESTION IS ALSO
13:42:49  A SERVICE.
13:42:50  SO WE HAVE A SERVICE CALLED ATLAS WHICH IF YOU
13:42:53  CAN MAYBE GUESS CONTAINS INFORMATION ABOUT HOW
13:42:56  OUR CLUSTER IS MAPPED.
13:42:58  SO ATLAS STORES INFORMATION IN DYNAMODB AND
13:43:03  ZOOKEEPER, AND WE BASICALLY SAY WHENEVER A NEW
13:43:06  SERVICE IS CREATED, WHENEVER YOU ATTACH A
13:43:08  SERVICE TO A PARTICULAR HOST, WE RECORD THOSE
13:43:11  BITS AS META DATA, AND FOR INSTANCE, IN
13:43:14  ZOOKEEPER, IT STARTS WITH THE HOST NAME AND
13:43:21  WHAT PORT IT'S RUNNING ON, WHETHER OR NOT IT'S
13:43:24  ABLED OR DISABLED AND ALL THAT STUFF.
13:43:26  SO THAT IS REALLY A SERVICE THAT ENCAPSULATES
13:43:28  ALL OF THAT CLUSTER CONFIGURATION.
13:43:32  THE NEXT PART OF THIS IS PYTHON WE CALL SIDE
13:43:36  CAR, AND SIDE CAR RUNS ON EVERY SINGLE HOST IN
13:43:38  OUR CLUSTER AND DOES A FEW DIFFERENT THINGS.
13:43:42  IT RUNS A HAPROXY LOCAL ON THOSE HOSTS, AND IT
13:43:47  CONFIGURES IT BY READING ATLAS, AND THEN IT
13:43:51  DOES THAT BY SETTING UP ZOOKEEPER WATCHER TO
13:43:55  LET YOU KNOW IF YOU'VE DISABLED A HOST OR A
13:43:59  AND THOSE CHANGES WILL KICKOFF A RELOAD OF
13:44:01  HAPROXY.
13:43:57  SERVICE OR ADDED A NEW HOST OR SERVICE.
13:44:02  SO WHAT IN EFFECT HAPPENS IF YOU'VE GOT THIS
13:44:06  CLUSTER OF MACHINES AND SIDE CAR AND HAPROXY
13:44:08  ARE RUNNING ON EACH OF THEM, AND WHENEVER YOU
13:44:11  NEED TO MAKE A SERVICE CALL, YOU'RE ACTUALLY
13:44:13  TAKING THAT SERVICE CALL AND MAKING IT TO A
13:44:15  LOCAL HOST.
13:44:17  AND THAT SERVICE CALL GETS SENT TO SERVICE A
13:44:20  WHEREVER IT'S LIVING IN THE CLUSTER.
13:44:21  AND THEN IF YOU WANT TO ADDRESS SERVICE B, YOU
13:44:24  ADDRESS LOCAL HOST, AND IT GOES OFF TO SERVICE
13:44:27  B.
13:44:28  THAT MAKES THE IMPLEMENTATION OF WHAT IT'S
13:44:30  DOING PRETTY SIMPLE.
13:44:33  IT TAKES THAT SERVICE URL, PARSES OUT OF THE
13:44:35  SERVICE NAME AND THEN USES A CUSTOM HEADER THAT
13:44:39  WE'VE ADDED CALLED RUNSCOPE SERVICE AND PASSES
13:44:42  ON THAT SERVICE NAME.
13:44:43  AND THEN THE ACTUAL REQUEST IS MADE TO LOCAL
13:44:45  HOST AND THEN THE HAPROXY FRONT END BOARD.
13:44:48  SO THE INTERESTING THING WE'RE DOING WITH
13:44:50  HAPROXY, WE'RE ACTUALLY USING A FEATURE CALLED
13:44:53  ACL WHERE YOU CAN DYNAMICALLY ROUTE A REQUEST
13:44:58  REQUEST.
13:44:58  SO HERE, HTTP MODE, AND THEN WE'RE CONSTRUCTING
13:44:56  BASED ON INFORMATION THAT'S COMING IN IN THAT
13:45:06  AN ACL CALLED HOST API AND WE'RE DOING A
13:45:10  PATTERN MATCH ON THAT RUNSCOPE SERVICE HOST
13:45:13  ADDER THAT WE'VE ADDED IN SMART CLIENT.
13:45:15  AND IF IT MATCHES API, WE'RE GOING TO SET THAT
13:45:19  IN THE ACL, AND THEN WE'RE GOING TO USE API
13:45:23  BACK END.
13:45:24  SO WE'VE CONDUCTED ONE STANZA FOR ALL OF OUR
13:45:27  SERVICES AND THEN DYNAMICALLY AT RUN TIME,
13:45:29  BASED ON WHAT IS PRESENT, IT WILL CHOOSE THE
13:45:32  APPROPRIATE BACK ENDS AND THOSE BACK ENDS WERE
13:45:35  CONFIGURED WITH THE CLUSTER FROM ATLAS.
13:45:38  SO THAT MAKES THE IMPLEMENTATION OF THIS REALLY
13:45:40  EASY AND THE BIGGEST BENEFIT THAT WE GOT FROM
13:45:43  DOING IT THIS WAY BECAUSE WHEN WE ORIGINALLY
13:45:45  BUILT SMART CLIENT WE HAD A LOT OF HARD-CODED
13:45:49  SERVICE NAMES AND HARD-CODED PORT NUMBERS AND
13:45:52  LOTS OF INFORMATION THAT WE KNEW, BUT THAT WAS
13:45:55  ALL KIND OF BAKED INTO THE LIBRARY, SO WHENEVER
13:45:57  WE WOULD ADD A NEW SERVICE YOU WOULD HAVE TO
13:45:59  UPDATE THE LIBRARY, DO A NEW BUILD, AND THEN
13:46:03  DEPLOY ALL THE SERVICES THAT USED IT.
13:46:05  MOVING TO THIS HAPROXY DYNAMIC HEADER ROUTING,
13:46:11  AND NOW INSTEAD OF DOING A CODE DEPLOYING TO
13:46:13  PICK UP A NEW SERVICE, IT'S JUST ADDING A NEW
13:46:09  IT'S ALL KIND OF DATA DRIVEN NOW.
13:46:16  LINE AND A DATABASE ESSENTIALLY.
13:46:19  SO THE CODE FOR SMART CLIENT NOW IS PRETTY
13:46:22  STATIC.
13:46:23  WE'VE GOTTEN IT TO A GOOD PLACE AND WE DON'T
13:46:25  HAVE TO DO NEW BUILDS, NEW DEPLOYS JUST TO PICK
13:46:28  UP NEW SERVICES THAT GET ADDED TO THE CLUSTER.
13:46:32  SO THAT'S KIND OF, YOU KNOW, THE FIRST QUESTION
13:46:34  IS HOW DO YOU FIND A NEW SERVICE.
13:46:37  THE NEXT QUESTION WE HAD TO ASK OURSELVES IS,
13:46:40  OKAY, HOW DO I MAKE SERVICE BUILDING REALLY
13:46:43  EASY.
13:46:43  AND OUR ANSWER TO THAT UNSURPRISINGLY WAS
13:46:47  CALLED SMART SERVICE.
13:46:48  SO SMART SERVICE IS A LIBRARY THAT'S BUILT ON
13:46:50  TOP OF FLASK, FLASK-RESTFUL, A FLASK RESTFUL.
13:46:59  WE STARTED WITH THIS BASE AND STARTED ADDING
13:47:01  MORE AND MORE PACKAGES ON TOP OF IT TO KIND OF
13:47:04  BUNDLE TOGETHER A LOT OF COMMON FEATURES AND
13:47:06  FUNCTIONALITY THAT WE FOUND WE NEEDED.
13:47:08  SO ONE OF THEM IS AN OPEN SOURCE PROJECT THAT
13:47:09  WE HAVE CALLED HEALTH CHECK WHICH MAKES IT EASY
13:47:11  TO ADD HEALTH CHECKS TO FLASK APPS.
13:47:18  SET OF EITHER THIRD PARTY PROGRAMMING PACKAGES
13:47:20  OR OTHER INTERNAL SERVICES OR LIBRARIES THAT
13:47:16  THE KIND OF NEXT BIT BUILD ON TOP OF THAT IS A
13:47:23  WE'VE WRITTEN TO DEAL WITH A LOT OF THAT
13:47:25  BOILERPLATE CODE.
13:47:26  SO WE USE BUGSNAG FOR DOING LOGGING.
13:47:31  AND THERE'S COUPLE PRODUCTS WE HAVE CALLED
13:47:34  RUNSCOPE, DAEMON, WHICH MAKES RUNSCOPE TASKS
13:47:38  EASY, AND THEN ALCHEMIST, WHICH IS OUR LIBRARY
13:47:42  FOR DOING DATA COLLECTION AND TEARDOWN.
13:47:44  AND THEN SMART CONFIG, WHICH WORKS TOGETHER
13:47:47  WITH SMART WORKS, WHICH WE WERE DOING FROM THE
13:47:52  BEGINNING DEALING WITH HARD-CODED CONSTANTS AND
13:47:55  HARD KEYS AND OTHER CONFIGURATION THINGS.
13:47:59  WE DUMP THAT INTO A PYTHON FILE AND SAY CONFIG,
13:48:03  RUN ASDB AND RUN THAT ALL THROUGH OUR CODE.
13:48:07  WHEN WE BUILT SMART SERVICE, AND WE WANTED TO
13:48:09  KEEP THAT KIND OF INTERACTION BECAUSE IT WAS
13:48:11  VERY EASY AND VERY PREDICTABLE TO KNOW LIKE,
13:48:14  OKAY, I NEED TO FIND, YOU KNOW, THIS API KEY OR
13:48:18  I NEED TO FIND WHAT DATABASE I'M USING, IT WAS
13:48:22  ALL KIND OF LOCATED IN ONE PLACE.
13:48:23  SO THEN WE BUILT SMART CONFIG, WHICH BASICALLY
13:48:26  LETS YOU LOAD THAT CONFIG MODULE DIRECTLY AS A
13:48:31  SET OF DEFAULTS.
13:48:35  QUERY ATLAS AT RUNTIME AND GET OTHER VARIABLES
13:48:39  AND OVERWRITE THOSE DEFAULTS IF YOU NEED TO.
13:48:31  THE OTHER THING SMART CONFIG DOES IS IT CAN
13:48:42  SO THAT'S REALLY HELPFUL FOR PUTTING SECRET
13:48:45  TOKENS INTO YOUR SOURCE CONTROL AND CHECKING
13:48:48  THOSE INTO GITHUB BECAUSE YOU CAN EITHER EMPTY
13:48:52  PLACEHOLDERS OR NOT SET THOSE IN YOUR SOURCE AT
13:48:54  ALL AND HAVE THAT COME FROM ATLAS VIA SMART
13:48:57  CONFIG.
13:48:58  SO THE OTHER THING HERE IS THAT WE'RE
13:48:59  INITIALIZING SMART SERVICE.
13:49:02  AND THE THING WE GET OUT IS AN APP OBJECT.
13:49:04  AND THAT'S BASICALLY A WRAPPED FLASK APP.
13:49:07  SO IT HAS ALL THE THINGS THAT A NORMAL FLASK
13:49:10  APP HAS ON IT.
13:49:12  BUT BASED ON THE VALUES OF THAT CONFIGURATION,
13:49:15  WE GET A LOT OF EXTRA PROPERTIES ON THAT
13:49:17  OBJECT.
13:49:17  SO YOU CAN ALWAYS NO MATTER WHERE YOU'RE AT IN
13:49:18  YOUR CODE FROM FLASK IMPORT CURRENT APP AND
13:49:22  THEN USE CURRENT APP. REALM, WHICH WILL TELL
13:49:27  YOU AM I IN OUR LOCAL ENVIRONMENT, A TESTING
13:49:30  ENVIRONMENT, IN PRODUCTION.
13:49:31  IT HAS THINGS LIKE IF YOU SPECIFY A RED SDB IN
13:49:35  THAT CONFIG, IT WOULD CONSTRUCT AND PUT A READ
13:49:42  YOU DON'T NEED TO KNOW IF YOU NEED DOES IT MAP
13:49:46  TO, WHERE DO YOU ROUTE THIS REQUEST.
13:49:40  CLIENT ON THE FLASK APP FOR YOU.
13:49:47  AS A DEVELOPER, YOU JUST STATE, OH, YEAH, JUST
13:49:50  IMPORT THE CURRENT APP, GET THE REDSES CLIENT
13:49:55  AND START USING IT.
13:49:56  THE SAME THING IF YOU CONFIGURED POSTGRESQL.
13:49:59  AND THEN IT HAS THE FLASK RESTFUL API OBJECT SO
13:50:04  YOU CAN START ADDING NEW ROUTES TO YOUR
13:50:06  SERVICE.
13:50:06  THE OTHER THING THAT SMART SERVICE DOES IS IT
13:50:09  BUILDS THIS COMMON LOGIN CONFIGURATION.
13:50:11  SO ONCE AGAIN, EVERYTHING IS PRETTY
13:50:14  STANDARDIZED.
13:50:14  WE PUT EVERYTHING IN ONE LOCATION.
13:50:17  WE CAN FIGURE OUR LOG FORMATS ALL AT ONCE, AND
13:50:20  AS A DEVELOPER YOU DON'T HAVE TO THINK HOW DO I
13:50:22  ACCESS THE LOGGER.
13:50:27  THE RIGHT OUTPUT FORMAT OR THE ACCESS LOG OR
13:50:30  THE AIR LOG OR IF I'M USING BUGSNAG TO NOTIFY
13:50:33  AN COMPETITION HAS HAPPENED.
13:50:35  YOU JUST KIND OF IMPORT THOSE THINGS AND JUST
13:50:39  USE THEM.
13:50:39  AND THIS IS KIND OF BUILDINGS CONSISTENCY
13:50:40  ACROSS ALL OF OUR DIFFERENT SERVICES.
13:50:49  WE CAN AUTO GENERATE THESE SERVICE SKELETONS
13:50:51  SINCE ALL OF OUR PROJECTS LOOK THE SAME NOW AND
13:50:44  THE OTHER THING WE HAVE WITH SMART SERVICE IS
13:50:54  BEHAVE IN THE SAME WAYS WE CAN ACTUALLY JUST
13:50:56  RUN ONE COMMAND, GENERATE SERVICE, AND THAT
13:50:58  WILL BUILD A LOT OF THINGS FOR YOU.
13:51:00  SO IT HANDLES ALL THAT BOILERPLATE OF, YOU
13:51:03  KNOW, CONSTRUCTING A NEW SMART SERVICE OBJECT,
13:51:06  DOING KIND OF DEFAULT VALUES, IT GIVES YOU A
13:51:11  DIRECTORY, A GIT REPERTOIRE, A VIRTUAL
13:51:15  ENVIRONMENT AND ALL THOSE COMPOSITES INSTALLED
13:51:20  INTO THE VIRTUAL ENVIRONMENT.
13:51:22  SO YOU WRITE ONE COMMAND, AND THEN A MINUTE
13:51:24  LATER YOU HAVE THIS FULLY OPERATIONAL SERVICE
13:51:27  THAT YOU CAN TAKE AND YOU CAN DEPLOY IT RIGHT
13:51:29  AWAY.
13:51:30  AND SO IT'S KIND OF GETS ALL OF THAT OVERHEAD
13:51:33  OF, YOU KNOW, HOW DO I GET STARTED, HOW DO I
13:51:36  SET SOMETHING ELSE -- SOMETHING NEW UP.
13:51:39  AND IT KIND OF REDUCES THAT INTO A SINGLE
13:51:42  COMMAND AND NOW YOU CAN MOVE ON AND ACTUALLY
13:51:43  WRITE USEFUL TOWED CODE.
13:51:46  AND TO SMART SERVICE AND ALL THE THINGS WE PUT
13:51:48  INTO IT AS WELL AS SMART CLIENT ITSELF GO INTO
13:51:51  THIS IDEA OF REDUCING COGNITIVE OVERHEAD.
13:51:55  ABOUT OR THE AMOUNT OF TIMES YOU HAVE TO
13:51:57  CONTEXT SWITCH FROM, OKAY SO I NEED TO ACCESS A
13:51:53  THE AMOUNT OF THINGS THAT YOU HAVE TO THINK
13:52:00  DATABASE BUT WHERE IS THAT DATABASE OR HOW DO I
13:52:02  CONSTRUCT A NEW SEQUEL MODEL, AND THEN WHERE DO
13:52:05  I FIND THE DATABASE SESSION AND WHAT DO I DO
13:52:08  WHEN THE APP IS, YOU KNOW, DONE WITH THIS
13:52:10  REQUEST, DO I HAVE TO TEAR IT DOWN.
13:52:12  ALL THESE THINGS ARE KIND OF ANSWERED FOR YOU.
13:52:14  AND AS A DEVELOPER, YOU JUST SAY, HEY,
13:52:16  DATABASE, DO THIS THING THAT I WANT.
13:52:18  RIGHT?
13:52:18  AND THEN MOVE ON TO THE NEXT THING YOU WANT TO
13:52:21  DO.
13:52:22  SO THIS IS REALLY HELPFUL FOR MANAGING LOTS AND
13:52:25  LOTS OF SERVICES BECAUSE ALL OF THESE SERVICES
13:52:26  LOOK AND BEHAVE AND ACT THE SAME WAY.
13:52:29  IF YOU FIX A BUG HERE, AND THEN YOU NEED TO
13:52:33  CONTACT AND SWITCH AND MOVE TO ANOTHER PROJECT
13:52:35  AND IMPLEMENT A FEATURE, ALL THE LOGGING IS THE
13:52:38  SAME, ALL THE DATABASE HANDLING IS THE SAME.
13:52:40  YOU DON'T HAVE TO THINK ABOUT THOSE LITTLE
13:52:42  DETAILS.
13:52:43  YOU CAN FOCUS ON WRITING ACTUAL CODE.
13:52:46  SO THAT'S COINED OF WHAT WE DID TO MAKE
13:52:50  AND SO NOW WE HAVE A LOT OF SERVICES.
13:52:51  SO NEXT QUESTION IS WHAT HAPPENS.
13:52:48  BUILDING SERVICES REAL EASY.
13:52:54  RIGHT?
13:52:55  SO A LOT.
13:52:57  SO THE NEXT BIT OF THIS TALK IS ABOUT SOME OF
13:52:59  THE LESSONS THAT WE'VE LEARNED OR SOME OF THE
13:53:01  THINGS THAT WE'VE DECIDED TO KIND OF BAKE INTO
13:53:03  OUR PROVES
13:53:04  PROCESS TO MAKE LIVING IN A WORLD WITH LOTS OF
13:53:06  SERVICES REALLY EASY.
13:53:10  SO THE FIRST LESSON NOT SURPRISING IS YOU HAVE
13:53:12  TO AUTOMATE EVERYTHING.
13:53:14  FOR US, THAT MEANS SIT -- SETTING UP NEW
13:53:19  SERVERS WHEN WE BRING THEM ONLINE.
13:53:21  THAT MEANS, YOU KNOW, WE USE PUPPET TO KIND OF
13:53:24  GENERATE TEMPLATES FOR ALL OF OUR INIT SCRIPTS,
13:53:29  ALL OF OUR MONITORING.
13:53:31  EVERYTHING YOU DO HAS TO BE KIND OF REPEATABLE
13:53:39  AND DEPLOYABLE WITHOUT HAVING TO THINK ABOUT
13:53:41  IT.
13:53:41  SO YOU HAVE TO INVEST A LOT IN DEVOPS AND VEST
13:53:46  IN AUTOMATION TOOLS AND SCRIPTS, TO MAKE
13:53:50  RUNNING 60 SERVICES, MAKE RUNNING A HUNDRED
13:53:54  SERVICES REASONABLE.
13:53:58  THESE SERVICES AND THEY'RE ALL OPERATING AND
13:54:00  TALKING TO EACH OTHER, AND WE'VE GOT ALL THESE
13:53:56  THE NEXT THING WE LEARNED IS ONCE WE BUILT
13:54:02  NICE AND INTERESTING TOOLS, THAT IS YOU
13:54:04  ACTUALLY BECOME LANGUAGE AGNOSTIC.
13:54:07  SO MOST OF OUR STUFF IS PYTHON.
13:54:10  A LOT OF PYTHON SERVICES.
13:54:11  BUT ABOUT A YEAR AGO WE STARTED WRITING A LOT
13:54:13  OF GO CODE.
13:54:15  AND SO WHEN WE, YOU KNOW, FIGURED OUT THAT KIND
13:54:17  OF FIRST BIT OF HOW DO YOU BUILD AND DEPLOY GO,
13:54:21  AND WE HAD A GO SERVICE UP AND RUNNING, IT
13:54:23  BECAME REALLY EASY TO INTEGRATE THAT WITH THE
13:54:25  REST OF OUR CLUSTER.
13:54:26  WE GOT ALL OF THESE NICE FEATURES THAT ALREADY
13:54:29  EXISTED FROM OUR IDENTITY SERVER, KNOWING ABOUT
13:54:32  CUSTOMERS.
13:54:33  RIGHT?
13:54:33  AND SO A PIECE OF GO CODE DOESN'T NEED TO KNOW
13:54:36  WHAT FORMAT IS THAT DATA IN, OR YOU KNOW, WHAT
13:54:40  DATABASE DO I NEED OR WHAT ORM DO I NEED.
13:54:42  IT JUST NEEDS TO KNOW I'VE GOT THIS API THAT I
13:54:44  CAN CALL TO GET ALL THIS DATA BACK IN JSON.
13:54:48  AND SO WE'RE ABLE TO KIND OF QUICKLY SPIN UP
13:54:51  EITHER NEW PROJECTS, THIRD PARTY TOOLS,
13:54:57  USEFUL IN THE CONTEXT OF OUR CLUSTER.
13:54:59  SO WE SAY THAT HTTP IS OUR COMMON LANGUAGE.
13:54:53  ANYTHING THAT TALKS HTTP BECOMES IMMEDIATELY
13:55:05  THE NEXT BIT WAS MORE OF A PHILOSOPHICAL
13:55:11  DECISION FOR US EARLY ON.
13:55:12  BUT IT'S REALLY PAID OFF.
13:55:14  THERE ARE NO SHARED DATABASES BETWEEN OUR
13:55:17  SERVICES.
13:55:17  SO WE COULD HAVE IMAGINED A WORLD WHERE YOU
13:55:19  HAVE OUR DASHBOARD, OUR TRAFFIC GATEWAY, OUR
13:55:25  API ALL TALKING TO THE SAME POSTGRESQL DATABASE
13:55:27  FOR CUSTOMER DATA.
13:55:29  THE PROBLEM THAT HAPPENS WHEN YOU HAVE THIS
13:55:30  KIND OF ARCHITECTURE IS THAT YOU HAVE THIS
13:55:32  SHARED DEPENDENCY BETWEEN NOT ONLY THE TYPE OF
13:55:36  DATABASE THAT YOU'RE ACTUALLY RUNNING, BUT ALSO
13:55:38  THE SCHEMA THAT THAT DATABASE HAS.
13:55:41  SO IF WE ADD A NEW COLUMN, MAKE A SCHEMA
13:55:44  UPDATE.
13:55:45  THEN WE HAVE TO DEPLOY CODE TO ALL THREE OF
13:55:48  THESE OTHER LOCATIONS.  THE REAL PROBLEM WITH
13:55:51  THAT IS THAT IT'S NO LONGER AN INDEPENDENT
13:55:53  SYSTEM.
13:55:53  YOU'RE TAKING WHAT USED TO BE THREE INDEPENDENT
13:55:56  SERVICES AND ACTUALLY TYING THEM TOGETHER VERY
13:55:59  AND SO WHENEVER YOU HAVE THIS KIND OF PATTERN
13:56:02  WHERE IF YOU MAKE THIS ONE CHANGE AND YOU HAVE
13:55:58  TIGHTLY.
13:56:04  TO DEPLOY EVERYTHING ELSE IN THE WORLD YOU KNOW
13:56:07  YOU'RE DOING SOMETHING WRONG.
13:56:08  SO FOR US, WE SAID NONE OF THIS.
13:56:10  WE'RE NOT GOING TO DO THAT.
13:56:12  EVERY SERVICE OWNS ITS OWNS ITS OWN DATASTORE.
13:56:17  FOR IDENTITY, RIGHT NOW WE RUN FLASK,
13:56:20  POSTGRESQL, WE USED TO RUN CACHE FOR CACHING,
13:56:24  WE CHANGED THAT TO REDIS.
13:56:26  BUT THE POINT IS FROM EVERYONE ELSE'S
13:56:28  PERSPECTIVE IT'S JUST AN API, RIGHT?
13:56:31  YOU DON'T HAVE TO KNOW WHAT TECHNOLOGIES ARE
13:56:33  INVOLVED IN THAT API UNLESS YOU'RE ACTUALLY
13:56:37  DEVELOPING THAT SERVICE, AND THAT REALLY KEEPS
13:56:39  THE CONTEXT SMALL, AND SO IF YOU NEED TO KNOW
13:56:42  OH, YEAH THIS IS HOW SEQUEL INTERACTS WITH
13:56:47  POSTGRESQL IN THE CONTEXT OF IDENTITY, THEN YOU
13:56:49  CAN FOCUS ON THAT ONE THING.
13:56:51  BUT IF YOU DON'T ACTUALLY CARE ABOUT THAT.
13:56:54  IF YOU'RE DEVELOPING SOMETHING FOR THE WEBSITE
13:56:55  OR ADDING A NEW FEATURE TO OUR PUBLIC API,
13:56:58  THOSE THINGS ARE KIND OF IRRELEVANT TO YOU IN
13:57:00  YOUR DAY-TO-DAY.
13:57:04  SMALL AND MAKES IT REALLY EASY TO CHANGE THINGS
13:57:09  INDEPENDENT FROM EVERYONE ELSE AROUND YOU.
13:57:01  AND SO IT KEEPS THAT KIND OF MENTAL OVERHEAD
13:57:11  SPEAKING OF CHANGING THINGS, THE BIGGEST EFFECT
13:57:17  FROM GOING TO THIS MICRO SERVICE ARCHITECTURE
13:57:20  FOR US WAS THAT ONCE WE INVESTED IN ALL OF THIS
13:57:22  INFRASTRUCTURE AND AUTOMATION IT MADE DEPLOYING
13:57:27  CODE REALLY EASY.
13:57:28  AND THIS IS SOMETHING WE REINFORCED OVER AND
13:57:31  OVER.
13:57:31  SOMETHING WE WANTED FROM THE VERY BEGINNING WAS
13:57:33  THE IDEA OF A ONE CLICK DEPLOY.
13:57:37  SO WE BUILT THIS NOT SURPRISINGLY A SERVICE
13:57:41  CALLED PROMETHEUS TO HELP US DO DEPLOYS.
13:57:46  THIS IS OUR OPERATIONAL AND SERVICE DASHBOARD.
13:57:49  SO RIGHT IN THE MIDDLE OF THE PAGE YOU SEE A
13:57:51  LIST OF BRANCHES THAT EXIST FOR THIS SERVICE
13:57:53  AND THEN A BUNCH OF DEPLOY BUTTONS TO THE
13:57:56  RIGHT.
13:57:56  SO YOU CAN DEPLOY TO OUR TESTING ENVIRONMENT
13:57:59  ANY BRANCH THAT YOU WANT AT ANY TIME.
13:58:01  AND KIND OF AT THE TOP OF THE SCREEN THERE'S,
13:58:02  YOU KNOW, WHEN WAS THE LAST BUILD, WHAT WAS THE
13:58:06  BUILD STATUS OF IT.
13:58:07  SO WE RUN JENKINS TO DO UNA TESTING AND PILOT
13:58:13  AND FOR EACH OF THOSE BRANCHES YOU CAN SEE
13:58:15  WHETHER OR NOT THOSE BUILDS SUCCEEDED OR
13:58:11  AND PEP CHECKS.
13:58:17  FAILED.
13:58:17  BUT THE IDEA HERE IS THAT WE WANT TO MAKE IT SO
13:58:19  SIMPLE TO GET ANY SERVICE DEPLOYED TO OUR
13:58:23  TESTING ENVIRONMENT AND PRODUCTION THAT ON THE
13:58:25  FIRST DAY YOU CAN COME, CHECK IN CODE, AND
13:58:29  DEPLOY TO PRODUCTION AS AN ENGINEER.
13:58:30  AND SINCE ALL OF OUR SERVICES BEHAVE
13:58:32  INDEPENDENTLY, EACH ONE IS INDEPENDENTLY
13:58:35  DEPLOYABLE, AND WE'VE KIND OF MADE THIS RULE
13:58:37  THAT ONCE YOU'VE CODE REVIEWED YOUR CHANGES AND
13:58:40  MERGED THEM INTO MASTER YOU CAN IMMEDIATELY GO
13:58:43  AND DEPLOY IT ON YOUR OWN.
13:58:44  WE FOUND THAT PEOPLE DO THAT.
13:58:46  AND PEOPLE REALLY LIKE DEPLOYING.
13:58:48  AND SO RIGHT NOW WE'RE DOING OVER 50 DEPLOYS A
13:58:51  DAY EVEN THOUGH WE HAVE SUCH A TINY TEAM.
13:58:55  SO THE NEXT QUESTION IS LIKE WHEN YOU'RE
13:58:58  DEPLOYING ALL THIS CODE SO QUICKLY, HOW DO YOU
13:59:02  NOT BREAK THINGS ALL THE TIME.
13:59:04  SO FOR US, GOING BACK TO THE PRODUCTS THAT WE
13:59:08  BUILD, WE ACTUALLY USE OUR OWN TESTING AND
13:59:11  AUGUST MONITORING TOOLS TO MONITOR OUR OWN
13:59:16  THIS IS SUCH A LIFESAVER FOR US.
13:59:19  WE'RE ABLE TO BUILD SERVICE TESTING IN OUR
13:59:15  INTERNAL SERVICES.
13:59:21  TESTING ENVIRONMENT.
13:59:22  SO AFTER YOU DEPLOY, IT AUTOMATICALLY TRIGGERS
13:59:25  THIS AUTOMATED TEST WHICH GOES OUT, VERIFIES
13:59:27  ALL THE SERVICE APIS ARE UP AND RUNNING ASK
13:59:31  RETURNING THE CORRECT DATA AND THEN LETS US
13:59:33  KNOW VIA SLACK OR EMAIL THAT SOMETHING BROKEN.
13:59:40  THE NICE THING ABOUT THE TOOL IS THAT YOU CAN
13:59:41  WRITE TEST, CREATE VARIABLES FOR THE HOST NAMES
13:59:45  AND USE THAT IN YOUR ENVIRONMENT SO YOU CAN DO
13:59:48  API DEVELOPMENT AND POINT THAT TEST AT YOUR
13:59:50  LOCAL HOST.
13:59:50  YOU CAN TAKE THAT SAME TEST AND RUN IT AGAINST
13:59:53  OUR TESTS ENVIRONMENT AND TRIGGER THAT
13:59:55  AUTOMATICALLY AFTER EVERY DEPLOY, AND THEN YOU
13:59:57  CAN TAKE THAT SAME TEST AND RUN IT ON A
14:00:00  SCHEDULE IN YOUR PRODUCTION ENVIRONMENT TO KNOW
14:00:02  THAT IT'S UP AND RUNNING AND THE PERFORMANCE
14:00:04  OVER TIME IS STABLE.
14:00:06  AND SO THE IDEA HERE IS THAT ALL OF THESE
14:00:09  THINGS TOGETHER, SMART SERVICE, SMART CLIENT,
14:00:12  OUR OWN TESTING TOOLS, KIND OF MAKE THIS GRAPH
14:00:15  POSSIBLE.
14:00:20  DEPLOY, BEING ABLE TO FIX A BUG IN LESS TIME
14:00:24  THAN IT TAKES TO RESPOND TO THE SUPPORT EMAIL,
14:00:16  AND AS AN ENGINEER, COMING IN, BEING ABLE TO
14:00:27  GETTING THINGS INTO PRODUCTION CONSTANTLY DAY
14:00:29  AFTER DAY AFTER DAY IS INCREDIBLY EMPOWERING
14:00:33  AND IT'S KIND OF -- IT'S SOMETHING THAT, YOU
14:00:35  KNOW, WE KNEW WAS POSSIBLE WHEN WE STARTED THE
14:00:38  COMPANY.
14:00:38  BUT SEEING IT IN PRACTICE OVER THE LAST
14:00:40  TWO AND-A-HALF YEARS, IT'S SOMETHING THAT
14:00:42  WE'RE, ONE, VERY PROUD OF, BUT STATEMENT, IT'S
14:00:46  SOMETHING THAT, YOU KNOW, CHANGES HOW YOU THINK
14:00:48  ABOUT CODE, HOW BIG A FEATURE YOU SCOPE AND HOW
14:00:51  OFTEN THAT YOU MAKE CHANGES TO YOUR SITE AND
14:00:55  YOU CAN DO THAT WITH CONFIDENCE IF YOU INVEST
14:00:57  IN ALL THE RIGHT PIECES OF INFRASTRUCTURE.
14:01:00  SO THAT'S ALL THE TALK THAT I HAD PLANNED.
14:01:05  THANK YOU.
14:01:07  [ APPLAUSE ]
14:01:13  >> AND I THINK I LEFT ENOUGH TIME FOR A FEW
14:01:15  QUESTIONS.
14:01:17
14:01:19  >> I THOUGHT THERE WAS A MICROPHONE FOR
14:01:21  QUESTIONS AND PERFECT.
14:01:22  OKAY.
14:01:25  >>  I HAVE A QUESTION ABOUT HOW YOU USE
14:01:31  [INAUDIBLE], KEEPING THEM CONSISTENT WHEN YOU
14:01:22  GO RIGHT AHEAD, PLEASE.
14:01:34  HAVE SORT OF DE FACTO FOREIGN KEYS BETWEEN
14:01:37  THOSE SERVICES.
14:01:38  >> SO WE TRY ACTUALLY NOT TO HAVE A DE FACTO
14:01:41  FOREIGN KEYS BETWEEN THE SERVICES.
14:01:44  WE TRY AND HAVE THE DATA THEY'RE STORING TO
14:01:48  KEEP ALL THAT RELATED INFORMATION TOGETHER.
14:01:50  AND SO YOU KNOW, A LOT OF THINGS KIND OF ASSUME
14:01:55  THERE'S A PARTICULAR STRUCTURE AND A PARTICULAR
14:01:58  KEY, BUT WE TRY TO KEEP THOSE LOOSELY COUPLED
14:02:01  BETWEEN SERVICES THAT I HAVE A CUSTOMER ID HERE
14:02:07  AND THAT MAY OR MAY NOT EXIST BUT I'LL CHECK
14:02:09  THAT AT RUNTIME WHEN I NEED TO.
14:02:12  BUT MOST OF THE DATA CONSISTENCY WHERE YOU NEED
14:02:15  HARD LINKAGE BETWEEN OBJECTS, WE TRY TO KEEP
14:02:19  THAT WITHIN ONE SERVICE.
14:02:21  >> HI.
14:02:22  DO YOU HAVE ANY TOOLS THAT HELP YOU DEBUG
14:02:26  RUNTIME ERRORS RELATED TO DATA FLOW BETWEEN
14:02:29  MULTIPLE SERVICES AND HOW DIFFICULT IS THAT?
14:02:32  >>  SO YEAH.
14:02:33  SO ONE OF THE THINGS THAT I SHOWED EARLIER IS
14:02:35  OUR TRAFFIC INSPECTOR.
14:02:40  BASICALLY ADD HEADERS THAT GET PASSED FROM
14:02:43  SERVICE TO SERVICE, AND SO IN OUR INTERFACE YOU
14:02:37  AND WE CAN TURN THAT ON FOR OURSELVES AND ADD
14:02:45  CAN DO A LITTLE SEARCH QUERY AND SAY DOES THIS
14:02:48  HEADER VALUE EXIST, AND SO YOU CAN TAG
14:02:50  BASICALLY A REQUEST FLOW AS IT GOES FROM
14:02:53  SERVICE TO SERVICE.
14:02:55  >>  COULD YOU TALK A LITTLE BIT ABOUT HIGH
14:02:58  AVAILABILITY?
14:02:59  LIKE WILL MICRO-SERVICES BEHIND LOAD BALANCERS
14:03:03  AND LIKE THAT.
14:03:04  >> YEAH.
14:03:04  I DIDN'T TOUCH ON THAT IDEA VERY MUCH IN THE
14:03:07  TALK.
14:03:07  BUT SINCE WE HAVE THESE SMALL, INDEPENDENT
14:03:11  SERVICES AND EACH ONE IS REPLICATED ACROSS
14:03:14  AVAILABILITY ZONES AND DIFFERENT DATA CENTERS
14:03:16  AND WE HAVE THAT HE IS LOCAL LOAD BALANCERS ON
14:03:18  EACH SERVICE, YOU KNOW, IF A REQUEST TO ONE OF
14:03:23  THOSE SERVICES FAIL, THERE'S ALWAYS ANOTHER ONE
14:03:25  UP RUNNING SOMEWHERE ELSE THAT YOU CAN TRY THAT
14:03:28  REQUEST TO.
14:03:29  AND THAT'S KIND OF WHAT WE BUILT IS TO TRY
14:03:32  AUTOMATIC REQUESTS WHEN WE KNOW IT'S SAFE TO DO
14:03:34  SO.
14:03:36  >>  DURING YOUR TALK, YOU MENTIONED THAT HTTP
14:03:38  IS YOUR COMMON LANGUAGE BETWEEN MICRO-SERVICES.
14:03:34  >> THANK YOU.
14:03:43  I WAS WONDERING IF YOU HAD ANY IDEA OF WHAT IS
14:03:45  OVERHEAD OF USING MULTIPLE MICRO-SERVICES DUE
14:03:49  TO THE TRANSACTIONS AND [INAUDIBLE] TO GET TO
14:03:55  THAT ANSWERS THE QUESTION.
14:03:59  >>  YEAH.
14:04:00  SO THERE IS SOME NATURAL OVERHEAD FOR USING
14:04:03  HTTP.
14:04:04  AND FOR US, I THINK THE THING THAT WE WANT TO
14:04:07  OPTIMIZE FOR IS EASE OF USE AND KIND OF
14:04:10  DEVELOPER PRODUCTIVITY.
14:04:12  AND SO THERE IS SOME OPTIMIZATION THAT WE COULD
14:04:16  USE.
14:04:17  WE COULD REPLACE THAT LAYER WITH A BINARY
14:04:20  PROTOCOL SOMETHING LIKE THAT.
14:04:21  AT THE END OF THE DAY WE FOUND WE MOVED SO
14:04:23  QUICKLY AND THINGS CHANGE SO OFTEN THAT KIND OF
14:04:27  BAKING IN THOSE THINGS RIGHT NOW DIDN'T MAKE A
14:04:29  LOT OF SENSE.
14:04:31  ALSO WITH ENOUGH CACHING AND ENOUGH
14:04:33  ASYNCHRONOUS WORK, YOU DON'T HAVE TO WORRY SO
14:04:36  MUCH ABOUT PERFORMANCE.
14:04:37  BUT WE REALLY STRIVE FOR CORRECTNESS FIRST.
14:04:44  ON EACH OTHER, AND YOU'RE GOING TO UPGRADE ONE
14:04:46  AND YOU'RE GOING TO -- I'M TALKING I GUESS
14:04:41  >>  HOW DO YOU DEAL WITH WHEN SERVICES DEPEND
14:04:48  ABOUT API VERSIONS.
14:04:50  SO WE'RE GOING TO HAVE ONE SERVICE, YOU'RE
14:04:52  GOING TO UPGRADE IT AND HAVE NEW FEATURES
14:04:54  BECAUSE ANOTHER SERVICE WANTS TO USE THOSE NEW
14:04:57  FEATURES.
14:04:57  HOW DO YOU DEAL WITH THE DEPENDENCY MANAGEMENT
14:05:00  PROGRAM YOU HAVE THERE.
14:05:01  >> COOL, THIS IS THE LAST QUESTION I'VE BEEN
14:05:02  TOLD FOR TIME.
14:05:03  BUT TO ANSWER YOUR QUESTION, WE TRY TO MAKE ALL
14:05:06  OF OUR API AS BACKWARDS COMPATIBLE AS WE MAKE
14:05:10  CHANGES.
14:05:10  SO WHAT WE FOUND USUALLY IS THAT ONCE YOU'VE
14:05:13  BUILT -- WHEN THE API CHANGES THE MOST IS
14:05:16  DURING THE FIRST DEVELOPMENT.
14:05:17  AND SO WE ITERATE LOCALLY AND IN OUR TEST
14:05:21  ENVIRONMENT, AND WE'RE NOT AFRAID TO BREAK
14:05:23  THINGS IN OUR TEST ENVIRONMENT.
14:05:24  BUT ONCE WE'VE DEPLOYED SOMETHING AND HAVE IT
14:05:28  UP AND RUNNING WE TRY TO MAKE ANY CHANGES TO
14:05:30  THE API BACKWARDS COMPATIBLE WITH ALL THE OLD
14:05:33  CLIENTS AND SOMETIMES THAT MIGHT INVOLVE
14:05:38  SO YOU MIGHT HAVE ONE THAT RUNS IN HAD TWO
14:05:41  MODES AND THEN DEPLOY ALL THE OLD SERVICES THAT
14:05:36  STAGING RELEASES.
14:05:43  USE THE OLD MODE AND MIGRATE THEM OVER AND THEN
14:05:46  DEPTH PREDICT AND REMOVE THAT OLD API BUT WE
14:05:48  TRY NOT TO DO THAT VERY OFTEN.
14:05:50  >> THANKS A LOT.
14:05:51  >> SO ANY MORE QUESTIONS, COME FIND ME OUTSIDE
14:05:55  THE ROOM OR COME BY THE RUNSCOPE BOOTH.
14:05:58  WE HAVE TONS OF PEOPLE HERE TALKING ABOUT API
14:06:01  AND API TESTING.
14:06:02  THANK YOU.
14:06:03  >>  THANK YOU.
14:06:04  [ APPLAUSE ]











