  >> All right, it's time to get started.  This is the last talk for this session.  We're going to hear from Augie Fackler and Nathaniel.
  >> Good afternoon.  Thank you for coming.
  This is my friend Augie he's a cone tributer to mercurial.
  [Applause]
  >> We're good.  Okay.  This is my friend Nathaniel, worked on the summer of code web application and doing things in Python.
  >> We're going to talk about drama which means we start with relationships.  We all have someone in our lives who maybe they're a friend maybe they're not a friend, when they come to us they say "Hey, do you have five minutes for a quick favor?"
  We just know it's not going to be five minutes.
  >> Not a quick favor.
  >> It's drama.
  >> We have all sorts of relationships with people and some of them unfortunately are harmful we have ways of distancing ourselves from harmful people.  Protecting ourselves in some manner.  But we don't have relationships just with people.  We also have relationships with things.  Normally I have a Swiss Army knife in my pocket.  I don't because I flew to get here.  But I've had it almost 20 years.  It's generally a very useful thing for me to have around.  I use it almost every week, things than sharpening it's been drama-free, I use it, I'm happy, I move on.  Things things, luxury things like owning a boat are a lot more involved.  There's a joke that the happiest two days in a boat owner's life are the day it's purchased and the day the boat is sold in between you discover that a boat in a hole in the water that you pour money and time, you have to keep it clean, keep the seals off.
  >> There's some thread in our cull that you are says "Watch out for your possessions" watch out for possessions that through their maintenance needs, invert the ownership relationship and start owning you.  This is from within my lifetime but the idea is actually, quite old.  And we find that really the only possession, is that require a lot of maintenance that are worth owning are hobbies and pets and things that bring enough joy to make the maintenance cost and the inverted ownership relationship worthwhile.  Now this doesn't just happen with people.  And with dumb objects this also happens with smart systems.  I use opera as my social media isolation zone.  I do things computing and things browsers but when I feel like social, feel like being social I fire up opera.  And I get this.
  >> It wants to make changes aren't you excited?
  >> I want to make changes, too.  I want to be taller and thinner.  But what is this getting me into?
  I don't know.  It wants my password but it's getting me into something that it cares about not something that I necessarily care about.  It's dragging me into something.
  >> Still in the software universe as a user, back in 2008 or so I tried to make a run at using Linux as daily driver desktop, I had terrible timing as anybody who has used Linux remembers.
  Famously the maintainer of pulse audio described it as the software that's breaking your sound on Linux.  And that was really true for me.  I gave up on using Linux on the desktop at the time, because I was a student and instead of writing papers and listening to the music I needed to listen to for music classes that sort of thing I was fixing my audio.  And after a couple of months of the abuse I just gave up wept back to a platform where I didn't need to fuss with kind of stuff all the time.
  >> We'd like to defend ourselves from this kind of software drama.  We have these techniques that we use in non-software drama, when someone approaches us with a political opinion says, sign my petition or you don't believe in this thing.
  We say, no, no, it's okay.  I can still believe in it without taking action.  Or when an object asks us to buy it.  Says "Buy me, you'll be so happy" wait a second.  What things do I have that you're going to interpret with or going to break some of my things.
  >> Or make me replace some of my things.
  >> What product ecosystem are you asking me to buy into.  These are all forms of loose coupling in lay life they correspond to loose coupling in approaches that we can take in software.
  >> Everything we've just talked about that you apply in lay life routinely basically sounds like common sense.  Nobody is really going to argue that you should think about what you should buy before you buy it and spend money on it.  But when we --get involved in software and write software we don't think abut this at all instead we just, owe, this library looks like it does what I need, done.  Six months later we find ourselves replacing it or on some sort of horrible upgrade treadmill.
  >> How can we do better.  We'd like some guidelines, some techniques, to do better to, free ourselves from getting sucked into software drama.  We have some.  Let's start off on the client side so this is the case of, us or you authoring a piece of software that needs to interface and interact with and depend upon another piece of software without getting sucked into its drama.  The first most important thing is, deliberate ignorance.  That dependency it might be open source, you might have gone and looked and seen how it's implemented.
  >> Might have implemented it yourself months ago or last week.
  >> Right.  Forget all that.  Forget your internal knowledge of how it works just use it according to its public API.  You may find that it's public AI is inefficient for what you need to do.  You file a request against the maintainer saying please make the system do this.  They come back to you they say, it already does.  Are you okay?
  You say to them, I know it does but it doesn't say so with a guarantee in its API.  That's what I really need.  And that establishes a healthy relationship.
  >> the next step in avoiding drama is to be prudent about what dependencies you pick.  Just because you have ten options doesn't mean you should pick the first one alphabetically or oldest one.  You have to evaluate service dependencies and libraries in somewhat similar ways with service providers the big difference is, a service can disappear out from under you then leave you in the lurch.  A library is not going to just disappear off your system one day, but in both cases you want to look at how well documented they are.  How well they seem to adhere to their API guarantees.  Do they have API guarantees.  Some people don't.  The last part of this is that you shouldn't necessarily use everything a dependency grants you behaviorally.  Just because the database you're using today can let you lock all of your database make sweeping changes to the universe in a transaction then commit it or fail it atomically, doesn't mean you're going to be able to do that in two years.  If your service is a thousand times bigger than it is so this is going to look like a really stupid decision because now you can't lock the entire world.  You're split across multiple machines somehow and you have to rearchitect your system.  So, a little bit of forward thinking today in terms of how you use a dependency and which one you pick can save from you a lot of drama.
  >> Now, we'd be remiss if we talked about your set of options as a client without talking about the Chernobyl design pattern is which you absolutely need to depend on some specific dependency, that is so poisonous and so toxic that it would suck your whole system into its drama, you can always wrap it in a sarcophagus.  Some sort of containment layer to isolate the damage, to say, no, I'm not going to let that disturb or disrupt my system.  And it may seem like you're doing someone else's work for them.  May seem like you're doing the job that the package provider should have done.
  Maybe.  But sometimes it's your best option.  A practical example of this is Python world HTML offers HTML quasi statewide.  And requests hides all of that from you gives you something that is reasonable and helps you do things like keep alives and things nice features of HTTP that are honestly a pain to use.
  >> On the flip side, we also build systems.  We also build systems and provide them to others and want those others to be able to use them without getting sucked into our drama.  We'd like to talk about how to do that.  The first thing is just to empathize.  Just to put yourself in your user's place, imagine yourself in your user's place ask, what should they have to know to be able to work with your system.
  >> This is really, really hard.  Because you've spent months building a system or years, and you've developed a -- your own knowledge about something.  You're now an expert in some field and your users probably don't know anything about your field.  They probably haven't spent any time researching it.  They want to come in, pick up your library, use it then walk back out and not have to understand everything.  That's important.  The next step is you need to question every time you say "Everybody knows".  Anything.
  >> Our profession is growing.  Our profession is welcoming more and more people of different skill sets, different backgrounds, different trainings, and it's becoming less and less safe when offering a system to say, oh, everybody knows.  Everybody knows Posics semantics.
  >> 40 years ago probably mostly reasonable assumption that everybody knew assembly.  But I'm guessing most of the people at this conference have never written serious assembly.  I've never written any at all.
  >> Even providing a network system it's no longer safe to say "Everybody knows TCP".  I thought I knew TCP until two days ago.
  >> So did I.  I found out about something out of band packets in TCP, which is an obscure feature, only thing I know of that uses it is telenet to send control C.  But on OS10 there was API that because of its design and when people didn't think of these packets they could get put into an infinite loop.  You can look up this CVE later if you want to see the details.  It's subtle and interesting.
  >> So when you really go through this empathy exercise, when you really do a thorough user study you may find yourself brought to this kind of identity crisis.  Where you look at your system and you look at the dependencies it uses.  Let's say there are five.  And you ask yourself, well, my system it provides some additional behavior, that's its value.  That's its reason for existence.  But it also uses these five things.  Shows who use my system have to know the five things that it uses?
  Well, if the value that your system adds is small, if the additional behavior is small, it may make sense to offer something that we think of as transparent or something like a utility.  That is designed to be used in the context of the things that it uses and designed to be used by a user who's familiar with the things that it uses.  So, it fits into a larger ecosystem.  Conversely at the things end of this spectrum that we're imagining may be that your system provides a great deal of different behavior.  And the appropriate thing to do in that case is to export a new universe of concepts and say, the users of my system, well they only need to be familiar with the concepts that my system exports.  They don't need to know about the five things under the hood that it uses.  I don't need them to be a domain expert in those things as well.
  Now, these are both valid perspectives for different systems.  It's important to take a stand.  Neither one is right or wrong.  But it's important to think about this and be deliberate about where you're placing your system because if you inadvertently stumble into a situation where you offer your users a whole new universe of concepts and they have to be domain experts in everything you use, you've really done them a disservice.  You've coupled them to a wide range of domain expertise that they may not be able to find.
  >> It's also important to realize that something might make sense as a utility today because there's a lot of valid things to do today.  But in another ten or 15 years this is something that is accept and routine, but needs to be invisible.  So it goes from being valid to give utility to be more valid to give somebody a solution that hides everything.
  >> You may find yourself of the choice of saying "In my documentation, should I focus on inventories, by which we mean a parts list of everything available in your system and the rules for how they fit together".
  >> This is basically what Pydoc gives you for free.
  >> Or codewalks.  Specific example how to build specific things out of specific elements in your system.
  >> the best analogy I found for this is, inventory is basically you open a box of Legos rip open all the bags, dump them in a tub then hand them and picture of what that kit is supposed to make to someone.  They're basically looking at this pile of grey Legos you gave them a picture of the death star and go, okay, you gave me a bunch of rectangles, that is a sphere, this doesn't make any sense.  The example gives them a step by step and can make that.  For novices the step by step is important and valuable.  For more advanced users, they just want the parts list because they're going to dive in, they're going to pick things up that they need and then they're going to walk away be done.  Experts probably don't want to spend two hours on your tutorial, they want to take their knowledge that they already have, find the things they need and get on with life.
  >> Another thing that you can do to make your system more approachable is to watch the way that you expose life cycle management facility for the parts of your system that have life cycle management.  I look around the room I see lot of fully constructed systems.  And most of us have this little artifact of how we were built.  We're never going to use it again but it's still on our surface area.  We see this in software with initialized methods.  These are methods on some object that they need to be called after construction, they need fob called exactly once, but they remain available on the object after they're usefulness.  And they can be called mistakenly, they can corrupt things, and they're just a problem.
  >> This would be like constructing a file then having to call dot.open afterwards.  Related problem is, side effects on import.  It's generally the case in my experience that an import time side effect for a package means it's setting up some kind of global shared state that's then going to limit later users of that package.  Instead of being able to open connection to five databases, you pull a database connection string out of an environment variable you set some magic global somewhere now I can only ever talk to that database from this process.  That limits me later, the better solution is, actually give that set-up method to your clients then they can use it and open whatever connections make sense in whatever scoping that makes sense.
  >> Another thing you can do is when you're assembling your system watch out for places where internal segmentation makes sense and where it does establish domains of distrust.  I know it makes sense, I know it sounds funny to distrust something that you just wrote last week yourself in what you're writing this week.  But it allows for you to separate failure and contain failure in different sub domains.  Wrath he than letting your whole system fail.  So, here is another system.  It's a physical system.  It's my system.  And it's an all in one, printer, scanner, fax, I even used it to fax back in 2008 or so.  I moved west, when I did the print mechanism broke in transit.  I thought that's great, I hardly ever print I'll use it to scan.  But the scanning and printing mechanisms inside had been coupled.  Coupled in software not even in physical hardware.  And now it refuses it's going out to the curb next week.
  >> Another example how this can accidentally happen where you set something up, Nathaniel got a patch for tests for the java script for the summer of code web app.  Ran the test, passed on its own machine.  Passed on shared reference again, passed for all the things condition tributers but then when anybody else tried to run it on the shared machine, the tests would fail.
  >> We just -- we scratched our heads or hours.  What's so special, why -- all set up our user accounts exactly the same way.  What's going on?
  >> the answer is, the test tool has to make a temporary profile for a web browser.  Which is fine.  And it makes it in the system's temporary directory which is also fine.  When it does that it uses a fixed name then sets permission so that it's only readable by the user that's running that browser which is totally reasonable except for the fixed name.  Because then I am running a test with Firefox with this fixed profile name which means Nathaniel can't on the same machine run a test Firefox with that.  They sent a patch upstream which made it totally random what the directory name was.  Stow that now anybody can run tests in parallel with anybody else.  But you got sucked into this drama of, oh, I only could possibly need one browser at a time.
  >> Or one user on the system at a time.  This happened to me a few years ago I was using idea, the Idea that I mostly love and it had this weird behavior when we corrupted our CVS server one day on a different machine.  And idea locked up.  Everything else's command line said, CVS is crazy, not going to believe what it says.  But my application locked up.  And it was because it wasn't because the CVS server was down, if the server was unresponsive, idea would behave well.  But it locked up because it trusted the emission of the CVS server across the network.  So, networks provide a natural boundary across which to distrust everything.
  >> We've got some positive examples of how splitting things up can be helpful.  Django as much as it has some of the these magic singleton behaviors gets a lot of this right in terms of providing loads of utilities and not a framework.  If you don't like its templating library, maybe it's too slow or you need to render templates in java script instead you can throw that out, Django doesn't really penalize you for not wanting to use.  You can SQL alchemy.  It doesn't hurt you maybe some admin stuff doesn't work because it can't any more.  But the system still functions and it cooperatives nicely.  Web driver is fantastic as example of putting something behind a solution.  Web driver makes remote controlling Firefox look the same as a headless web kit as the same as chrome, and you can run your web application inside one of these things and it looks the same.  It's the same API, you don't have to build your own complicated adapter dealing with five different web browsers and all of the shenanigan, is that would entail.
  >> All right.  Stay out of your drama.  Stay out of our drama.  Keep us out of yours.  Thank you.
  >> Thank you!
  !
  [Applause]
  >> All right.  We have couple of minutes for questions.  Anybody questions.  Can you please use the Mic you'll have to run.  Then your question gets recorded on the video and we can all hear it.
  >> Audience: Hi, at the -- I just wanted to say thank you for calling out the codewalks versus inventory distinction.  I love it when I find project that have both of those.  On twisted we call those reference documentation and narrative documentation since those are the two like things that you do with them.  You refer to them or you get a story from them.  But thank you for suggesting how the folks do that.
  >> You're welcome.  Thank you for the comment.
  >> Audience: What is your best example of drama you get pulled in by using the long wedge.
  >> Drama in to which you get sucked by using the Python language.
  >> for me it's been the Python 3 migration.  The questioner knew that.  I work a lot on mercurial.  Mercurial deals almost exclusively with bytes data most of the operations disappearing from bytes in terms of being able to add them together and format them into each things has been very difficult for us.  I'm actually looking forward to playing with the alpha 3.5 because it may actually solve that problem.  We actually went to Python core developers said, guys, this is killing us, we can't make this work.  There was a lot of social drama surrounding that technical drama in order to get the functionality we needed.
  >> for me I think the biggest drama into which using sucks me is the world of Posix semantics and thinking about computing in terms of processes and threads and pipes those sorts of things.  I kind of wish that the Python interpreter were a for powerful virtual machine with more powerful abstractions and exposed less of the underlying operating system.  I realize there's not a lot of detail in that answer.  But I think that's something I found frustrating as I was learning the language was that I really wished I was learning a new way of computing rather than a new way of issuing commands to the same underlying computer.
  >> Anyone else?
  All right.  Thank you very much.
  >> Somebody's moving.  Or not.
  [Applause]
  
