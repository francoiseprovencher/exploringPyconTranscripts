01:39:14   >> WE HAVE CURTIS LASSAM THAT WILL BE TALKING
01:42:49   ABOUT HASH FUNCTIONS AND YOU, PARTNERS IN
01:42:52   FREEDOM.
01:42:52   >> HELLO, I'M CURTIS LASSAM, CLASSAM ON TWITTER.
01:43:07   WE'LL TALK ABOUT HASH FUNCTIONS.
01:43:09   I'M GOING TO SHOW YOU WHY THIS FUNDAMENTAL
01:43:11   TECHNIQUE BELONGS IN YOUR TOOL KIT AND YOU'LL SEE
01:43:14   I'M NOT A HANDYMAN.
01:43:16   WE'RE GOING TO TALK ABOUT HASH FUNCTIONS,
01:43:19   #FILTER, BLOOM FILTERS AND HASHES INSECURITY.
01:43:24   WHAT IS A HASH FUNCTION?
01:43:25   THE VERY BEGINNING.
01:43:27   HERE IS AN EXAMPLE.
01:43:29   IT TAKES A STRING, SPLITS ITS INTO CHARACTERS,
01:43:32   CONVERTS EVERY CHARACTER INTO AN INTEGER, ADDS
01:43:34   THE INTEGERS TOGETHER AND MODELS THE RESULT BY
01:43:38   100.
01:43:38   THIS IS A HASH IF YOU THINK.
01:43:39   NOT EVERY HASH FUNCTION WORKS THIS WAY BUT THIS,
01:43:42   LIKE MANY OTHER FUNCTIONS, IS AN EXAMPLE OF A
01:43:44   HASH FUNCTION.
01:43:45   IT HAS A NUMBER OF USEFUL PROPERTIES.
01:43:48   REGARDLESS OF WHAT SEQUENCE OF CHARACTERS YOU PUT
01:43:51   IN, YOU'RE GUARANTEED THAT THE OUTPUT WILL ALWAYS
01:43:52   BE BETWEEN 0 AND 99.
01:43:54   THE OUTPUT FOR A STRING WILL ALWAYS BE THE SAME.
01:43:58   AND MANY DIFFERENT INPUTS CAN PRODUCE THE SAME
01:44:02   OUTPUT.
01:44:03   ALSO, GIVEN THE OUTPUT, IT'S IMPOSSIBLE TO GUESS
01:44:05   THE INPUT THAT PRODUCED IT.
01:44:07   I KNOW INVOKING THE WIKIPEDIA DEFINITION OF
01:44:11   SOMETHING IS THE PRESENTATION EQUIVALENT TO
01:44:13   OPENING WITH WEBSTER DEFINITIONS DEFINES BUT THE
01:44:15   WIKIPEDIA HAS A GOOD DEFINITION OF A HASH
01:44:17   FUNCTION.
01:44:18   A HASH FUNCTION IS ANY ALGORITHM THAT MAPS DATA
01:44:23   OF ARBITRARY LENGTH TO DATA OF A FIXED LENGTH.
01:44:27   SO WHATEVER YOU PUT IN, YOU GET DATA OF A CERTAIN
01:44:30   LENGTH.
01:44:31   THAT'S HASH FUNCTION.
01:44:32   LET'S TALK ABOUT HASH TABLES.
01:44:33   THEY'RE A DATA CONCEPT USED TO STORE KEYS AND
01:44:36   VALUES.
01:44:37   KEYS AND VALUES ARE IMPORTANT, YOU DEAL WITH THEM
01:44:38   WHEN YOU WORK WITH THINGS LIKE MUNGO DB OR PYTHON
01:44:42   DICT, AND IF YOU'RE DEALING WITH KEYS AND VALUES,
01:44:45   CHANCES ARE BEHIND THE SCENES SOMETHING CLEAR
01:44:47   WITH HASH TABLES IS HAPPENING.
01:44:49   IT COULD BE A TREE OR A TRI, BUT WE'RE NOT
01:44:52   TALKING ABOUT THOSE SO WE'LL PRETEND THEY DON'T
01:44:55   EXIST.
01:44:55   SO LET'S START WITH A BIG BLOCK OF MEMORY, AN
01:44:57   ARRAY WITH 100 ELEMENTS.
01:44:59   WE WANT TO STORE THE VALUE, HASH 215D29 AGAINST
01:45:04   THE KEY COLOR SO, WE RUN A HASH FUNCTION ON THE
01:45:07   KEY, COLOR, THIS PRODUCES A NUMBER WHICH WE MOD
01:45:11   BY THE LENGTH OF OUR TABLE AND THIS GIVES US AN
01:45:13   INDEX.
01:45:13   AND THEN WE CAN STORE OUR VALUE AT THE LOCATION
01:45:18   POINTED TO BY THE INDEX, THAT'S A HASH TABLE.
01:45:20   EASY PEASY.
01:45:21   BUT IT IS NOT SO EASY NOR QUITE SO PEASY.
01:45:26   AS THE ARRAY FILLS UP WITH VALUES, IT GETS MORE
01:45:28   AND MORE LIKELY THAT WE'LL HAVE A HASH VALUE
01:45:32   POINT TO A SPOT IN THE ARRAY THAT'S ALREADY FULL.
01:45:34   THIS IS CALLED A COLLISION AS YOU MIGHT IMAGINE.
01:45:38   WHAT DO WE DO WHEN THERE'S ALREADY A VALUE IN THE
01:45:40   SPOT WHERE WE WANT TO STORE A VALUE?
01:45:41   WE CAN KEEP WALKING FORWARD IN THE TABLE UNTIL WE
01:45:46   FIND AN AVAILABLE SPOT, THIS IS CALLED LINEAR
01:45:49   PROBING.
01:45:50   ALTERNATIVELY, WE COULD LINK TO EVERY SPACE IN
01:45:53   THE ARRAY, THAT WAY OUR HASH TABLES CAN TAKE AS
01:45:56   MANY VARIABLES AS WE CAN THROW AT IT.
01:45:57   OR ROOT A TREE AT EVERY SPACE IN THE TABLE.
01:46:00   THIS, ROOTING A SEPARATE DATA STRUCTURE AT EVERY
01:46:02   SPOT IN THE TABLE IS CALLED A CHAINED HASH TABLE.
01:46:05   THERE'S ONE PROBLEM WITH A CHAINED HASH TABLE,
01:46:08   HERE THERE'S A BUNCH OF DIFFERENT VALUES STORED
01:46:10   WHERE WE'RE LOOKING FOR THE KEY.
01:46:12   GEEZ, HOW DO WE KNOW WHICH IS THE RIGHT ONE.
01:46:14   WE NEED TO STORE THE KEY WITH THE VALUE IN THE
01:46:16   SECOND DATA STRUCTURE SO WE CAN MAKE SURE WE'RE
01:46:19   RETRIEVERING THE RIGHT THING.
01:46:20   THIS IS GOING TO BE THE CASE ANY TIME WE HAVE TO
01:46:22   DEAL WITH COLLISION.
01:46:23   IF WE CAN RETRIEVE MULTIPLE POTENTIAL VALUES FROM
01:46:25   AUER HASH TABLE, WE NEEDS TO BE ABLE TO TELL
01:46:27   WHICH IS THE CORRECT VALUE.
01:46:28   SO EVEN WITH SOME STRATEGY FOR COLLISION
01:46:31   DETECTION IN PLACE, IT'S POSSIBLE FOR THE TABLE
01:46:34   TO GET SO FULL THAT IT PERFORMS VERY SLUGGISHLY.
01:46:37   A CROWDED CHAINED HASH TABLE IS ONLY A LITTLE BIT
01:46:39   BETTER THAN A LINKED LIST.
01:46:41   OR IN THE CASE OF HASHING STRATEGIES THAT JUST
01:46:45   SHUFFLE ADDRESSES AROUND, IT'S POSSIBLE FOR THE
01:46:47   TABLE TO BECOME COMPLETELY FULL.
01:46:49   WHEN THIS HAPPENS, IT'S TIME TO REBUILD THE HASH?
01:46:54   THIS IS THE TIME-CONSUMING PROCESS OF ADDRESSING
01:46:57   AN EVEN BIGGER WHACK OF MEMORY, TAKING ALL THE
01:47:00   KEYS OUT OF THE ARRAY, REHASHING THEM AND PUTTING
01:47:03   THEM IN THE SECONDS ARRAY.
01:47:04   THERE'S ONE LANGUAGE I CAN THINK OF WHOSE DEFAULT
01:47:07   HASH TABLE IMPLEMENTATION CAN PERFORM THIS
01:47:10   COMPUTATIONALLY IMPORTANT STEP UNEXPECTEDLY ANY
01:47:14   TIME AN INSERT PUSHES THE LOAD ABOVE THE LOAD
01:47:17   LIMIT.
01:47:18   FOR THE SAKE OF POLITENESS, I'M NOT GOING TO
01:47:20   MENTION WHICH LANGUAGE.
01:47:21   OF COURSE, LINEAR PROBING AND CHAINED HASHING ARE
01:47:24   NOT THE ONLY MANAGEMENT STRATEGIES, THERE ARE
01:47:26   MANY WAYS TO MANAGE A HASH TABLE, LIKE ROBIN HOOD
01:47:29   HASHING WHICH STEALS DATA FROM THE RICHER TABLES
01:47:33   AND PUT ITS INTO THE POORER TABLES, OR HOPSCOTCH
01:47:36   WHERE YOU ARRAY IT ON THE PAVEMENT.
01:47:39   YOU PROBABLY SHOULDN'T FACT-CHECK ME ON THOSE
01:47:43   LAST TWO.
01:47:43   SO A HASH TABLE USES THE HASH FUNCTION AS A
01:47:47   LOCATION TO STORE THE DATA IN MEMORY.
01:47:49   INSERT HAPPENS IN CONSTANT TIME.
01:47:51   DELETE HAPPENS IN CONSTANT TIME.
01:47:53   LOOK UP, HAPPENS IN CONSTANT TIME.
01:47:55   AND YOU SHOULDN'T LINEAR SEARCH THROUGH A HASH
01:47:59   TABLE.
01:47:59   SO THAT FIRST FEW MINUTES OF THE PRESENTATION WAS
01:48:03   THERE TO GET YOU UP TO SPEED ON THE BASIC.
01:48:05   NOW LET'S GET TO SOME OF MEAT OF THE
01:48:08   PRESENTATION.
01:48:09   BLOOM FILTERS, THEY'RE FINANCE.
01:48:10   A BLOOM FILTER IS A GREAT WAY TO KEEP BALLOONS
01:48:12   OUT OF YOUR FACE.
01:48:13   A BLOOM FILTER IS A DATA STRUCTURE THAT'S FAST
01:48:17   AND SPACE EFFICIENT, USED TO TEST FOR MEMBERSHIP
01:48:19   IN A SET.
01:48:22   THAT'S IMPORTANT, IT TESTS FOR SET MEMBERSHIP, IT
01:48:25   DOESN'T STORE ANY DATA, IT CAN TELL YOU IF
01:48:28   SOMETHING IS IN A SET BUT YOU CAN'T RETRIEVE AN
01:48:31   ITEM FROM THE SET.
01:48:32   LIKE IF WE HAVE THREE OBJECTS, BANANA, APPLE,
01:48:34   BOWLING BALL AND A BLOOM FILTER REPRESENTING THE
01:48:36   SET OF FRUIT, WE CAN USE THE SET TO DETERMINE THE
01:48:39   BANANA AND APPLE ARE PROBABLY FRUIT AND THAT
01:48:41   BOWLING BALL IS DEFINITELY NOT.
01:48:43   BUT WE CAN'T GIVE YOU A HIS OF ALL THE FRUIT THAT
01:48:46   WE'RE USED TO POPULATE THE SET.
01:48:48   WE DON'T KNOW THEM.
01:48:49   SO A LOT OF THE TIME BLOOM FILTERS ARE USED TO
01:48:51   ANSWER QUESTIONS LIKE, IS CHUMP'S A REAL WORLD?
01:48:54   NO, CHUPPIES IS NOT A REAL WORLD.
01:48:58   IS EVIL.YOU A REAL WEBSITE, I DON'T KNOW.
01:49:01   AND IS MAIN.CSS IN THE CACHE?
01:49:04   YES, IT IS.
01:49:05   IS THIS A BAND IMAGE?
01:49:07   SO LET'S LOOK AT THE PROBLEM OF BANNED IMAGES A
01:49:09   LITTLE BIT.
01:49:10   LET'S IMAGINE WE'RE RUNNING A FORUM AND OUR
01:49:12   ITINERANT USERS KEEP POSTING BANNED IMAGES.
01:49:15   HOW DO WE KNOW, LOOKING AT IMAGE DATA IF AN IMAGE
01:49:19   HAS BEEN BANNED?
01:49:20   LET'S SAY WE RUN A HASH FUNCTION ON THE IMAGE.
01:49:23   YOU CAN HASH IMAGES, HASH JUST ABOUT ANYTHING
01:49:25   THAT'S DATA.
01:49:26   MOD THE RESULT BY THE LENGTH OF AN ARRAY, MOVE TO
01:49:29   THAT INDEX LOCATION IN THE ARRAY, AND SAVE A LINK
01:49:32   TO THE IMAGE THERE.
01:49:33   THEN WHEN WE'RE CHECKING A NEW IMAGE, WE CAN HASH
01:49:36   IT AND SEE IF IT'S IN OUR ARRAY.
01:49:38   OF COURSE, THIS IS JUST A BUG STANDARD HASH TABLE
01:49:41   AND I'M SUPPOSED TO BE TALKING ABOUT BLOOM
01:49:42   FILTERS THIS.
01:49:43   WORKS FINE, THE STRATEGY I'VE USED SO FAR, BUT
01:49:45   TAKES UP A LOT OF SPACE AND I PROMISED YOU SPACE
01:49:48   EFFICIENCY.
01:49:49   LET'S IMAGINE THERE ARE 5,000 IMAGES WE WANT TO
01:49:52   KEEP OUT OF OR FORUMS AND THEY TAKE UP 100
01:49:55   KILOBYTES EACH.
01:49:56   THAT MEANS ABOUT A 500 MEGABYTE TABLE OF
01:49:58   DUPLICATE IMAGES.
01:49:59   WHILE NOT A TON OF SPACE, IT'S ENOUGH THAT YOU
01:50:01   PROBABLY WON'T WANT TO KEEP THAT IN RAM OR SEND
01:50:03   IT TO A CLIENT.
01:50:05   REMEMBER, THOUGH, WE DON'T NEED STORAGE FROM THE
01:50:08   DATA STRUCTURE, WE'RE ONLY INTERESTED IN WHETHER
01:50:10   OR NOT THIS IMAGE EXISTS IN OUR DATA STRUCTURE.
01:50:13   LET'S IMAGINE WE STORE ZEROS IN EVERY SPACE IN
01:50:15   OUR TABLE AND WE STORE ONES WHERE THE HASH
01:50:20   FUNCTIONS LANDS.
01:50:21   THAT WAY WE CAN CHECK IF AN IMAGE IS BENT BY
01:50:26   CHECKING IT AND SPOTTING IF IT HAS A ONE IN IT.
01:50:28   IF THERE'S NO ONE THERE, WE CAN'T POSSIBLY HAVE
01:50:30   SEEN THAT IMAGE BEFORE.
01:50:32   THERE'S ONLY ONE SLIGHT PROBLEM WITH THIS
01:50:34   TECHNIQUE, WHAT HAPPENS WHEN WE HAVE A DIFFERENT
01:50:37   IMAGE THAT ACCIDENTALLY COLLIDES WITH AN IMAGE
01:50:41   THAT WE SET EARLIER.
01:50:42   THIS CREATES A FALSE-POSITIVE AND UNFAIRLY TAKES
01:50:45   PICTURES OF NICHOLAS CAGE OUT OF CIRCULATION.
01:50:48   SO HOW DO WE STOP COLLISIONS LIKE THIS FROM
01:50:51   OCCURRING?
01:50:52   WELL, WE COULD USE A HASH FUNCTION THAT
01:50:54   GUARANTEES AN ASTRONOMICALLY LOW PROBABILITY OF
01:50:57   COLLISION.
01:50:58   MD5, FOR EXAMPLE.
01:50:59   IT'S A HASH FUNCTION THAT GUARANTEES AN
01:51:01   ASTRONOMICALLY PROBABILITY OF COLLISION BUT WITH
01:51:05   THAT LOW PROBABILITY OF COLLISION, YOU GET
01:51:07   AXIOMATICALLY A HIGH NUMBER OF OUTPUTS WITH ONE
01:51:11   BIT FOR EVERY OUTPUT, YOU'RE SUDDENLY SADDLED
01:51:13   WITH FOUR TIMES TEN TO THE 25 TERABYTES IN YOUR
01:51:16   ARRAY, WHICH IS ALSO A LITTLE BIT UNREALISTIC TO
01:51:19   CRAM INTO YOUR RAM.
01:51:21   BUT IT DOES HIT ON ONE OF THE TWO STRATEGIES WE
01:51:23   COULD USE TO REDUCE COLLISIONS IN OUR BIT ARRAY,
01:51:26   MORE SPACE.
01:51:27   LET'S LOOK AT THE LESS OBVIOUS STRATEGY FOR
01:51:29   REDUCING COLLISIONS.
01:51:31   MORE HASH FUNCTIONS.
01:51:32   INSTEAD OF HASHING OUR IMAGE JUST ONCE, LET'S
01:51:35   HASH IT TWICE, WITH TWO DIFFERENT HASH FUNCTIONS.
01:51:38   THIS GIVES US TWO DIFFERENT LOCATIONS IN THE
01:51:40   TABLE, AND WE CAN STORE ONE AT BOTH OF THEM.
01:51:43   ANOTHER IMAGE MIGHT SHARE THE RESULT OF ONE OF
01:51:46   THE HASH FUNCTIONS, BUT IT'S NOT AS LIKELY TO
01:51:48   SHARE THE RESULTS OF ALL OF THEM.
01:51:50   AND IF ANY OF THE HASH FUNCTIONS POINT TO A
01:51:52   LOCATION WITH A ZERO IN IT, WE KNOW THAT THIS
01:51:55   OBJECT CAN NEVER HAVE BEEN ENTERED INTO THE BLOOM
01:51:57   FILTER.
01:51:58   SO THIS IS A BLOOM FILTER, A BIT FIELD AND
01:52:02   MULTIPLE HASH FUNCTIONS TO SET THE BITS IN THAT
01:52:04   FIELD.
01:52:04   WE PUT ITEMS IN BY HASHING THEM MULTIPLE TIMES
01:52:09   AND SETTING THE BITS AT ALL OF THOSE LOCATIONS
01:52:11   AND WE CHECK IF ITEMS ARE IN THE SET BY HASHING
01:52:14   ITEMS MULTIPLE TIMES AND CHECKING IF THE BITS ARE
01:52:16   SETS AT ALL OF THOSE LOCATIONS.
01:52:18   THERE ARE SOME DOWNSIDES TO THIS.
01:52:20   BECAUSE EACH ITEM WE PUT INTO THE BLOOM FILTER
01:52:24   HAS MULTIPLE HASH FUNCTIONS, THERE CAN BE SOME
01:52:27   OVERLAP, WHICH MEANS WE CAN NEVER DELETE ANYTHING
01:52:29   FROM THE BLOOM FILTER.
01:52:30   IF WE DO, WE RUN THE RISK OF ACCIDENTALLY
01:52:35   DELETING SOMETHING ELSE FROM THE FILL --
01:52:37   ACCIDENTALLY DELETING SOMETHING ELSE FROM THE
01:52:39   FILTER.
01:52:40   ON TOP OF THAT, WE'VE REDUCED THE CHANCE OF
01:52:42   COLLISION BUT IT'S IMPRACTICAL TO REDUCE THAT
01:52:45   CHANCE TO EFFECTIVELY ZERO SO ALWAYS SOME CHANCE
01:52:48   OF A FALSE POSITIVE.
01:52:49   HOWEVER, THE PROBABILITY OF A FALSE POSITIVE IS A
01:52:51   NUMBER THAT WE HAVE SOME CONTROL OVER.
01:52:53   IF WE KNOW THE DESIRED PROBABILITY OF A
01:52:58   COLLISION, IN THE CASE OF OUR IMAGE FILTER, LET'S
01:53:01   SAY 0.1% AND THE NUMBER OF THINGS THAT WE WANT TO
01:53:04   PUT 2349 FILTER, WE MENTIONED BEFORE, 5,000
01:53:06   IMAGES, WE CAN USE HAND-WAVEY MATH TO DETERMINE
01:53:10   HOW MUCH SPACE WE NEED AND WHAT WE NEED TO GET
01:53:14   THE OPTIMAL SOLUTION.
01:53:15   WAVING MY HANDS, YOU DON'T TO HAVE MEMORIZE THIS
01:53:18   OR WRITE IT DOWN, IT'S EASY TO FIND ON THE
01:53:20   INTERNET.
01:53:20   SO DOING THIS MATH WITH OUR NUMBERS, WE NEED AN
01:53:22   ARRAY OF 71,888 BITS, WHICH IS 8.8 KILOBYTES AND
01:53:28   THAT'S SMALL ENOUGH TO KEEP IT IN RAM.
01:53:30   WE COULD SEND IT TO THE CLIENT SIDE IF WE WANTED
01:53:34   TO.
01:53:34   IT'S EASIER TO WORK WITH.
01:53:36   AND WE NEED TEN DIFFERENT HASH FUNCTIONS.
01:53:38   THAT IS TO SAY THE OPTIMAL PACKING REQUIRES THAT
01:53:40   EACH ITEM WE PLACE IN THE TABLE SET TEN DIFFERENT
01:53:45   BITS IN THE BLOOM FILTER.
01:53:47   A LOT OF THE TIME BLOOM FILTERS ARE PAIRED UP
01:53:49   WITH OTHER DATA STRUCTURE THAT HANDLE THE ACTUAL
01:53:52   STORAGE.
01:53:52   THERE'S SUPER USEFUL WHEN PAIRED WITH DATA
01:53:55   STRUCTURES THAT EXHIBIT WORST-CASE PERFORMANCE.
01:53:58   IN A LINKED LIST OR UNSORTED LARGE ARRAY, FOR
01:54:01   EXAMPLE, YOU GET THE WORST POSSIBLE CASE WHEN
01:54:02   YOU'RE SEARCHING FOR AN ITEM THAT JUST ISN'T
01:54:04   THERE.
01:54:05   THE BLOOM FILTER CAN CHECK BEFORE YOU HIT THE
01:54:08   DATA STRUCTURE IN THE DATA IS IN THE DATA
01:54:10   STRUCTURE.
01:54:10   THEY'RE ALSO VERY USEFUL WHEN THE RETRIEVAL STEP
01:54:14   FOR DATA TAKES A LONG TIME.
01:54:15   FOR EXAMPLE, WHEN A NETWORK CALL NEEDS TO BE MADE
01:54:17   TO A FAR-AWAY DATABASE, A LOCAL BLOOM FILTER IS A
01:54:22   WONDERFUL WAY TO KNOW IF YOU'RE WASTE CRINGE
01:54:24   EVERYBODY'S TIME WITH A REQUEST FOR DATA THAT
01:54:26   JUST DOESN'T EXIST.
01:54:27   OR DATA WITH A VERY LOW HIT RATE.
01:54:29   IF YOU'RE DEALING WITH THE SORT OF DATA WHERE YOU
01:54:31   GET TEN MISSES FOR EVERY HIT, IS THIS A
01:54:33   SUSPICIOUS WEBSITE, FOR EXAMPLE, YOU CAN CATCH
01:54:36   THE MISSES WITH A BLOOM FILTER.
01:54:39   SO IN SUMMARY, THIS IS A VERY SMALL SUMMARY FOR
01:54:41   THE PEOPLE IN THE BACK SO I'LL TRY TO BE LOUD,
01:54:42   BLOOM FILTERS ARE FAST, COMPRESSED, STORAGE-FREE
01:54:46   DATA STRUCTURE USED TO CHECK FOR SET MEMBERSHIP.
01:54:48   IT'S IMPLEMENTED AS A SET OF HASH FUNCTIONS,
01:54:51   POINTING TO A BIT ARRAY, NO RETRIEVAL IS ALLOWED,
01:54:54   AND NO REMOVAL IS ALLOWED.
01:54:59   SO NOW LET'S TALK ABOUT HOW TO PICK WHICH HASH
01:55:02   FUNCTIONS TO USE WHEN YOU'RE BUILDING DATA
01:55:03   STRUCTURES.
01:55:04   I SHOWED YOU MY AWESOME CHEESE HASH FUNCTION
01:55:07   EARLIER BUT IT'S TERRIBLE AND ON TOP OF THAT,
01:55:08   REALLY ONLY WORKS ON STRINGS.
01:55:11   NOW, THE NUMBER OF DIFFERENT HASH FUNCTIONS ARE
01:55:13   COUNTLESS, EACH ONE IS A UNIQUE SNOWFLAKE, ONLY
01:55:16   THREE OF THE ONES ON THIS BOARD ARE MADE UP AND
01:55:18   IF YOU CAN PICK THEM OUT, I MIGHT GET A CHANCE TO
01:55:20   ASK YOU WHICH ONES THEY ARE AT THE END OF THE
01:55:26   PRESENTATION.
01:55:26   I'LL COME BACK TO THAT SLIDE.
01:55:29   IF WE NEED TO.
01:55:30   WHICH ONES DO WE PICK FOR OUR DATA STRUCTURES?
01:55:33   FOR DATA STRUCTURES, THE PROPERTIES WE'RE LOOKING
01:55:35   FOR ARE THAT THE HASH FUNCTION SHOULD BE FAST AND
01:55:38   WELL DISTRIBUTED.
01:55:39   WHEN WE SAY FAST, WHAT WE MEAN IS NOT
01:55:43   CRYPTOGRAPHIC.
01:55:43   CRYPT CRASH HASHES ARE AWESOME, THEY HAVE A BUNCH
01:55:49   OF -- THE MOST IMPORTANT ONE, THEY'RE COLLISION
01:55:52   RESISTANT, IT'S ASTRONOMICALLY UNLIKELY THAT
01:55:55   YOU'LL EVER BE ABLE TO FIND TWO DIFFERENT ITEMS
01:55:57   THAT HAVE THE SAME HASH VALUE.
01:55:58   BUT THE CRYPTOGRAPHIC FEATURES ALSO MAKE THEM
01:56:01   MORE PROCESSER HUNGRY, SO WE SHOULD AVOID SHAH OR
01:56:05   MD5 WHEN WORKING ON DATA STRUCTURE STUFF WE DON'T
01:56:10   NEED THE SECURITY.
01:56:11   SO NON-CRYPTOGRAPHIC.
01:56:13   AND WELL-DISTRIBUTED WHICH MEANS THAT NO MATTER
01:56:15   HOW SIMILAR YOUR DATA IS GOING INTO THE DATA
01:56:17   STRUCTURE, THE OUTPUT SHOULD APPEAR ALL OVER THE
01:56:21   SPECTRUM.
01:56:21   HASH FUNCTIONS THAT EXHIBIT THIS QUALITY ARE
01:56:24   KNOWN AS AVALANCHING HASHES, BECAUSE SMALL
01:56:27   CHANGES IN THE INPUT LEAD TO LARGE CHANGES IN THE
01:56:30   OUTPUT.
01:56:30   OF COURSE, THIS IS ALSO A DESIRABLE PROPERTY IN
01:56:34   CRYPTOGRAPHIC HASHES BUT THIS ONE WE'RE WILLING
01:56:38   TO BLOW OUR TIME ON BECAUSE IT'S IMPORTANT FOR
01:56:41   DATA STRUCTURE THAT HAVE HASH FUNCTIONS TO HAVE
01:56:43   WELL-DISTRIBUTED HASH FUNCTIONS.
01:56:44   A COMMON HASH USE FOR THIS PURPOSE IS THE
01:56:46   NON-CRYPTO GRAPHIC, WELL AVALANCHING PUBLIC
01:56:49   DOMAIN MURMUR THREE, IMPLEMENTATIONS EXIST FOR
01:56:53   MOST MODERN LANGUAGES, INCLUDING PYTHON AND WHICH
01:56:56   HAS APPEARED IN MOST OPEN SOURCE PRODUCTS.
01:57:00   IT ALSO HAS A SEED VALUE SO YOU CAN CREATE DOZENS
01:57:02   OF DIFFERENT HASH FUNCTIONS OUT OF THE MURMUR 3
01:57:06   BASE HASH FUNCTION, JUST BY CHANGING THE SEED
01:57:08   VALUE.
01:57:09   THERE ARE SOME REASONS, THOUGH, THAT YOU MIGHT
01:57:11   ACTUALLY WANT CRYPTOGRAPHIC HASHES IN YOUR DATA
01:57:13   STRUCTURES.
01:57:14   A CLEVER ATTACKER, FOR EXAMPLE, MIGHT TAKE
01:57:16   ADVANTAGE OF YOUR DATA STRUCTURE AND ONLY INSERT
01:57:19   DATA THAT MATCHES A CERTAIN SMALL SET OF HASHES,
01:57:21   FORCING COLLISION AFTER COLLISION, UNTIL YOUR
01:57:23   WHOLE APPLICATION FALLS OVER.
01:57:24   IT'S BEEN DEMONSTRATED THAT PYTHON IS VULNERABLE
01:57:28   TO THIS SORT OF ATTACK, ALTHOUGH THE BDFL CALL
01:57:31   THIS SOME SECURITY RESEARCHERS DRUMMING UP
01:57:34   BUSINESS.
01:57:35   IN PEP 456, CHRISTIAN HEIMS LAYS OUT THE REASON
01:57:39   BEHIND CHOOSING A CRYPTOGRAPHIC HASH FUNCTION AS
01:57:43   THE DEFAULT FOR BITS AND BYTES, COMPARING THE --
01:57:48   AS WELL AS THE PRIVATE CPYTHON HASH
01:57:50   IMPLEMENTATION.
01:57:52   THIS PIP WAS ACCEPTED AND PYTHON 3.4, IT'S SIP
01:57:59   HASH.
01:57:59   ONE OTHER THING.
01:58:01   WE HASHED AN IMAGE TO PUTS IN OUR DATA STRUCTURE
01:58:03   EARLIER.
01:58:04   WHAT SORT OF HASH FUNCTION WORKS ON AN IMAGE?
01:58:07   MOST OF THEM, REALLY, BUT A PERCEPTUAL HASH, OR
01:58:11   P-HASH IS DESIGNED 20 CLUSTER SIMILAR IMAGES
01:58:14   TOGETHER IN THE HASH OUTPUT.
01:58:15   FOR EXAMPLE, IF IT'S THE SAME IMAGE BUT SLICED
01:58:18   LARGER OR SKEWED TO THE LEFT, IT SHOULD END UP
01:58:20   WITH A HASH FUNCTION VERY CLOSE TO THE ORIGINAL
01:58:22   IMAGE.
01:58:22   OF COURSE, BY NATURE, THIS HASH FUNCTION WON'T BE
01:58:25   DISTRIBUTED IN THE WAY THAT WE WOULD NEED FOR AN
01:58:27   OPTIMAL GENERAL PURPOSE DATA STRUCTURE.
01:58:29   IT'S THE OPPOSITE OF AN AFTER LAP HAVING HASH,
01:58:32   SMALL CHANGES IN THE OUTPUT LEAD TO ALMOST NO
01:58:34   CHANGES IN THE OUTPUT.
01:58:35   I SAID OUTPUT TWICE IN THAT LAST SENTENCE.
01:58:37   PAY NO ATTENTION.
01:58:38   BUT WE CAN PAY -- WE CAN ABUSE THAT PROPERTY SO
01:58:41   THAT FALSE POSITIVE ARE UNFAIRLY CLUSTERED ON
01:58:44   IMAGES THAT LOOK VERY SIMILAR TO OUR BAND IMAGES,
01:58:46   WHICH WOULD ACTUALLY PROBABLY BE A GOOD THING IN
01:58:48   THE CASE OF TRYING TO FIND BANNED IMAGES, SO THAT
01:58:51   CONCLUDES THE DATA STRUCTURE PORTIONS OF THE
01:58:54   TALK.
01:58:54   NOW LET'S TACK ABOUT HASH FUNCTIONS CONTRIBUTE TO
01:58:56   THE SECURITY OF YOUR APPLICATION.
01:59:00   SO YOU'RE RUNNING A WEB APPLICATION AND THE WORST
01:59:02   CASE SCENARIO HAPPENS.
01:59:04   SOME HACKER MAKES OFF WITH THE USER TABLE FROM
01:59:07   YOUR DATABASE.
01:59:07   HOW?
01:59:08   I DON'T KNOW, FOR THE SAKE OF ARGUMENT, LET'S SAY
01:59:12   SQL INJECTION.
01:59:13   AT THIS POINT, YOU ARE YOUR USER ARE SHIT OUT OF
01:59:16   WILL BE, SOME BRIGGAND MADE OFF WITH THEIR
01:59:21   PASSWORDS.
01:59:21   NO, SOMEBODY SECURED THEM BEFORE SAVING THEM.
01:59:25   HOPEFULLY YOU ARE A AWARE OF THIS.
01:59:27   IN ORDER TO HIDES THE PASSWORDS, WHEN THE USER
01:59:29   SAVERS THE PASSWORDS, WE DON'T SAVE THE PASSWORDS
01:59:33   ITSELF, WE SAVE THE RESULT OF THE HASH FUNCTION.
01:59:35   LATER, WHEN THE USER TRIES TO LOG IN, THE THEY
01:59:40   TRY TO -- THEY PROVIDE A PASSWORD AND WE HASH
01:59:44   ITS.
01:59:45   IF THE TWO ARE CORRECT, THE USER HAS PRIDES THE
01:59:47   CORRECT PASSWORD.
01:59:48   IF THE TWO DIFFERENT PASSWORDS EVER COLLIDES, IF
01:59:51   TWO HASH STREAMS GO TO THE SAME VALUE, IT WOULD
01:59:54   BE IMPOSSIBLE TO LOG INTO OUR SITE WITH THE WRONG
01:59:56   PASSWORD.
01:59:57   THAT'S BAD.
01:59:57   DO YOU REMEMBER EARLIER WHEN I SAID THAT
01:59:59   CRYPTOGRAPHIC HASHES LIKE MD 5, FOR EXAMPLE, HAVE
02:00:02   A FEATURE CALLED COLLISION RESISTANCE WHICH MEANS
02:00:04   THAT TWO INPUTS ARE ASTRONOMICALLY UNLIKELY TO
02:00:08   COLLIDE?
02:00:09   HERE IS WHERE THAT IS SUPER IMPORTANT.
02:00:11   NOW OUR PASSWORDS ARE PROTECTED.
02:00:13   YEP.
02:00:14   TOTALLY PROTECTED.
02:00:15   NOTHING CAN POSSIBLY GO WRONG.
02:00:17   OKAY, SO LET'S TALK ABOUT DICTIONARY ATTACKS, THE
02:00:21   WAY TO BREAK HASHED PASSWORDS.
02:00:23   SO WE'VE STOLEN A WHOLE DATABASE FULL OF USER
02:00:28   NAMES AND HASH PASSWORDS AND WE WANT TO GET AT
02:00:30   THE RAW PASSWORDS SO THAT HE CAN TRY THEM OUT ON
02:00:34   BANKING SITES AND STUFF.
02:00:35   SO WHAT WE CAN DO IS CREATE A LIST OF EVERYTHING
02:00:38   THAT WE CAN THINK OF AS A POSSIBLE PASSWORD, AN
02:00:40   ENORMOUS COMPREHENSIVE LIST OF PASSWORDS.
02:00:42   THEN WE USE THE SAME HASH THAT THE PROGRAMMER
02:00:45   USED TO HASH THE ORIGINAL PASSWORDS AND WE RUN
02:00:47   THAT ON EVERY SINGLE ITEM IN OUR GIGANTIC
02:00:50   PASSWORD LIST.
02:00:51   NOW WE HAVE A GIANT COLLECTION OF HASHED TO
02:00:54   PASSWORDS PAIRS WHICH WE CAN COMPARE AGAINST THE
02:00:56   ORIGINAL DATA.
02:00:57   ANY TIME WE FIND A MATCH WITH ONE OF THE HASHES
02:01:00   IN OUR SET, WE KNOW WHAT THE PASSWORD MUST HAVE
02:01:03   BEEN.
02:01:03   THIS CHECKING OF EVERY HASH IN THE SET AGAINST
02:01:06   EVERY HASH IN THE DATABASE IS N SQUARED BUT IT'S
02:01:10   INHERENTLY VERY PARALYZABLE SO WITH A BIT OF
02:01:14   OPTIMIZATION, THIS CAN RUN VERY FAST AND SOME
02:01:17   PEOPLE HAVE MANAGED TO USE GRAPHIC SOFTWARE TO
02:01:21   RUN THEM VERY QUICKLY.
02:01:22   SO THIS IS CALLED A PRE-COMPUTED DICTIONARY
02:01:24   ATTACK.
02:01:24   IT'S IMPORTANT TO NOTE THAT THIS ISN'T A RAINBOW
02:01:27   TABLE, A RAINBOW TABLE IS A DIFFERENT THING,
02:01:29   INVOLVE LASH CHAINS THAT ACCOMPLISHES THE SAME
02:01:31   TASK BUT USING A LOT LESS STORAGE SPACE.
02:01:34   AND I'M NOT GOING TO DESCRIBE THEM TODAY BECAUSE
02:01:37   I'M NOT SURE IF I HAVE ENOUGH TIME AND I DON'T
02:01:38   UNDERSTAND THEM SUPER WELL.
02:01:39   SO THE MD 5 HASH FUNCTION IS SO COMMON THAT JUSO
02:01:47   SOLONAN RELEASED A UTILITY CALLED BOZO CRACK,
02:01:51   THAT TAKES A PASSWORD, SEARCHING FOR IT ON GOOGLE
02:01:53   AND MD5 HASHING EVERYTHING THAT COMES BACK IN
02:01:56   GOOGLE RESULTS UNTIL IT FINDS A MATCH.
02:01:58   NOT AS COMPREHENSIVE AS MD5 DICTIONARY BUT STILL
02:02:02   MANAGES TO BE DEPRESSINGLY EFFECTIVE, 85%
02:02:05   EFFECTIVE, SCARY.
02:02:06   PARTS OF THE REASON THESE ATTACKS ARE SO
02:02:08   EFFECTIVE IS BECAUSE EVERY USER'S PASSWORD HAS
02:02:10   BEEN HASHED WITH THE SAME HASH FUNCTION.
02:02:12   IT'S POSSIBLE FOR US TO TEST PASSWORDS AGAINST
02:02:15   THE ENTIRE TABLE ALL AT ONCE.
02:02:17   WHILE IT'S UNLIKELY WE'LL NEVER CRACK ALL THE
02:02:19   PASSWORDS, WE'RE ABLE TO FIND OUT THE USERS WHO
02:02:21   HAVE SIMPLE PASSWORDS VERY, VERY EASILY.
02:02:23   JUST TESTING THE WHOLE DATABASE AGAINST THE
02:02:25   THOUSAND MOST COMMON PASSWORDS SHOULDN'T TAKE
02:02:27   MORE THAN AN HOUR AND WILL PROVIDE US WITH A
02:02:30   WEALTH OF POTENTIAL USEFUL DATA.
02:02:32   SO WHAT WE WANT TO DO TO REDUCE THE EFFECTIVENESS
02:02:35   OF THIS KIND OF ATTACK IS TO USE A DIFFERENT HASH
02:02:38   FUNCTION FOR EVERY SINGLE PERSON IN THE DATABASE.
02:02:39   THIS DOESN'T MEAN WE NEED TO ENLIST THOUSANDS OF
02:02:46   DIFFERENT IMPLEMENTATIONS, WHAT IT MEANS WE NEED
02:02:48   TO USE ONE WHICH WE SEED WITH A DIFFERENT VALUE
02:02:52   FOR EACH USER IN THE TABLE.
02:02:54   IT HAS TO BE A VALUE THAT WE HAVE ACCESS TO.
02:02:56   BECAUSE WE NEED TO BE ABLE TO RECREATE THIS
02:02:58   CUSTOM HASH FUNCTION EVERY TIME WE CHECK THE
02:03:00   USER'S PASSWORD.
02:03:01   IT'S QUITE COMMON TO USE THE USER NAME FOR THIS
02:03:04   VALUE.
02:03:05   DOESN'T MEAN YOU SHOULD USE THE USER NAME, CRIP
02:03:09   TO GO FEARS REQUIRE THAT YOU USE A LARGE RANDOM
02:03:13   BLOCK TO USE AS A SEED.
02:03:14   THIS HASH SEEDING VALUE IS CALLED ASSAULT.
02:03:16   SO ASSAULT IS RANDOM DATA USED AS ADDITIONAL
02:03:21   INPUT TO A HASH FUNCTION TO PROTECT AGAINST
02:03:22   RAINBOW TABLE AND DICTIONARY STYLE ATTACKS.
02:03:25   OKAY, SO THAT COVERS THE VERY, VERY BASICS.
02:03:29   AND WHEN I SAY BASIC, I MEAN THE VERY MOST
02:03:32   BASICS.
02:03:33   THIS ISN'T EXACTLY STATE OF THE ART.
02:03:36   UNIX CRYPT FUNCTIONS FIRST USED SALT HASHES IN
02:03:41   1976, A FULL DECADE BEFORE I WAS BORN.
02:03:44   SO NOW LET'S TALK ABOUT NOT USING MD5, WHICH IS
02:03:46   AN IMPORTANT TOPIC AND HASHES ALL TO ITSELF.
02:03:49   MD5 IS WELL KNOWN AND WELL UNDERSTOOD AND BEEN IN
02:03:51   USE FOR A VERY LONG TIME.
02:03:53   UNFORTUNATELY, IN THAT VERY LONG TIME, SOME
02:03:56   CRACKS HAVE BEGUN TO SHOW IN THIS VENERABLE
02:04:00   HASHING ALGORITHM.
02:04:02   THE BIGGEST REASON TO AVOID IT IS IT'S TOO FAST.
02:04:05   IT'S POSSIBLE TO MD5 HASH MILLIONS OF VARIABLES
02:04:08   PER SECOND.
02:04:09   THIS MAKES BRUTE FORCE ATTACKS AGAINST PASSWORDS
02:04:13   VERY, VERY EASY.
02:04:16   THIS HASHING PYTHON SCRIPT I WROTE RUNS ON A
02:04:18   CHEAP LITTLE VIRTUAL MACHINE, ONE MILLION MD5
02:04:21   HASHES IN 1.5 SECONDS.
02:04:23   AND THIS IS JUST LIKE A VAGRANT 512, YOU KNOW,
02:04:26   POP-UP VIRTUAL MACHINE ON MY COMPUTER, NOT REALLY
02:04:28   SOMETHING THAT IS BEEFY WITH A MUCH FASTER
02:04:32   COMPUTER, YOU CAN RUN MANY MORE HASHES MUCH MORE
02:04:34   QUICKLY.
02:04:35   SO INSTEAD OF MD5, I RECOMMEND BCRYPT OR SCRYPT
02:04:40   OR PDKF2 BCRYPT IS DESIGNED TO BE SLOW.
02:04:46   USING THE DEFAULT SITTING ON THE SAME VIRTUAL
02:04:48   MACHINE, THIS RUN WHERE I USED BCRYPT INSTEAD OF
02:04:51   MD5 WOULD TAKE ME 3.4 DAYS.
02:04:54   THE LAST ONE WAS 1.5 SECONDS, THIS TOOK ME 3.4
02:04:58   DAYS.
02:04:59   THIS COMBINED WITH ASSAULT FOR EACH INDIVIDUAL
02:05:00   USER MEANS THAT BRUTE FORCING PASSWORDS OUT OF A
02:05:04   DATABASE COULD TAKE DAYS OR MONTHS PER USER
02:05:10   RATHER THAN AN HOUR OR TWO.
02:05:11   IT ALSO COMES WITH A WORK VARIABLE THAT YOU CAN
02:05:15   CRANK UP TO 11.
02:05:15   WHEN I TURN IT UP TO 15, MY MILLION HASH SCRIPT
02:05:18   GOES FROM 3.4 DAYS TO RUN TO 26 DAYS TO RUN.
02:05:23   I DIDN'T ACTUALLY LET IT RUN FOR 26 DAYS, I
02:05:25   ACTUALLY LETS IT RUN FOR A MUCH SMALLER AMOUNT OF
02:05:28   TIMES AND MULTIPLIED THE TIME.
02:05:30   SO AT THIS POINT LOGGING A SINGLE USER INTO PLY
02:05:32   SITE COULD TAKE A COUPLE OF SECONDS, SO I'M NOT
02:05:35   SURE THEY'RE WILLING TO WAITS THAT LONG BUT NICE
02:05:38   TO HAVE THE VARIABLE THERE THAT I CAN CRANK UP.
02:05:40   SO FOR PASSWORD SECURITY, YOU SHOULD BE USING
02:05:42   SOMETHING THAT'S SPECIFICALLY DESIGNED FOR
02:05:45   PASSWORDS SECURITY.
02:05:46   LIKE BCRYPT OR PBKDF 2.
02:05:50   BUT EVEN FOR GENERAL PURPOSES, IF YOU'RE LOOKING
02:05:52   FOR A SECURE HASH ALL GO RHYTHM, MD5 IS KINDS OF
02:05:56   OLD AND BROKEN, IT'S BEEN SHOWN THAT YOU CAN
02:05:58   FORCE COLLISIONS IN MD5, BY RESEARCHERS BUT IT
02:06:01   COULD HAPPEN.
02:06:01   SO INSTEAD TRY SECURE HASH ALL GO RHYTHM.
02:06:05   SO SECURE HASH ALGORITHM, OR SHAR 51123 HAS
02:06:12   BECOME A NEW STANDARD FOR GRAPHING, ONE THAT'S
02:06:15   MUCH MORE SECURE.
02:06:15   AND THAT'S BEEN HASH FUNCTIONS, HASH TABLES,
02:06:19   BLOOM FILTERS, CHOOSING HASH FUNCTIONS AND HASHES
02:06:23   AND SECURITY, WHICH CONCLUDES THE BODY OF THE
02:06:25   PRESENTATION.
02:06:26   NOW, I BELIEVE THAT LEAVES US A LITTLE BIT OF
02:06:28   TIME FOR Q AND A.
02:06:30   BEFORE WE START Q AND A, THOUGH, I'M GOING TO
02:06:32   BRING UP MY LIST OF FAKE HASH FUNCTIONS AND I'M
02:06:36   GOING TO SEE IF YOU CAN GUESS WHICH ONES ARE THE
02:06:38   FAKES.
02:06:42   [ Audio Indiscernible ]
02:06:43   >> NO, NOT THAT ONE.
02:06:44   SOME 41 WAS A FAKE HASH FUNCTION.
02:06:50   COME ON HASH FUNCTION SLIGHT, I KNOW YOU'RE IN
02:06:54   HERE SOMEWHERE.
02:06:55   OH, IT WAS IN DATA STRUCTURES, IT WASN'T IN
02:06:57   SECURITY.
02:06:57   THAT'S WHY.
02:06:57   HERE WE GO.
02:07:02   SO WE'VE SUCCESSFULLY IDENTIFIED SOME 41 AS A
02:07:05   FAKE HASH.
02:07:06   [ Audio Indiscernible ]
02:07:07   THE LESTER B. PEARSON HASH IS A FAKE HASH.
02:07:11   THE PIERSON HASH IS A REAL HASH, THOUGH.
02:07:13   LET'S SEE HERE.
02:07:14   MD5 IS REAL.
02:07:15   ANY MORE GUESSES?
02:07:24   [ Audio Indiscernible ]
02:07:25   THE PERFECT HASH IS A REAL HASH.
02:07:26   THE PERFECT HASH IS A HASH FUNCTION THAT HAS
02:07:29   BEEN -- IT'S BEEN CALCULATED IN ADVANCE SO THAT
02:07:32   THE SET OF INPUTS YOU HAVE PERFECTLY MAP TO A SET
02:07:35   OF OUTPUTS.
02:07:35   A REALLY INTERESTING HASH.
02:07:37   AND -- THE FAKE HASH HERE IS THE COUNTRY HASH.
02:07:41   CITY HASH IS REAL, COUNTRY HASH IS FAKE.
02:07:43   PIERSON HASH IS FAKE, LESTER B. PIERSON IS FAKE.
02:07:47   SOME SOME 42 IS REAL, SOME 41 IS BANNED.
02:07:53   SO HAVING CONCLUDED THAT, IF YOU HAVE ANY
02:07:54   QUESTIONS, NOW WOULD BE THE TIME TO ASK THEM.
02:07:56   [ Applause ]
02:08:07   >> THANK YOU VERY MUCH, AND JUST A REMINDER TO
02:08:09   PLEASE ASK A QUESTION AND TRY TO BE CONCISE.
02:08:11   THANKS.
02:08:13   >> AUDIENCE: JUST A QUICK QUESTION.
02:08:15   IS THERE A GOOD BLOOM FILTER IMPLEMENTATION FOR
02:08:18   PYTHON ON PYPY OR SOMETHING?
02:08:20   >> I HAVE LOOKED AROUND.
02:08:22   I REMEMBER LOOKING AND EVENTUALLY CREATING MY OWN
02:08:25   BUT I'M SURE THERE'S ONE ALREADY IN PYTHON
02:08:27   SOMEWHERE.
02:08:27   IT'S A REALLY COMMON DATA STRUCTURE AND MUST
02:08:30   EXIST ALREADY, AND I THINK THE REASON I CREATED
02:08:32   ONE WAS JUST BECAUSE I WANTED TO DO RESEARCH FOR
02:08:34   THIS PRESENTATION, SO...
02:08:36   >> AUDIENCE:  THANK YOU.
02:08:44   >> THAT'S ALL THE QUESTIONS.
02:08:48   >> THANK YOU VERY MUCH.
02:08:50   >> THANKS, EVERYONE.
02:08:50   [ Applause ]



















