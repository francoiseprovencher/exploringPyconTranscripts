03:36:44   [ BREAK ]
03:37:04   ALL RIGHT.
03:51:56   OUR LAST SPEAKER FOR THE DAY IS JOSH TRIPLETT,
03:51:59   HE'LL BE TELLING US HOW HE PORTED PYTHON TO RUN
03:52:01   WITHOUT AN OPERATING SYSTEM.
03:52:12   >> YES, THE WHOLE POINT OF THIS TALK IS WE PORTED
03:52:15   PYTHON TO WORK WITHOUT AN OS, AND I'LL GO INTO
03:52:20   THAT.
03:52:20   I'LL ALSO TALK ABOUT SOME OF THE OTHER THINGS WE
03:52:22   ADDED TO PYTHON IN ORDER TO BUILD UP A NICE
03:52:26   ENVIRONMENT TO WORK WITH AND WE MADE IT A
03:52:28   SUFFICIENTLY COMFORTABLE ENVIRONMENT THAT THE
03:52:29   ALTERNATE TITLE FOR THIS TALK WAS "WE
03:52:32   ACCIDENTALLY HAD AN OPERATING SYSTEM."
03:52:34   SO WITH THAT, YOU KNOW, THE BIG -- LET ME START
03:52:37   WITH THE PUNCH LINE.
03:52:38   WE PORTED PYTHON TO RUN IN THE GRUBE BOOT LOADER,
03:52:42   TO RUN ON BIOS AND EFI FIRMWARE.
03:52:45   SO THAT THEN RAISES A NUMBER OF QUESTIONS, THE
03:52:48   MOST POPULAR OF WHICH TENDS TO BE WHY -- USUALLY
03:52:50   IS YOU HAVE FIXED WITH SOMETHING LIKE WHY WOULD
03:52:52   YOU DO SUCH A THING!!
03:52:53   SO I WANT TO GO INTO THAT, WHAT THE MOTIVATION
03:52:59   FOR THIS IS, WHAT WE USE THIS FOR OTHER THAN AS A
03:53:02   NOVEL PARTY TRICK.
03:53:03   THEN I'LL GO INTO WHAT WE PROVIDE AS PART OF THIS
03:53:05   ENVIRONMENT, BOTH PYTHON ITSELF AND ABOVE AND
03:53:07   BEYOND THAT.
03:53:08   HOW IT WORKS, WHICH IS THE MAIN BULK OF THE TALK,
03:53:12   HOW WE GOT PYTHON RUNNING WITHOUT AN OS.
03:53:15   THEN, PLATFORM APIs THAT WE'VE ADDED ON TOP OF
03:53:19   PYTHON JUST AS YOU WANT ACCESS TO WINDOWS
03:53:21   SERVICES OR LINUX SERVICES, YOU WANT ACCESS TO
03:53:23   THE PLATFORM SERVICES FOR THIS NOT AN OPERATING
03:53:26   SYSTEM.
03:53:26   AND I'M GOING TO BE INCLUDING QUITE A NUMBER OF
03:53:29   DEMOS ALONG THE WAY, JUST SWITCHING OVER AND
03:53:31   RUNNING THINGS WITHIN A VIRTUAL MACHINE TO SHOW
03:53:34   OFF HOW THIS WORKS, THE WHOLE WAY THROUGH.
03:53:36   FIRST OF ALL, WHY WOULD WE DO SUCH A THING IS IN
03:53:40   THE ORIGINAL REASON IS THAT WE WANTED TO TEST
03:53:42   HARDWARE BIOS, ACPI AND EFI.
03:53:46   WE WANTED TO HAVE A NICE, CONVENIENT TEST
03:53:47   ENVIRONMENT FOR POKING AT ALL OF THESE THINGS
03:53:50   WITHOUT HAVING TO WRITE A WHOLE BUNCH OF ONE-OFF
03:53:54   PROGRAMS TO DO TESTS.
03:53:56   THAT WAS THE SECOND REASON, THE TRADITIONAL
03:53:58   APPROACH TO TESTING BIOS OR EFI -- TESTING BYE,
03:54:02   TESTING ACPI, WAS TO WRITE A WOULD YOU KNOW-OFF
03:54:05   TEST PROGRAM USUALLY TARGETING DOS.
03:54:08   THAT ISN'T REALLY A FULL OPERATING SYSTEM,
03:54:11   DOESN'T HAVE ANY PROTECTIONS, YOU CAN POKE
03:54:12   HARDWARE.
03:54:14   WITH CURRENT EFI, THE SAME TENDED TO BE TRUE, YOU
03:54:17   WOULD RUN AN EFI ENVIRONMENT AND RUN A ONE-OFF
03:54:22   TEST PROGRAM.
03:54:23   WE WANTED TO WRITE A SCRIPT WHICH IS MORE FUN.
03:54:26   WE ALSO WANTED TO AVOID WRITING ANY MORE C-CODE
03:54:29   OR FOR THAT MAT THE PREVIOUS INCARNATION OF THIS
03:54:32   ACTUALLY USED GRUB SHELL-LIKE HANK LANGUAGE
03:54:35   TOGETHER WITH A SHELL FUNCTION THAT EVALUATED
03:54:39   C-LIKE EXPRESSIONS WITHIN GRUB SHELL.
03:54:42   WE WANTED TO DO LESS OF THAT, AS WELL.
03:54:43   IN GENERAL, THE MORE SENTENCES I CAN END WITH,
03:54:46   WITHOUT WRITING ANY C-CODE, THE HAPPIER MY LIFE
03:54:48   SFINALLY, WE TURNED OVER TIME THIS TURNED INTO A
03:54:55   NICE EXPLORATORY ENVIRONMENT.
03:54:56   I HAD SOMEONE COMMENT TO ME THEY WERE LOOKING FOR
03:54:59   TO THIS ONE BECAUSE IT BROUGHT BACK SOME OF THE
03:55:01   FUN OF HACKING ON A COMMODORE 64 OR A DOS
03:55:04   ENVIRONMENT WHERE YOU CAN PEEK AND POKE THINGS.
03:55:06   AND YOU CAN'T REALLY DO THAT ON MODERN HARDWARE
03:55:09   ANYMORE.
03:55:09   SO WE'VE SAID WHY.
03:55:11   BUT WHAT AGENCY ARE WE PROVIDING HERE?
03:55:16   THIS RUNS ON A FEW DIFFERENT TARGET PLATFORMS,
03:55:19   RUNS ON BIOS IN 32 BIT, IFI IN EITHER 32 BIT OR
03:55:23   64 BIT.
03:55:24   SO EFFECTIVELY PC HARDWARE WITH WHATEVER KIND OF
03:55:27   FIRMWEAR YOU MIGHT BE RUNNING, THIS WILL RUN.
03:55:29   IT'S CPYTHON, I APOLOGIZE IT IS PYTHON 2.7.
03:55:35   THE REASON FOR THAT IS THE TARGET AUDIENCE FOR
03:55:37   THIS TEST SUITE IS VERY FAMILIAR WITH PYTHON 2.7,
03:55:41   USED IN A VARIETY OF OTHER TOOLS LIKE
03:55:44   OPERATING -- HARDWARE SIMULATING ENVIRONMENTS OR
03:55:47   TESTS FRAMEWORKS AND JTAGS AND VARIOUS SIMILAR
03:55:52   TYPES, SO IF THE TARGET AUDIENCE MOVES TO 2.7, WE
03:55:56   WOULD LOVE TO MOVE TO 3 IF WE CAN DO SO.
03:56:00   WE HAVE A FULL INTERACTIVE PREDEVELOPMENT PRINT
03:56:04   LOOP, SO TYPE AN ARBITRARY COMMAND, TAB-COMPLETE
03:56:08   ALL THE INTERESTING FUNCTIONS, FILLING HISTORY AN
03:56:11   LINE EDITING AVAILABLE AND WE HAVE A PRETTY
03:56:14   SUBSTANTIAL FRACTION OF THE STANDARD PYTHON
03:56:15   LIBRARY, AS WELL.
03:56:16   SO ON TOP OF THAT, WE HAVE SOME ADDITIONAL
03:56:20   MODULES FOR THINGS LIKE PLATFORM SUPPORT.
03:56:22   WE HAVE WAYS TO ACCESS THE FUNCTIONS OF YOUR CPU,
03:56:25   REGISTER CPUI. D.THAT KIND OF THING.
03:56:28   WE HAVE SMP SUPPORT SO YOU CAN RUN THINGS ON
03:56:31   CPUs THAT YOU DIDN'T BOOT ON.
03:56:33   WE HAVE ACPI SUPPORT SO YOU CAN EXPLORE THAT PART
03:56:35   OF YOUR FIRMWARE AND WE HAVE EFI SUPPORT IF
03:56:39   YOU'RE RUNNING THAT PLATFORM.
03:56:40   SO FINALLY, ON TOP OF ALL THAT, WE HAVE A TEST
03:56:44   SUITE AND A BUNCH OF EXPLORATORY TOOLS ALL OF
03:56:47   WHICH WE WERE ABLE TO WRITE IN PYTHON, WHICH IS
03:56:50   GREAT.
03:56:50   SO LET'S START WITH THE FIRST BUILT OF DEMO.
03:56:54   I HAVE A PYTHON PROMPT RUNNING INSIDE A VIRTUAL
03:56:56   MACHINE.
03:56:56   AND I'VE GOT THE FULL POWER OF PYTHON HERE.
03:56:59   I CAN DO LIST COMPREHENSIONS, FOR EXAMPLE.
03:57:02   AND I'VE GOT BIG NUMBS, SO FULL POWER OF PYTHON
03:57:11   AVAILABLE ON YOUR PROMPT.
03:57:13   BUT THAT'S NOT THE ONLY THING WE CAN DO.
03:57:14   SO LET'S TALK A LITTLE BIT ABOUT HOW WE GOT THAT
03:57:18   FAR, THOUGH.
03:57:19   SO IN OF CPYTHON, THERE'S ONE FUNCTION, SHOW THE
03:57:27   PROMPT, READS, DO LINE EDITING, HANDLE ALL OF
03:57:30   WHAT YOU'RE TRYING TO DO, PROCESS, RUN AND
03:57:33   EVALUATE YOUR OPERATION, KEEP STATE AND THAT'S
03:57:35   WHAT YOU DO WITH PI RUN INTERACTIVE LOOP.
03:57:38   THE FIRST STANDARD IN HERE IS JUST WHERE DO I GET
03:57:40   MY INPUT FROM.
03:57:41   AND THE QUOTED STANDARD IN IS WHAT YOU SEE IF YOU
03:57:44   GET AN EXCEPTION THROWN, YOU'LL SEE IN THE TRACE
03:57:48   BACK, LINE X OF STANDARD IN, AND THAT WILL BE THE
03:57:51   LAST ITEM IN YOUR TRACE BACK AND YOU MIGHT HAVE A
03:57:53   FUNCTION THAT YOU CALLED FROM SOME OTHER MODULE
03:57:55   BUT AT THE TOP LEVEL, YOU'RE TYPING AT THIS FILE
03:57:57   NAME STANDARD IN.
03:57:58   BUT THAT'S THE FUNCTION THAT WE CALL, THAT'S THE
03:58:02   ONE FUNCTION THAT WE WANTED TO RUN AT THE TOP
03:58:05   LEVEL.
03:58:05   WHAT DID WE DO TO GET THERE?
03:58:07   WELL, FIRST OF ALL, WE COULDN'T ACTUALLY USE
03:58:09   PYTHON'S CONFIGURE AND MAKE.
03:58:11   AUTOCOMP IS PORTABLE, RUNS ON A LOT OF PLATFORMS
03:58:15   BUT THE REASON WE COULDN'T GO THAT ROUTE IS WE'RE
03:58:16   BUILDING USING A HOST LINUX TOOL CHAIN, USING
03:58:19   JCC, BUILDING AND TARGETING THE SAME THING THAT
03:58:24   GRUB DOES.
03:58:24   SO IN PARTICULAR WHAT WE DON'T HAVE IS THE
03:58:27   CLASSIC CPU TRIPLE VENDOR YOU WOULD SEE FOR WHAT
03:58:31   IS MY TARGETS OPERATING SYSTEM, LIKE I-386 PC
03:58:36   LINUX GENU.
03:58:37   WE DON'T HAVE THAT SO WE CAN'T TARGET GRUB AND
03:58:42   BUILD PYTHON WITH CONFIGURE AND MAKE, AND WE
03:58:44   DON'T THAT HAVE TOOL CHAIN POINTING AT TARGET
03:58:46   HEADERS FOR GRUB IN ORDER TO RUN IN OUR
03:58:49   ENVIRONMENT.
03:58:49   SO INSTEAD, WHAT WE DID WAS ADDED ALL OF THE
03:58:53   PYTHON SOURCE FILES THAT MAKE UP THE PYTHON
03:58:55   DISTRIBUTION, WHAT YOU WOULD NORMALLY HAVE IN THE
03:58:57   MAKE FILE.
03:58:58   WE PUT A LIST OF THOSE INTO THE GRUB BUILD
03:59:01   SYSTEM, SAYING HERE'S ALL THE THINGS YOU NEED TO
03:59:03   MAKE UP PYTHON AND ALL THE EXTEND END SEES OF
03:59:05   PYTHON, A LIST OF C FILES.
03:59:07   OKAY.
03:59:08   AND THEN WE MANUALLY WROTE OUT THE CONFIGURATION
03:59:11   FILE, FILE CONFIG.8.
03:59:15   THIS IS THE FILE THAT AUTO O.COMP AND HEADER
03:59:18   WOULD WRITE OUT THAT TELLS YOU I HAVE THIS
03:59:21   FEATURE OR I DON'T EVER THIS FEATURE.
03:59:22   SO WE HAVE A LONG LIST OF NO, I DON'T HAVES, AND
03:59:25   A HANDFUL OF YES, WE DO HAVE THIS, FOR WAYS THAT
03:59:27   PYTHON NEEDS TO WORK AROUND SHORTCOMINGS OF THE
03:59:30   OPERATING SYSTEM.
03:59:31   WE DON'T HAVE AN OPERATING SYSTEM SO WE DON'T
03:59:32   HAVE A LOT OF THOSE FUNCTIONS, BUT ANYTHING THAT
03:59:35   PYTHON REQUIRES TO RUN AND A HANDFUL OF THE
03:59:38   OPTIONAL ITEMS WE ADDED.
03:59:40   AND THEN WE HAVE TO PROVIDE THOSE FUNCTIONS THAT
03:59:42   PYTHON EXPECTS.
03:59:43   SO WHAT KIND OF FUNCTIONS ARE THOSE, WHAT DO YOU
03:59:45   NEED TO REALLY RUN A CPYTHON?
03:59:49   A COUPLE OF EXAMPLES.
03:59:50   TURNS OUTS YOU NEEDS SOME NON-TRIVIAL FILE
03:59:52   OPERATION HE IS TO RUN PYTHON.
03:59:53   YOU NEEDS THINGS LIKE STATS OR -- IN ORDER TO
03:59:56   FIND OUT, OH, IS THIS A DIRECTORY THAT MIGHT
04:00:00   CONTAIN AN INCHIN.PI OR FOOD.PI.
04:00:05   YOU NEED TO KNOW IF IT IS A TEMP NATURAL, A TTY,
04:00:07   AND WE HAVE A SIMPLE IMPLEMENTATION OF THIS, IF
04:00:11   FILE SCRIPTER LIST THAN 3, YES, I'M TTY.
04:00:14   WE HAVE SEEK, WHICH THE GRUB FILE LAYER DIDN'T
04:00:18   HAVE AN L-SEEK FUNCTION SO WE ADDED ONE FOR
04:00:20   COMPATIBILITY AND IN ORDER TO SUPPORT ALL THESE
04:00:22   FILE SCRIPTERS, WE NEEDED A FILE DESCRIBER TABLE,
04:00:26   HERE, HAVE AN INTEGER THAT CORRESPONDENCE TO A
04:00:28   FILE.
04:00:28   GRUB'S LAYERS LIKE LIKE THE C-STANDS AROUND
04:00:32   I.-- LAYER, AND THAT WAS EASY TO SUPPORT.
04:00:36   BUT TO HANDLE SMALL INTEGER FILE DESCRIPTORS, WE
04:00:38   HAD TO WRITE OUR OWN TABLE.
04:00:40   THIS WAS ACTUALLY WHY IT TOOK SOME TIME TO IMPORT
04:00:46   64-BIT BECAUSE WHEN THEY WERE 32 WE POINTED THE
04:00:50   POINTER TO A BAD IT.
04:00:52   BAD US.
04:00:53   THERE IS A LOT OF OTHER THINGS WE HAD TO ADD.
04:00:55   TURNS OUT WE -- PYTHON WANTS UNGITSYNC.
04:00:59   PLEASE PUT THIS STANDARD CHARACTER BACK.
04:01:01   USES THAT AS PART OF THE PARSERS, SO WE WROTE --
04:01:03   RATHER THAN ADDING A ONE-CHARACTER BUFFER, WE
04:01:06   ADDED A QUICK HACK THAT SAYS PYTHON ALWAYS UNGETS
04:01:09   THE CHARACTER IT JUST GOT SO SEEK BACKWARD BY
04:01:11   ONE.
04:01:12   WE NEEDED A QSORT IMPLEMENTATION AND GRUB DIDN'T
04:01:16   HAVE ANY SORT FUNCTIONS SO WE ENDED UP HAVING TO
04:01:18   OPEN-CODE THAT.
04:01:19   WE NEEDED FLOATING POINT MATH BECAUSE PYTHON DOES
04:01:23   HAVE FLOAT TYPES AND I CAN DO A QUICK DEMO OF
04:01:25   THAT, AS WELL, IF I DO 2.5 TIME PLEA, WE HAVE
04:01:30   FLOATING POINTS.
04:01:31   WE NEEDED THAT, GRUB HAD NONE OF THAT, SO IT
04:01:35   TURNS OUT THERE IS AN OPEN SOURCE PERMISSIVELY
04:01:38   LICENSED LIB M IMPLEMENTATION FOR ALL THE MAJOR
04:01:41   MATH FUNCTIONS THAT IS AVAILABLE, IT DOES PURE
04:01:45   SOFTWARE, CALLED FDLIBIN'.
04:01:47   DOESN'T HAVE ANY HARDWARE ACCELERATION.
04:01:49   WE CONSIDERED THAT TO BE A BIT OF A FEATURE
04:01:51   BECAUSE IT DOESN'T REQUIRE THE REST OF THE
04:01:52   FIRMWARE TO HAVE PROPERLY INITIALIZED FLOATING
04:01:56   POINT SUPPORT.
04:01:56   IF YOU TRY TO USE FLOATING POINTS, IF THE
04:01:59   FIRMWARE HASN'T INITIALIZED, YOU WOULD END UP
04:02:01   BREAKING SO THAT'S GREAT.
04:02:02   WE ALSO NEEDED PRINTS F, S PRINT OF, PYTHON USES
04:02:06   THOSE.
04:02:06   FOR THE MOST MART, WE COULD USE GRUB'S
04:02:08   IMPLEMENTATION OF THESE FOR SOME OF THE BASIC
04:02:10   FUNCTIONALITIES BUILT WHICH HAD TO EXTENDS IT FOR
04:02:12   A FEW THINGS THAT GRUB DIDN'T KNOW HOW TO HANDLE.
04:02:15   SO, FOR EXAMPLE, IT DIDN'T HAVE THE PERCENT
04:02:18   PERCENT ESCAPE TO PUT A PERCENT IN THE FINAL
04:02:22   STRING AND PYTHON USES THIS TO CREATE A FORMAT
04:02:24   STRING AND THEN RUN THAT BACK THROUGH PRINT F,
04:02:27   WHEN YOU HAVE * WHENEVER YOU USE THE PERCENT
04:02:30   OPERATOR ON THE PYTHON COMMAND LINE SO UNTIL WE
04:02:32   FIGURED OUT WE DIDN'T HAVE THIS, WE HAD SOME VERY
04:02:34   INTERESTING BUGS.
04:02:35   SO APART FROM THAT, WE ALSO WANTED TO WORK
04:02:37   THROUGH A HANDFUL OF INTERESTING PERFORMANCE
04:02:39   ISSUES.
04:02:40   SO AT -- WHEN NOT TOO LONG AGO, WE FOUND OUT THIS
04:02:44   TOOK A SURPRISINGLY LONG TIME TO BOOT AND THAT'S
04:02:46   PAINFUL ENOUGH ON REAL HARDWARE, IT WAS EXTRA
04:02:49   PAINFUL IF YOU'RE IN A CPU CIRCUIT SIMULATION
04:02:52   ENVIRONMENT THAT RUNS VERY, VERY SLOWLY.
04:02:54   WE WOULDN'T WANT THIS TO TAKE THREE DAYS TO BOOT.
04:02:56   SO WHAT WE -- PART OF THIS COMES BECAUSE THE
04:03:00   PYTHON PARISSER IS FAIRLY INTRICATE, READS READ
04:03:04   CHARACTER BY CHARACTER, USES GITSYNC, GRUB HAS
04:03:09   VERY FULL DISK CACHES, SO WE USED BYTE SUPPORT.
04:03:16   WE BUILT AN EXTRA COPY OF PYTHON ON OUR HOST
04:03:19   SYSTEM AS PART OF THE BUILD SYSTEM, USED TO THAT
04:03:22   BYTE COMPILE INTO PI C FILES, AND THEN IT TURNS
04:03:26   OUT GRUB DOESN'T HAVE MODIFICATION TIME SUPPORT
04:03:28   BUT WE KNOW WE ALWAYS HAVE THE PI C FILES THAT WE
04:03:31   JUST BUILT SO WE ZERO OUT THE MTIME IN THE FILES
04:03:34   WHICH MATCHES THE ZERO FEEDBACK FROM OUR
04:03:37   IMPLEMENTATION.
04:03:38   YES, IT'S UP-TO-DATE.
04:03:40   SILL A LITTLE SLOW BECAUSE ON A LINUX SYSTEM YOU
04:03:44   EXPECT STAT TO TAKE MICROSECONDS AND OURS TAKES
04:03:48   MILLISECONDS BUT IT'S STILL FASTER FORWARD ADDING
04:03:52   THAT SUPPORTS.
04:03:53   SPEEDING IT UP FURTHER, WE CAN USE ZIP IMPORT,
04:03:56   ZIP UP THE BYTE CODES AND IMPORT IT THAT WAY AND
04:03:59   WE DO ONE BIG CONSISTENT READS OFF DISK SO WE ADD
04:04:01   THE Z-LIB SUPPORT NEEDED TO RUN ZIP SUPPORT.
04:04:05   APART FROM THAT, WE ALSO WANTED HISTORY, WE
04:04:07   WANTED COMPLETION, LINE EDITING, AND SO NORMALLY
04:04:10   YOU DO THIS WITH THE READ LINE LIBRARY, BUT THAT
04:04:15   DEPENDS ON POSIX AND DETAILS OF HOW TO RUN A
04:04:19   TERMINAL.
04:04:19   WE DON'T HAVE A DEV TTY OR PTC AREA LAYER, WE
04:04:23   DON'T HAVE THE USUAL HIGH OCTALS TO RUN THAT KIND
04:04:27   OF THING AND WE DIDN'T WANT TO RUN A PILE OF
04:04:30   C-CODE THAT WE FRESHLY WROTE TO SOLVE THIS
04:04:33   PROBLEM BECAUSE THAT'S WHAT WE'RE TRYING TO GET
04:04:35   AWAY FROM, WE WANT TO WRITE MORE PYTHON.
04:04:37   SO INSTEAD WE KIND OF HAD A SNAKE EATING ITS OWN
04:04:41   TAIL HERE AND WE WROTE PYTHON'S OWN WRITING IN
04:04:44   PYTHON.
04:04:45   TO DO THAT, WE IMPLEMENTED THE LINE EDITING, THE
04:04:48   COMPLETION IN THE PURE PYTHON AND IN C, IN THE
04:04:52   SMALL C STUBS WE HAVE, WE SET THE PI OS FUNCTION
04:04:56   POINTER TO A C FUNCTION THAT USES THE PYTHON API
04:04:59   TO CALL A CALL BACK THAT WAS PREVIOUSLY SET UP.
04:05:01   SO WE CALL IN TO PYTHON, GET THE DATA BACK, FEED
04:05:05   THAT BACK INTO PYTHON, WHICH IS THEN RETURNED TO
04:05:07   THE ORIGINAL PYTHON PROMPT SAYING HERE'S WHAT I
04:05:10   LINE EDITED AND READ.
04:05:11   SO THE MORE BITS THAT WE CAN WRITE IN PURE
04:05:14   PYTHON, EVEN IF THEY WERE INTENDED TO BE WRITTEN
04:05:16   IN C, THE BETTER.
04:05:18   APART FROM THAT, WE ALSO WANTED TO HAVE DYNAMIC
04:05:22   MENUS IN GRUB, SO THAT HAS A LOVELY MENU SYSTEM
04:05:25   SO YOU CAN CHOOSE, DO YOU WANT TO BOOT LINUX OR
04:05:29   WINDOWS OR SOME OTHER VERSION OF LINUX AND WE
04:05:32   WANTED THAT MENU TO DO TEST SUITES.
04:05:34   WHAT TESTS DO YOU WANT TO RUN, OR DO ALL OF THEM,
04:05:37   OR DO THIS EXPLORATORY ACTIVITY OR PULL UP A
04:05:39   PROMPT.
04:05:40   GRUB ALREADY HAS DISK AND FILE SYSTEM PROVIDERS
04:05:42   FOR THINGS LIKE ZERO HARD DISK, CDROM, FLOPPY
04:05:46   DRIVE, SO WE ADDED ONE FOR PYTHON.
04:05:50   THERE IS A GRUB N PYTHON DEVICE THAT WHEN YOU
04:05:53   CALL IT, IT WILL GO READS THE FILE YOU SPECIFIED
04:05:56   BY HANDING THAT TO PYTHON TO VERIFY IT AND
04:05:59   FEEDING THE DATA BACK TO GRUB.
04:06:00   YOU CAN ADD IN ANY MEMORY FILE YOU WANT, LIKE THE
04:06:03   FUSE FILE SYSTEM, AND YOU RUN A GRUB COMMAND.
04:06:06   MY CONFIG FILE IS IN THE PYTHON FILE SYSTEM,
04:06:09   MENU.CFG.
04:06:11   SO EVEN MORE C CODE WE DON'T HAVE TO WRITE.
04:06:13   >> SO APART FROM THAT, THAT'S A LOT OF THE STUFF
04:06:16   THAT WE'VE ADDED TO MAKE THAT INTERFACE WITH GRUB
04:06:19   TO WORK BETTER ON THE SYSTEM.
04:06:20   HOW DO WE HANDLE HARDWARE SPECIFIC FUNCTIONALITY.
04:06:23   WELL, WE WANT TO HAVE THINGS LIKE CPU I.D.,
04:06:26   MEMORY MAPPED IO, IO PORT SO WE DID THAT BY
04:06:30   ADDING A NEW MODULE CALLED BITS.
04:06:33   SO I CAN SHOW THAT OFF A LITTLE BIT, AS WELL.
04:06:35   LET ME IMPORT BITS AND RUN -- I'M ALSO GOING TO
04:06:38   NEEDS THE C-TYPES MODULE WHICH I'LL EXPLAIN IN A
04:06:41   BIT IN ORDER TO GO TALK TO LITTLE PIECES OF REAL
04:06:44   HARDWARE.
04:06:44   NOT BECAUSE WE'RE CALLING IF YOU THINKS FROM
04:06:45   THERE YET BUT BECAUSE WE NEED TO MANIPULATE RAW
04:06:49   MEMORY IN WAYS THAT YOU WOULDN'T NORMALLY WANT TO
04:06:50   DO ON A LIVE HOSTED SYSTEM.
04:06:53   SO I'M GOING TO CALL CPU I.D. ON CPU ZERO AND GET
04:06:59   THE NUMBER ZERO AND THAT GIVES YOU A CPU
04:07:01   I.D. RESULT WITH THESE PROCESSOR REGISTERS, SO,
04:07:04   FIRST OF ALL, HOW FUN IS THAT?
04:07:06   GETTING PROCESSOR REGISTERS FROM PYTHON AND THEN
04:07:09   I CAN INTERPRET THAT RESULT, THE LAST THREE
04:07:11   REGISTERS THERE ARE AN IDENTIFIER OF WHAT CPU I
04:07:15   RUN ON.
04:07:15   I CAN SET UP A BUFFER OF THREE 32s AND THAT IS
04:07:21   C.PDB, .EDX IN THAT ORDER AND THEN PART OF THE
04:07:28   REASON I NEED C-TYPES IS SO I CAN REINTERPRET
04:07:32   THAT IN A DIFFERENT WAY AS A C-CHARACTER ARRAY, A
04:07:36   12-CHARACTER STRING FROM THAT SAME BUFFER, AND
04:07:39   WHAT'S THAT VALUE?
04:07:40   THAT'S THE PROCESSER I'M RUNNING ON.
04:07:43   SO GOING OFF AND DOING A CPU I.D. INSTRUCTION
04:07:46   FROM PYTHON.
04:07:47   A C-FUNCTION UNDERNEATH TO DO CPU I.D. BUT I
04:07:50   DON'T HAVE TO ASSEMBLE THE RESULT FROM ANYTHING
04:07:52   BUT PYTHON.
04:07:53   SO BACK TO THE PRESENTATION.
04:08:01   ANOTHER ONE, I MENTIONED ON CPU0.
04:08:04   WE WANT TO TEST HIGHLY PARALLEL SYSTEMS WE, DON'T
04:08:06   CRUST WANTS TO TEST THE CPU BOOTED ON, GRUB ONLY
04:08:10   KNOWS ABOUT THE CPU YOU BOOTED ON SO WE NEED TO
04:08:12   GO COLLECT AND MODIFY STATE ON ANY RANDOM CPU.
04:08:15   SO WE WAKE UP EVERY CPU AT RUN TIME WHICH GRUB
04:08:18   DOESN'T DO, PUT THEM INTO A SLEEPING LOOP USING
04:08:21   MWAY AND SAY, OKAY, SIT THERE AND WAIT FOR ME TO
04:08:23   HAVE WORK FOR YOU.
04:08:24   AND THEN WE HAVE A FEW C FUNCTIONS THAT JUST SAY,
04:08:27   GO WAKE UP THAT CPU, RUN THIS INSTRUCTION ON IT
04:08:29   AND GET BACK TO ME WITH THE RESULT.
04:08:31   AND THEN WE BIND ALL THOSE FUNCTIONS TO PYTHON.
04:08:34   SO THE NICE THING IS THAT THEN WHEN WE COLLECT
04:08:36   ALL THOSE RESULTS, PYTHON'S GREAT DATA STRUCTURES
04:08:39   GIVE US THE ABILITY TO CORRELATES THOSE RESULTS,
04:08:42   LIKE IF I RUN CFI I.D.ON EVERY ONE BUT 0, IT HAD
04:08:47   THIS RESULTS AND 0 HAD THAT RESULT.
04:08:50   THAT HE THAT'S INTERESTING.
04:08:51   SAME THING WITH MSR, SAME THINGS WITH MEMORY READ
04:08:54   FROM DIFFERENT PROCESSORS, YOU GET CORRELATING
04:08:57   RESULTS THAT ARE HARD TO PUT TOGETHER AND SEE
04:08:59   BECAUSE OF LACK OF BASIC DATA STRUCTURES.
04:09:01   APART FROM THAT, WE WANTED TO TALK TO YOUR ACTUAL
04:09:04   FIRMWARE, NOT JUST THE HARDWARE BUT FIRMWARE
04:09:07   LAYER.
04:09:07   IN PARTICULAR, THERE'S ACPI, THE ADVANCED
04:09:10   CONFIGURATION POWER INTERFACE.
04:09:12   THAT IS WHAT YOU USE TO FIND HARDWARE ON MODERN
04:09:14   SYSTEMS, TO FIND OUT HOW TO PUT YOUR CPU TO SLEEP
04:09:16   OR YOUR WHOLE SYSTEM TO SLEEP.
04:09:18   IT HAS A BUNCH OF STATIC DATA TABLES AS WELL AS
04:09:23   BYTE METHODS, AND WE WANTED TO DRIVE THIS FROM
04:09:25   PYTHON, NOT FROM C, SO WE PULLED IN THE REFERENCE
04:09:28   IMPLEMENTATION OF ACPI C.A., WE PUT THAT IN BITS
04:09:33   AND HANDLED ITS PORTABILITY ISSUES, AS WELL.
04:09:35   THAT IS A C-LIBRARY AND WE ADDED PYTHON BINDINGS
04:09:38   TO IT.
04:09:38   IN PARTICULAR, IT'S POSSIBLE TO EVALUATE AN
04:09:42   ARBITRARY APCI METHOD, FEED IT ARGUMENTS FROM
04:09:45   PYTHON, THEY GET CONVERTED TO ACPI, GO CALL AND
04:09:48   INTERPRET THE BYTE KIDS METHOD, FEED THE RESULT
04:09:50   BACK TO PYTHON AND, AGAIN, NO EXTRA C-CODE
04:09:53   INVOLVED.
04:09:53   SO LET'S DO A QUICK DEMO OF THAT.
04:09:57   I CAN GO IMPORT ACPI.
04:09:59   AND I CAN DUMP EVERY METHOD ON MY SYSTEM THAT HAS
04:10:06   THE HARDWARE IDENTIFIER NAME SO GO FIND ME ALL MY
04:10:10   HARDWARE AND WHAT MAGIC NUMBER IT HAS FOR WHAT
04:10:12   THE KIND OF HARDWARE THIS IS AND YOU CAN SEE THAT
04:10:14   WE'VE GOT THINGS LIKE A COUPLE OF SERIAL PORTS, A
04:10:17   FLOPPY DISK CONTROLLER, A PS2 KEYBOARD AND MOUSE
04:10:22   ALL PROVIDED BY THIS VIRTUAL MACHINE AND THEY
04:10:23   HAVE DIFFERENT IDENTIFIERS, THIS ONE IS THE
04:10:25   I.D. OF A SERIAL PORT AND BOTH OF THEM HAVE THE
04:10:27   SAME I.D., SO THIS IS HOW YOUR MODERN LINUX
04:10:30   SYSTEM OR MODERN WINDOWS SYSTEMS FINDS THE
04:10:33   HARDWARE ON YOUR SYSTEM.
04:10:34   HERE'S HARDWARE, HERE'S ITS I.D.
04:10:37   SO I'M NOT GOING TO GO INTO GREAT DETAIL ABOUT
04:10:41   HOW TO EXPLORE HARDWARE, I'VE GIVEN TALKS ABOUT
04:10:44   THAT ELSEWHERE.
04:10:44   THE FOCUS OF THIS IS HOW WE MADE THIS WORK AND
04:10:48   HOW WE GOT THIS WORKING WITH FIRMWARE.
04:10:50   SO THE NEXT ITEM I WANT TO GO INTO IS EFI.
04:10:53   SO ON SYSTEMS THAT AREN'T JUST RUNNING BASIC BIOS
04:10:56   BUT RUNNING THE EXTENSIVE FIRMWARE INTERFACE, YOU
04:11:00   WANT SOME ABILITY TO CALL THE FUNCTIONS THAT
04:11:02   PROVIDES AND EXTENSIBLE HERE IN EFA MEANS THAT
04:11:05   EVERYTHING IS A PROTOCOL, IF YOU'RE FAMILIAR WITH
04:11:08   COM ON WINDOWS, THIS WAS SOMEWHAT INSPIRED BY
04:11:10   THAT.
04:11:11   LET ME GO GET THIS INTERFACE, CALL ALL THE
04:11:13   FUNCTIONS THAT IT PROVIDES, AND THOSE ARE ALL
04:11:15   NATIVE C FUNNELS USING A CALLING CONVENTION
04:11:18   PROVIDED BY C, SO LET'S TAKE A LOOK AT WHAT THAT
04:11:21   WOULD LOOK LIKE.
04:11:22   I CAN GO IMPORT THE EFI MODULE, WHICH ONLY EXISTS
04:11:26   SINCE I'M BOOTED VIA EFI AND I CAN GET A METHOD
04:11:30   FROM THE SYSTEM TABLE PROVIDED TO EFI APPS WHEN
04:11:35   THEY START UP.
04:11:37   IN PARTICULAR, A CONSOLE METHOD.
04:11:40   I CAN GET THE ACTUAL STRUCTURE OF THAT SINCE
04:11:42   THAT'S A POINTER, C-TYPE'S CONVENTION FOR
04:11:45   REFERENCING A POINTER SO NOW I HAVE AN OUTPUT
04:11:47   INTERFACE.
04:11:48   AND I CAN CALL METHODS LIKE CLEAR SCREEN, AND
04:11:52   PASS THAT INTERFACE AND CLEAR THE SCREEN BY
04:11:56   CALLING A FIRMWARE FUNCTION FROM PYTHON.
04:11:58   OR I COULD OUTPUT A FAMILIAR GREETING...
04:12:08   AGAIN, USING FIRMWARE FUNCTIONS, NOT USING
04:12:13   PYTHON.
04:12:14   SO HOW THAT ACTUALLY WORKS, C-TYPES IS AN
04:12:18   INTERFACE TO CALL C-TYPES AND C-FUNCTIONS FROM
04:12:22   PYTHON.
04:12:23   AND LIB FFI IS THE FOREIGN FUNCTION INTERFACE
04:12:27   LIBRARY THAT'S BUILT ON THAT ACTUALLY IMPLEMENTS
04:12:29   THE CALLING CONVENTIONS SO IT'S WHAT SAYS THAT IF
04:12:31   YOU WANT TO CALL A FUNCTION, THEN THIS ARGUMENT
04:12:34   IS IN THIS REGISTER THIS ONE HERE THE REMAINING
04:12:37   ARGUMENTS ARE PUSHED ON THE STACK IN THIS ORDER,
04:12:39   HERE'S HOW TO CLEAN IT UP.
04:12:41   AND IT IMPLEMENTS ALTHOUGH PLATFORM SPECIFIC
04:12:43   FUNCTIONALITY SO THAT PYTHON AND C-TYPES DON'T
04:12:48   HAVE TO.
04:12:48   SO WE PORTED LIB FFI TO LIVE INSIDE THE GRUB
04:12:52   ENVIRONMENT AND WE ADDED SUPPORT FOR THE EFI
04:12:54   CALLING CONVENTION WHICH IS DIFFERENT ON 32-BIT
04:12:56   AND 64 BIT, ON 32-BIT, IT IS THE STANDARD CALL
04:13:00   CONVENTION USED ON WINDOWS AND ON 64-BIT, IT'S
04:13:03   THE WINDOWS 64-BIT CALLING CONVENTION WHERE YOU
04:13:05   PASS A PILE OF ARGUMENTS IN REGISTERS.
04:13:07   SO ONCE WE ADDED THAT SUPPORT, WE CAN NOW DECLARE
04:13:12   AN EFI FUNCTION AND AN EFI FUNCTION PROTOCOL FULL
04:13:16   OF FUNCTIONS ENTIRELY IN PYTHON USING THE C TYPE
04:13:19   LANGUAGE, CALL THEM FROM PURE PYTHON AND WITHOUT
04:13:21   WRITING A SINGLE LINE OF C-CODE TO CALL IN
04:13:24   ARBITRARY FIRMWARE FUNCTION.
04:13:26   SO WHAT KINDS OF THINGS CAN WE DO WITH THIS
04:13:29   BEYOND JUST HELLO WORLD, THAT KIND OF THING.
04:13:31   WE'VE GOT A BINDING FOR THE EFI FILE LAYER THAT
04:13:34   USES EFI FILE PROTOCOL AND THE NICE THING ABOUT
04:13:37   THIS, UNLIKE GRUBS FILE ERRORS, IT KNOWS HOW TO
04:13:40   MAKE -- TO WRITES TO A FILE SYSTEM AND NOT JUST
04:13:42   READ IT.
04:13:43   SO WE CAN DO THINGS LIKE THIS, GO GET THE BOOT
04:13:45   FILE SYSTEM, MAKE A DIRECTORY IN IT, CREATE A
04:13:48   FILE IN THAT DIRECTORY, AND WRITE SOME CONTENTS
04:13:50   TO THAT.
04:13:51   WE CREATED A FILE-LIKE OBJECT ON TOP OF THIS
04:13:54   INTERFACE THAT GIVES YOU ALL THE STANDARD THINGS
04:13:57   YOU EXPECT FROM A PYTHON FILE.
04:13:59   ON TOP OF THAT, HOW ABOUT GRAPHICS?
04:14:03   WE'VE DONE TEXT BUT THERE IS AN EFI GRAPHICS
04:14:06   OUTPUT PROTOCOL THAT GIVES YOU FUNCTIONS TO READ
04:14:09   AND WRITE THE CONTENTS OF THE SCREEN.
04:14:10   SO WHAT KINDS OF THINGS MIGHT WE DISPLAY WITH
04:14:13   THIS ONE?
04:14:13   WELL, IT TURNS OUT PRESENTATION SLIDES ARE
04:14:17   GRAPHICS, SO WHEN I SAID THERE ARE DEMOS
04:14:19   THROUGHOUT THIS TALK, I SHOULD ALSO SAY THIS
04:14:22   ENTIRE TALK IS A DEMO AND IT'S ALL RUNNING INSIDE
04:14:24   OF THIS ENVIRONMENT.
04:14:25   [ Applause ]
04:14:26   THANK YOU.
04:14:37   SO IN PARTICULAR, EVERY TIME IT LOOKED LIKE I WAS
04:14:39   DOING AN ALT TAB BACK AND FORTH BETWEEN A PYTHON
04:14:43   WINDOW AND THIS, I WAS HITTING ESCAPE TO GET OUT
04:14:45   OF MY PRESENTATION AND A HOT KEY THAT BINDS INTO
04:14:48   OUR READ LINE LAYER TO JUMP BACK TO THE
04:14:50   PRESENTATION.
04:14:51   AND LOOKS A LOT LIKE I'M SWITCHING BUT IT'S ALL
04:14:54   RUNNING IN THE SAME APPLICATION, WITHOUT AN
04:14:56   OPERATING SYSTEM AND IMENTIRELY USING EFI
04:15:01   GRAPHICS PROTOCOL.
04:15:01   NO NEW C-CODE, NOT A SINGLE LINE.
04:15:04   SO WITH THAT, THE -- ONE LAST DEMO I WANT TO GIVE
04:15:09   SINCE I DO HAVE A MOMENT OF TIME, IS IF I CAN DO
04:15:13   GRAPHICS, WHO HERE REMEMBERS THE FUN OLD DAYS OF
04:15:16   COMMODORE 64, OF DOS, WHERE YOU COULD PEEK AND
04:15:20   POKE HARDWARE AND ESPECIALLY YOU COULD GET A RAW
04:15:22   POINTER TO THE SCREEN AND START SCRIBBLING ON IT
04:15:26   AND DRAWING.
04:15:27   ANYBODY?
04:15:28   AWESOME.
04:15:28   LOTS OF HANDS.
04:15:29   LET'S DO SOME OF THAT.
04:15:30   SO LET'S GET A POINTER TO THE FRAME BUFFER, WHICH
04:15:34   EVERY COLOR HAPPENS TO BE A 32-BIT VALUE IN BGR
04:15:39   DATE ORDER, FOR WHATEVER REASON.
04:15:41   I HAVE AN 800 BY 600 DISPLAY, SO I'LL CREATE A
04:15:45   GIANT TWO-DIMENSIONAL ARRAY.
04:15:47   I'LL PUT -- GO GET THAT FROM BITS.PRESENT, WHICH
04:15:52   IS ALREADY INITIALIZED GRAPHICS FOR ME.
04:15:54   THE GOP INTERFACE, GRAPHICS OUTPUT PROTOCOL, GO
04:15:58   GET THE VIDEO MODE STRUCTURE AND DE-REFERENCE IT
04:16:01   AND GO GET FRAME BUFFER BASE, WHICH TELLS YOU THE
04:16:06   EQUIVALENTS HERE WOULD BE GO CREATE A POINTER TO
04:16:08   C-BILLION OR A BILLION IN DOS WHERE A VIDEO
04:16:11   MEMORY HAPPENS TO LIVE.
04:16:12   WELL, HERE'S WHERE IT LIVES.
04:16:13   SO HERE'S MY FRAME BUFFER, LET'S DO A QUICK LOOP
04:16:17   AND OUTPUT SOME THINGS.
04:16:18   I'LL CREATE A 400 BY 400 IMAGE TO GET IT
04:16:23   SOMETHING BIG ENOUGH TO SEE WITHOUT TAKING TOO
04:16:26   LONG.
04:16:26   AND I'LL DECLARE A COUPLE OF BITS OF MATH HERE TO
04:16:36   BUILD SOMETHING INTERESTING.
04:16:37   DOING SOME SCALING TO MAKE IT 400 BY 400.
04:16:46   AND I'LL DO A LITTLE BIT OF ITERATIVE MATH.
04:16:55   25 ITERATIONS OUGHT TO BE ENOUGH.
04:17:01   LET'S ITERATE.
04:17:02   AND THE OTHER COMPONENT.
04:17:12   I HEAR SOME LAUGHTER FROM THE PEOPLE WHO
04:17:16   RECOGNIZE WHAT I'M DOING.
04:17:17   LET'S CHECK THE MAGNITUDE.
04:17:19   AND LET'S DRAW SOME COLOR.
04:17:28   BUT IT UP IN THE UPPER RIGHT CORNER.
04:17:30   ASSIGN IT AN APPROPRIATE COLOR.
04:17:34   DISTRIBUTE IT TO ALL THREE COMPONENT AND DRAW.
04:17:42   WE HAVE FRACTILES IN PYTHON VIA GRAPHICS
04:17:50   PROTOCOL.
04:17:50   [ Applause ]
04:18:02   >> AND WITH THAT, ANY QUESTIONS?
04:18:04   ALL RIGHTY.
04:18:09   THERE'S A MIC RIGHT THERE IN THE CENTER IF YOU
04:18:12   WANT TO BE AUDIBILITY.
04:18:24   >> AUDIENCE:  THAT IS LOUD.
04:18:26   YOUR FFI PORTS, DID YOU RUN INTO ANY PARTICULAR
04:18:28   STRUGGLES IMPORTING THAT TO THE EFI ENVIRONMENT
04:18:32   FOR ANY MEMORY MANAGEMENT OR POINTER HANDLING OR
04:18:35   THE LIKE?
04:18:35   >> SO MEMORY MANAGEMENT AND POINTER HANDLING IS
04:18:38   ACTUALLY ALMOST EXCLUSIVELY HANDLED BY C-TYPES
04:18:40   AND WE DIDN'T HAVE TO DO ANYTHING SPECIAL TO MAKE
04:18:42   THAT WORK.
04:18:43   THE NON-TRIVIAL EFFORT INVOLVED WAS ACTUALLY
04:18:46   PORTING LIB FFI ITSELF TO UNDERSTAND THE CALLING
04:18:49   CONVENTION USED BY EFI.
04:18:51   SO IN PARTICULAR, LIB FFI UNDERSTANDS HOW TO CALL
04:18:55   WINDOWS FUNCTIONS ON WINDOWS AND HOW TO CALL
04:18:57   LINUX IF YOU THINKS ON LINUX.
04:18:59   IT HAD NO IDEA HOW TO CALL WINDOWS FUNCTIONS ON
04:19:02   WHAT WE'RE PRETENDING IS A POSIX SYSTEM AND THAT
04:19:05   LAYER WAS NON-PORTABLE SHE IT ONLY RAN ON
04:19:08   WINDOWS, SO WE ENDED UP WRITING ABOUT 50, 75
04:19:12   LINES WORTH OF EXTRA CODE TO PORT THAT OVER,
04:19:15   INCLUDING SOME X-86 AND X-6866 ASSEMBLY CODE TO
04:19:21   MAKE THAT WORK IN BOTH PLAT FORAGES AND IT WAS
04:19:23   ONE OF THOSE CASES WHERE IT WAS ABOUT A WEEKEND
04:19:25   WORTH OF WORK TO RIGHT THE 55 LINES OF CODES AND
04:19:29   DEBUG IT BUT ONCE WE HAD THAT WORKING, V-TYPES
04:19:32   WAS REALLY TRIVIAL.
04:19:33   >> AUDIENCE:  GOTCHA.
04:19:34   THANK YOU.
04:19:36   >> AUDIENCE:  IS THERE ANY WAY TO HANDLE
04:19:38   INTERRUPTS?
04:19:39   >> SO, RIGHT NOW, WE DON'T HAVE A HOOK FOR THAT.
04:19:44   WE COULD EASILY ADD THAT ONE.
04:19:45   THAT WOULD EFFECTIVELY BE, LET'S WRITE A SMALL
04:19:48   HANDFUL OF LINES OF ASSEMBLY TO BUILD THE --
04:19:51   ACTUALLY, I TAKE THAT BACK.
04:19:52   LET ME COVER -- LET ME COVER ONE ITEM THERE.
04:19:54   YOU COULD ACTUALLY WRITE TO THE INTERRUPT
04:19:57   DESCRIPTOR TABLE EASILY ENOUGH AND YOU COULD USE
04:20:00   C-TYPES TO CREATES A FUNCTION THAT IS CALLABLE
04:20:04   FROM THAT ENVIRONMENT.
04:20:05   THE ONLY REALLY TRICKY BIT THERE IS THAT WITHOUT
04:20:08   A LITTLE EXTRA HELP FROM C, THERE'S NO WAY TO DO
04:20:11   AN INTERRUPT RETURN, SO WE WOULD NEED A COUPLE OF
04:20:14   EXTRA HELPER FUNCTIONS TO MAKE THAT WORK BUT WE
04:20:17   DON'T YET HAVE THEM.
04:20:18   FLIPPING THAT AROUND, WE SHOULD ALSO ADD THE
04:20:20   CLASSIC ENT86 DOS C COMPILER FUNCTION SO THAT YOU
04:20:25   COULD CALL THE SOFT WARE INTERRUPT BUT THOSE
04:20:27   WOULD BE MAYBE, 10, 15 LINES OF CODES AND A
04:20:30   PYTHON BINDING AND WE'RE DONE AND WE WRITE
04:20:32   EVERYTHING THAT USES THAT IN PYTHON.
04:20:34   SO FOR THAT MATTER, I WOULD BE HAPPY TO CHAT WITH
04:20:37   YOU IF YOU WOULD LIKE TO HACK ON THAT AND WORK ON
04:20:39   A PATCH FOR THAT.
04:20:39   A FUN ENVIRONMENT TO HACK ON.
04:20:41   NEXT QUESTION?
04:20:45   >> AUDIENCE:  I WANTED TO ANNOUNCE THAT THE
04:20:46   LIGHTNING TALKS WILL BE STARTING IN A COUPLE OF
04:20:48   MINUTES SO ANYONE WHO HAD SIGNED UP FOR THAT
04:20:50   SHOULD HEAD DOWN BUT WE CAN DO FIVE MORE MINUTES
04:20:52   OF QUESTIONS IN THIS ROOM.
04:20:54   >> AWESOME.
04:20:57   >> AUDIENCE:  REALLY INTERESTING TALK.
04:20:59   THERE IS ANOTHER THING CALLED MIRAGE OS WHICH IS
04:21:04   AN ML MACRO KERNEL, I BELIEVE IT'S CALLED, WHERE
04:21:07   IT'S JUST LIKE ML RUNNING ON A ZION HYPER
04:21:10   ADVISOR.
04:21:11   CAN YOU SEE SOMETHING LIKE THIS DOING THE SAME
04:21:14   THING FOR PYTHON SO YOU COULD RUN A WEB SERVICE
04:21:17   OR SOMETHING?
04:21:17   >> SO, THAT'S A REALLY INTERESTING POINT,
04:21:19   ACTUALLY, SO I AM FAMILIAR WITH MIRAGE OS AND
04:21:22   THERE ARE SEVERAL OTHER KINDS OF JUST ENOUGH OS
04:21:24   OR BARE OS KINDS OF EFFORTS OF, YOU KNOW, IT
04:21:26   WOULD BE DIFFICULT TO DO THAT ON REAL HARDWARE
04:21:28   BECAUSE YOU HAVE TO DRIVE REAL HARDWARE BUT IF
04:21:30   YOU'RE RUNNING IN A VIRTUAL MACHINE, IT'S NOT
04:21:32   THAT HARD TO HAVE A BARE METAL IMPLEMENTATION.
04:21:35   IT TAKES A DECENT AMOUNT OF WORK TO PROVIDE
04:21:37   BINDING BUT FOR PYTHON, WE'RE THERE.
04:21:40   SO IF SOMEBODY WANTED TO EXTEND THIS TO PROVIDE
04:21:43   THAT KIND OF ENVIRONMENT INSIDE A VIRTUAL
04:21:45   MACHINE, IT WOULD ACTUALLY NOT BE THAT HARD TO
04:21:47   DO.
04:21:47   THE NEXT FUN ITEM ON OUR TO-DO LIST, FOR WHAT
04:21:51   IT'S WORTH, IS EFI HAS A TCP/IP PROTOCOL, SO WE
04:21:56   WERE GOING TO PROVIDE BINDINGS TO THAT, MAKE IT
04:22:00   WORK WITH THE PYTHON SOCKET MODULE AND SEE IF WE
04:22:03   CAN'T RUN SIMPLE TCP/IPSERVEER.
04:22:08   SO THEN YOU COULD HAVE A WEB -- TO YOUR FIRMWARE.
04:22:12   SO, YES, BY ALL MEANS, WOULD BE AWESOME.
04:22:15   >> AUDIENCE:  SOUNDS LIKE A LOT OF FUN.
04:22:17   >> NEXT QUESTION.
04:22:19   >> AUDIENCE:  I LOVE THE -- KUDOSFOR THAT.
04:22:24   >> THANK YOU.
04:22:24   >> AUDIENCE:  WHAT'S THE SPEED COMPARISON BETWEEN
04:22:27   RUNNING WHAT YOU JUST DID FOR THIS SET VERSUS
04:22:31   RUNNING PYTHON THROUGH THE NORMALLY NUKES KERNEL?
04:22:36   >> SO, SPEED COMPARISON, IT'S FUNNY, THIS
04:22:39   RENDERED FAIRLY SLOWLY BUT NOT ACTUALLY FOR ANY
04:22:42   REASON HAVING TO DO WITH PYTHON.
04:22:44   THE PYTHON CODE ACTUALLY RUNS AT EFFECTIVELY THE
04:22:47   SAME SPEED AS C-PYTHON DOES ON ANY OTHER PLATFORM
04:22:51   AS LONG AS YOU DON'T TOUCH PLATFORM SERVICES,
04:22:53   THINGS LIKE STAT ARE A LITTLE SLOWER BECAUSE THE
04:22:56   FILE ON THE MY ZAG ISN'T AS OPTIMIZED AS LINUX,
04:23:01   NEVER NEEDED TO BE.
04:23:01   THE REASON THIS IS SLOW IS BECAUSE OF THE LIB FM
04:23:04   LIBRARY, THIS IS SLOW BECAUSE IT USES SOFTWARE
04:23:07   FLOATING POINT.
04:23:08   IF WE WERE TO PROVIDE A VERSION OF LIB M THAT
04:23:11   WOULD PROVIDE FLOATING POINT SUPPORT, THIS WOULD
04:23:13   BE AS FAST AS IT IS UNDER LIE NEXT OR UNDER
04:23:15   WINDOWS.
04:23:16   EVERYTHING ELSE IS REASONABLE SPEED TO WRITE OUT
04:23:19   THE FRAME BUFFER.
04:23:20   IF I WERE TO WRITE OUT, FOR EXAMPLE, PURE BLUE
04:23:23   AND JUST FILL THE WHOLE SCREEN WITH BLUE, ALMOST
04:23:26   INSTANTANEOUS.
04:23:26   SO THAT MUCH IS NOT A BIG DEAL.
04:23:31   THAT'S ALWAYS THE REASON I TYPED THIS OUT BY HAND
04:23:33   RATHER THAN USING THE PYTHON COMPLEX TYPE WHICH
04:23:36   WOULD HAVE MADE THIS BRIEFER AND SIMPLER TO
04:23:39   RECOGNIZE.
04:23:39   THAT MAKES IT SEVERAL TIMES SLOWER BECAUSE,
04:23:41   AGAIN, THE PYTHON COMPLEX LIBRARY DOES A LITTLE
04:23:44   BIT MORE FLOATING POINT MATH THAN IT NEEDS TO,
04:23:47   COMPARED TO THIS OPEN CODED VERSION.
04:23:50   >> AUDIENCE:  THANK YOU.
04:23:51   >> ANY OTHER QUESTIONS?
04:23:59   >>  OKAY.
04:23:59   LOOKS LIKE THAT'S IT.
04:24:00   THANK YOU SO MUCH, JOSH.
04:24:01   >> THANK YOU VERY MUCH.
04:24:19   [ Applause ]
04:24:19


