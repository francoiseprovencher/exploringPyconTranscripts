03:09:59   [ MUSIC PLAYING ]
03:10:02   >> ALL RIGHT.
03:10:09   HELLO, EVERYBODY.
03:10:10   I HAVE QUITE AN HONOR TODAY.
03:10:12   I AM LUCKY ENOUGH TO INTRODUCE BRANDON RHODES, A
03:10:16   LONG-TIME PYTHON DEVELOPER, MAINTAINER OF SEVERAL
03:10:20   AMATEUR ASTRONOMY LIBRARIES AND A DEVELOPER FOR
03:10:23   DROPBOX.
03:10:24   HE'S ALSO A QUIZ MASTER EXTRAORDINAIRE, AS SOME
03:10:27   PEOPLE GOT TO FIND OUT LAST NIGHT.
03:10:29   TODAY HE WILL BE PRESENTING ON OH, COME ON, WHO
03:10:32   NEEDS BYTEARRAYS.
03:10:34   WITHOUT FURTHER ADO, BRANDON RHODES.
03:10:36   [ Applause ]
03:10:44   >> WELCOME, EVERYBODY.
03:10:45   I HOPE YOU'RE HAVING A GOOD TIME AT PYCON AND IN
03:10:47   MONTREAL.
03:10:48   MY TOPIC TODAY IS INDEED BYTEARRAYS.
03:10:51   A VERY INTERESTING REASONED EDITION OF THE PYTHON
03:10:56   ECOSYSTEM.
03:10:57   BECAUSE IN PYTHON, NORMAL STRING OBJECTS, THE
03:11:02   ONES WE'RE ACCUSTOMED TO DEALING WITH ARE
03:11:04   IMMUTABLE, THEY CAN'T BE CHANGED OR MODIFIED.
03:11:08   THIS IS TRUE OF THE TYPES AVAILABLE UNDER BOTH 2
03:11:15   AND 3.
03:11:15   THE ORIGINAL STRING TYPE, STR, WAS IN PYTHON 3
03:11:22   RENAMED TO BYTES BECAUSE OF ITS LOW-LEVEL NATURE
03:11:26   AND THAT SYNONYM WAS ALSO BACK PORTED TO PYTHON
03:11:30   2.
03:11:30   WE WON'T TALK MUCH TODAY ABOUT THE NEWER UNICODE
03:11:35   BYTE STRINGS THAT WERE RENAMED TO THE STR TYPE,
03:11:38   THE OFFICIAL STRING TYPE OF PYTHON 3.
03:11:42   WE'RE GOING TO BE TALKING ABOUT THOSE LOWER-LEVEL
03:11:45   ONES, THE STRINGS THAT DON'T PRETEND THAT THEY
03:11:48   HAVE SYMBOLS INSIDE OF THEM SO MUCH AS THEY KNOW
03:11:51   THAT THEIR INNARDS ARE REALLY BYTES, 8-BIT CODES
03:11:57   0 THROUGH 255.
03:11:58   FOR THE MOST PART I WILL PUT THAT LITTLE B IN
03:12:06   FRONT OF THE BYTE STRINGS THAT I TYPE.
03:12:08   IT IS OPTIONAL UNDER PYTHON 2 BUT IT BECOMES
03:12:11   MANDATORY UNDER PYTHON 3, SO IF I WRITE MY
03:12:19   STRINGS LIKE THIS, IT WILL WORK WHEREVER YOU TRY
03:12:20   THIS LATER IF YOU WANT TO SEE THE EXAMPLES RUN.
03:12:23   STRINGS ARE IMMUTABLE.
03:12:25   WHAT DOES THAT MEAN IT?
03:12:26   MEANS THAT WHEN YOU CALL METHODS, WHEN YOU DO
03:12:28   THINGS TO THEM, THE ORIGINAL OBJECT ITSELF
03:12:31   DOESN'T CHANGE.
03:12:32   YOU GET GIVEN A NEW OBJECT AS THE RETURN VALUE OF
03:12:35   THE METHOD YOU CALL SO IF DOT LOWER RETURNS TO
03:12:39   YOU A NEW STRING, YOU CAN STILL PEEK BACK AND SEE
03:12:42   THAT THE ORIGINAL IS UNTOUCHED AND UNCHANGED.
03:12:44   IF YOU RUN SPLIT, YOU'LL SEE THAT BOTH OF THE
03:12:48   OBJECTS YOU'VE BEEN GIVEN ARE NEW STRING OBJECTS,
03:12:50   THE ORIGINAL IS STILL UNCHANGED.
03:12:52   THEY DO NOT ALLOW ASSIGNMENT BECAUSE THAT WOULD
03:12:57   MAKE THEM CHANGE, IT WOULD MAKE THEM MUTATE IS
03:13:01   THE TECHNICAL TERM IN COMPUTER SCIENCE.
03:13:04   NOW IMMUTABILITY HAS A LONG AND VERY SUCCESSFUL
03:13:07   CAREER IN PYTHON BECAUSE IT MAKES THINGS SIMPLE
03:13:13   YOU DON'T PASS A NAME TO A FUNCTION ONLY TO
03:13:16   SUDDENLY DISCOVER IT'S ANOTHER NAME WHEN IT COMES
03:13:18   BACK.
03:13:18   YOU DON'T PASS A STRING OR A BLOCK TO SOMEONE AND
03:13:21   SUDDENLY IT'S A DIFFERENT STRING OR BLOCK, IT'S A
03:13:23   VERY, VERY SIMPLE MODEL THAT IF YOU HAVE THE WORD
03:13:26   "PYTHON," YOU KNOW IT WILL ALWAYS REMAIN SO.
03:13:29   AND IT ACTUALLY IS ONE OF THE MOST PARTS OF
03:13:32   PYTHON THAT'S THE MOST LIKE FUNCTIONAL
03:13:34   PROGRAMMING LANGUAGES, WHERE NEW RESULTS ARE
03:13:36   RETURNED INSTEAD OF BEING WRITTEN ON TO DATA
03:13:40   STRUCTURES YOU ALREADY HOLD.
03:13:42   THE STRING TYPES ARE A PRIMARY EXAMPLE OF THAT.
03:13:46   BUT IT SOMETIMES IS A LITTLE EXPRESSIVE IN TERMS
03:13:51   OF ALLOCATION.
03:13:52   ANY TIME YOU WANT TO MAKE A LITTLE TWEAK TO A
03:13:54   STRING, IT HAS TO ALLOCATE A NEW ONE FOR YOU.
03:13:57   THAT MEANS A LOT OF DATA GETS COPIED BACK AND
03:14:01   FORTH INTO NEW AREAS OF MEMORY.
03:14:02   NOT EVERYBODY IS HAPPY ABOUT THAT, AND SO PYTHON
03:14:07   3 INTRODUCED AND THEN IT WAS BACK-PORTED TO
03:14:10   PYTHON 2, 6 AND 7, THE NEW BYTEARRAY.
03:14:13   A BUILT-IN, PYTHON 2-7, PYTHON 3, YOU CAN JUST
03:14:17   TYPE "BYTEARRAY" AND YOU'LL GET ACCESS TO THAT
03:14:22   TYPE JUST LIKE WITH STR AND INT AND LIST.
03:14:25   A BYTEARRAY IS IMMUTABLE STRING THAT IS BASED --
03:14:32   THIS IS INTERESTING -- ON PYTHON 3'S BYTE STRING,
03:14:35   NOT THE OLD STR STRING FROM PYTHON 2.
03:14:39   AND THAT'S AN INTERESTING PROBLEM THAT IT'S BASED
03:14:42   ON PYTHON 3 LEAST BYTE STRING TYPE, BECAUSE,
03:14:48   HONESTLY, THE PYTHON 3 BYTES TYPE IS DESIGNED TO
03:14:53   BE AWKWARD FOR STRING OPERATIONS.
03:14:56   WHY?
03:14:56   SO YOU WILL WANT TO BE A GOOD PERSON AND RUN
03:15:02   DECODE BEFORE TREATING YOUR DATA AS CHARACTERS,
03:15:07   AND THIS HAS LED TO PYTHON 3 PROGRAMMERS TENDING
03:15:10   TO WRITE CODE THAT IS FROM THE GROUND UP PREPARED
03:15:14   FOR INTERNATIONALIZATION AND DIFFERENT ALPHABETS
03:15:18   BECAUSE THEY THINK ABOUT THE ISSUE OF DECODING ON
03:15:19   THE WAY IN AND ENCODING ON THE WAY BACK OUT,
03:15:22   BECAUSE THEY HAVE TO.
03:15:23   BUT WE'LL SEE IT LEADS TO SOME INTERESTING
03:15:27   BEHAVIORS, JUST PROFESSIONALLY, ALWAYS BEWARE OF
03:15:30   USING STRING TYPES THAT WISH YOU WEREN'T USING
03:15:33   THEM.
03:15:33   IN PYTHON 2, LET'S COMPARE.
03:15:38   WE CAN BUILD A STRING, WE COULD ASK ITS LENGTH,
03:15:40   WE CAN SPLIT IT INTO PIECES.
03:15:42   PYTHON 3'S BYTES TYPE.
03:15:44   THERE IS A LITTLE B CHARACTERS HANGING OUT IN
03:15:47   FRONT OF OUR BYTE STRINGS BUT WE CAN TAKE THE
03:15:49   LENGTH, WE CAN CALL A METHOD LIKE SPLIT.
03:15:52   IN PYTHON 2, WE CAN USE THOSE SQUARE BRACKETS
03:15:56   WITH A COLON IN ORDER TO DO SLICING AND GET BACK
03:15:58   A COPY OF THE INSIDE OF THE STRING.
03:16:01   EXACT SAME THING WORKS EXACTLY THE SAME WAY IN
03:16:05   PYTHON 3.
03:16:06   IN PYTHON 2-, IT'S ALWAYS A CUSTOM IN PYTHON, IF
03:16:13   SOMETHING HAS A LENGTH, IT SHOULD ALLOW ITSELF TO
03:16:16   BE ITERATED OR LOOPED OVER.
03:16:17   IN PYTHON 3, IF YOU LOOP OVER A CHARACTER STRING,
03:16:21   YOU GET ONE CHARACTER STRINGS THAT ARE INSIDE.
03:16:24   WHAT HAPPENS IF YOU PRINT -- PRESS "ENTER" FOR
03:16:28   THIS LINE OF CODE IN PYTHON 3?
03:16:31   YOU GET A SYNTAX ERROR.
03:16:36   SYNTAX ERROR.
03:16:38   YOU FAILED TO PAY THE PYTHON 3 PAREN TAX.
03:16:42   [ Laughter ]
03:16:46   PYTHON 3 IS KIND OF LIKE AN OLD TEXT-BASED
03:16:49   ADVENTURE GAME WHERE YOU CAN TELL THE WRITER JUST
03:16:53   THREW AN EXTRA OBSTACLE IN YOUR WAY BECAUSE THE
03:16:55   ROOM NEEDED TO BE A LITTLE MORE COMPLICATED.
03:16:57   YOU KNOW, IN -- YOU KNOW, IN THE -- IN SERIOUS...
03:17:06   [ Applause ]
03:17:07   IN SERIOUSNESS, I'VE KNOWN SOME RUBY PROGRAM
03:17:13   YEARS, THIS IS A BIG DEBATE IN THE RUBY
03:17:16   COMMUNITY.
03:17:17   RUBY MAKES PARENTHESES OPTIONAL WHEN CALLING A
03:17:21   FUNCTION.
03:17:21   THE RUBYISTS WHO NEVER USE PARENTHESES ALWAYS
03:17:24   TELL ME THEY COULD NEVER STAND PYTHON AGAIN AND I
03:17:27   THOUGHT THAT WAS THE ODDEST THING.
03:17:29   DOESN'T EVERYONE WANT TO TYPE PARENTHESES
03:17:31   WHENEVER THEY ASK THEIR COMPUTER TO DO SOMETHING?
03:17:33   AND I MUST ADMIT THAT ONCE IT WAS ME WHO WAS
03:17:36   SUDDENLY HAVING TO TYPE PARENTHESIS, BUT THEY
03:17:42   SURELY MUST STILL BE WRONG.
03:17:44   ANYWAY...
03:17:45   I DID A CONSERVATIVE ESTIMATE OF HOW MUCH TYPING
03:17:50   IS COST ME BY THESE PRINT STATEMENTS IN PYTHON 3
03:17:54   AND THIS IS -- THESE ARE CONSERVATIVE ESTIMATES,
03:17:57   AND IT'S COMING OUT TO QUITE A BIT OF TYPING PER
03:18:01   YEAR.
03:18:02   I'M HAVING TO FACE GOING INTO PAREN DEBT JUST TO
03:18:05   WRITE SOME EMARKS LISP NEXT WEEK.
03:18:08   ANYWAY, PYTHON 3 WANTS THEM FOR THIS PRINT
03:18:11   STATEMENT AND WHAT'S ANOTHER 2 PARENS WHEN I'VE
03:18:13   ALREADY TYPED SO MANY?
03:18:14   ONCE YOU GET THE PRINT STATEMENT WORKING, YOU'RE
03:18:21   IN FOR ANOTHER SURPRISE.
03:18:23   PYTHON 3 BYTES TYPE IS NOT MADE OF CHARACTERS, IT
03:18:30   IS MADE OF NUMBERS.
03:18:31   THIS BREAKS A VERY IMPORTANT CONTRACT THAT, FOR
03:18:35   ME, EXISTED WITH STRINGS WHICH IS THAT I CAN PULL
03:18:38   THEM INTO PIECES WITH EITHER INDEXING OR SLICING
03:18:42   AND KNOW THAT THEY WOULD GO BACK TOGETHER AGAIN.
03:18:45   NOW, THERE IS A WAY AROUND BY ASKING FOR ONE
03:18:48   ELEMENT SLICES INSTEAD OF LOOKING UP INTEGER
03:18:51   INDEXES.
03:18:52   BUT, CLEARLY, IT DOESN'T WANT ME TO TREAT IT LIKE
03:18:56   A STRING.
03:18:57   SO BYTES OBJECTS EVEN IF YOU LEARN SOME
03:19:01   WORK-AROUND ARE KIND OF AN AWKWARD FIT FOR MANY
03:19:03   OF THE TASKS THEY'RE CALLED UPON TO DO.
03:19:06   THEY'RE KIND OF THIS HYBRID TYPE BETWEEN A LIST
03:19:08   OF NUMBERS AND A STRING.
03:19:13   THEY ARE KIND OF IN-BETWEEN AND THEY DON'T
03:19:17   NECESSARILY DO EITHER ONE PERFECTLY WELL.
03:19:20   SO WHY DO I BRING ALL OF THAT UP?
03:19:25   WHY DO I REHEARSE THESE WELL-KNOWN ISSUES WITH
03:19:28   PYTHON 3 BYTES WHICH, BY THE WAY, ARE BEING TAKEN
03:19:31   CARE OF.
03:19:31   PYTHON 2-5 WILL REINTRODUCE PERCENT FORMATTING
03:19:37   FOR BYTE STRINGS BECAUSE NOW THAT THE EXPERIMENT
03:19:39   IS IN ITS FIFTH VERSION, I THINK IT IS BEGINNING
03:19:42   TO BECOME CLEAR THAT THE REAL PROBLEM IN PYTHON 2
03:19:45   WASN'T THAT STRINGS WERE CONVENIENT, AND SO WE
03:19:48   IGNORE UNICODE, IT'S THAT CONVERSION COULD HAPPEN
03:19:51   AUTOMATICALLY WITHOUT WARNING.
03:19:53   AND SO THEY ARE BEGINNING TO ADD POWER BACK INTO
03:19:57   PYTHON 3 BYTE STRINGS BUT THEY PROBABLY WILL
03:20:02   ALWAYS BE MADE OF NUMBERS NOW FOR BACKWARDS
03:20:04   COMPATIBILITY AND WE BRING ALL THAT UP BECAUSE
03:20:07   THE BYTEARRAY THAT I WILL NOW TALK ABOUT IS A
03:20:10   MUTABLE VERSION OF PYTHON 3'S BYTE STRING, A
03:20:14   MUTABLE VERSION OF PYTHON'S MOST UNDERPOWERED
03:20:18   STRING TYPE.
03:20:19   SO WE'LL JUST QUICKLY LOOK AT A FEW POSSIBLE
03:20:23   APPLICATIONS AND WHETHER A MUTABLE VECTOR OF
03:20:26   BYTES IS ABLE TO ACCOMPLISH THINGS BETTER OR
03:20:29   WORSE THAN TRADITIONAL PYTHON.
03:20:32   SO, FIRST, LET'S BE FAIR TO IT.
03:20:36   WHAT IF YOU ACTUALLY WANT A LIST OF NUMBERS
03:20:38   BETWEEN ZERO AND 255?
03:20:40   THAT NEVER HAPPENS TO ME.
03:20:44   [ Laughter ]
03:20:45   SO I INVENTED -- IN THOSE RARE CASES WHERE YOU
03:20:49   ACTUALLY WANT TO STORE BYTES, IF YOU HAD ONE, IS
03:20:51   THE BYTEARRAY A GOOD CHOICE.
03:20:52   SO I INVENTED ONE.
03:20:53   I WROTE MY FIRST BLOOM FILTER AS PREPARATION FOR
03:20:57   THIS TALK, A BLOOM FILTER IS A WAY TO -- LET'S
03:21:02   SAY YOU HAVE A DICTIONARY OF WORDS AND BEFORE YOU
03:21:04   GO LOOK ON DISK FOR WHETHER WORD IS IN YOUR
03:21:07   DICTIONARY, YOU WANT A QUICK WAY TO KNOCK OUT A
03:21:11   LOT OF WORDS, IT'S JUST NOT BEING CANDIDATES.
03:21:14   WHAT YOU CAN DO IS SET UP A BIG BIT FIELD AND
03:21:17   HAVE A COUPLE OF HASH FUNCTIONS THAT YOU THROW
03:21:20   THE WORLD "ELEPHANT" AT THEM AND THEY IDENTIFY
03:21:24   SOME BITS FOR YOU THAT BELONG TO "ELEPHANT."
03:21:26   YOU GIVE THEM THE WORD "PYTHON," A DIFFERENT SET
03:21:29   OF BITS.
03:21:30   THE IDEA IS THAT IF YOU LOAD UP YOUR DICTIONARY
03:21:33   BY SETTING ALL OF THE BITS FOR ELEPHANT AND ALL
03:21:35   THE BITS FOR PYTHON, THEN WHEN YOU SEE THOSE
03:21:38   WORDS LATER IN A DOCUMENT, YOU CAN JUST CHECK
03:21:41   WHETHER THEY'RE BITS ARE SET TO KNOW IF THERE'S
03:21:43   ANY POSSIBILITY THAT "ELEPHANT" IS IN YOUR
03:21:47   DICTIONARY BECAUSE MANY WORDS WILL HAVE SETS OF
03:21:50   BITS THAT AREN'T SET AT ALL AND SO -- OR SEVERAL
03:21:53   OF WHICH AREN'T SET AND THAT YOU KNOW COULD NOT
03:21:55   HAVE BEEN IN THE DICTIONARY YOU LOADED.
03:21:57   THIS IS A NICE EXAMPLE BECAUSE IT LETS US DO A
03:22:00   PURE MATH OPERATION, IN THIS CASE, THE IN-PLACE
03:22:06   OREING OF A BYTE IN THIS ARRAY A WITH ITSELF, AND
03:22:13   WITH A BIT THAT WE CREATE OVER HERE IN SET.
03:22:17   AND WE CAN RUN THROUGH, SET THIS UP, AND THEN WE
03:22:20   WANT TO TEST A WORTH, GO BACK IN AND USE THE
03:22:24   READING VERSION OF SQUARE BRACKETS, NOT IN AN
03:22:27   ASSIGNMENT STATEMENT BUT IN AN EXPRESSION, TO
03:22:29   READ BACK THE VALUE OF A BIT.
03:22:31   A NICE EXERCISE TO SEE HOW DOES THIS THING
03:22:35   PERFORM, STORING AND RECEIVING A FEW TENS OF
03:22:39   THOUSANDS OF BYTES.
03:22:40   BY THE WAY, THE NAME A IN THE PREVIOUS CODE CAN
03:22:43   BE EITHER AN OLD-FASHIONED ARRAY.ARRAY THAT'S
03:22:47   BEEN AROUND IN PYTHON FOREVER, OR A NEW-FANGLED
03:22:51   BYTEARRAY.
03:22:52   TO THIS EXTENT, THEY BOTH PROVIDE THE SAME
03:22:54   INTERFACE, EACH SLOT YOU CAN ADDRESS GETS YOU OR
03:22:58   LET'S YOU STORE A BYTE.
03:23:00   AND SO WITH THIS APPLICATION, I RAN IT BOTH WAYS
03:23:04   AND BYTEARRAY SCORED ITS FIRST VICTORY, BECAUSE
03:23:07   IT IS SO MORE SPECIFIC THAN ARRAY.ARRAY WHICH I
03:23:12   BELIEVE CAN ALSO HOLD FLOATS AND INTEGERS AND
03:23:14   THINGS LIKE THAT, BECAUSE THE BYTEARRAYS CODE
03:23:18   PATH HAS ALMOST NO DECISIONS, IT IS ALMOST ALWAYS
03:23:21   GOING TO STORE BYTES, IT IS ALMOST 7% FASTER FOR
03:23:25   RUNNING THAT BLOOM ARRAY CODE THAT I JUST SHOWED
03:23:28   YOU THAN THE ORIGINAL PURPOSE ARRAY.ARRAY
03:23:31   PURPOSE.
03:23:32   SO YOU MIGHT THINK THIS IS IMMEDIATELY AND
03:23:33   OBVIOUSLY A GO-TO DATA STRUCTURE FOR LISTS OF
03:23:38   8-BIT NUMBERS.
03:23:39   I TRIED IT ANOTHER WAY.
03:23:40   I WANT WANT TO KNOW WHAT'S EVEN FASTER THAN
03:23:45   ANOTHER BYTE AWAY?
03:23:46   A LIST OF INTEGERS.
03:23:47   1% FASTER.
03:23:52   IF YOU JUST SAY, HEY, PYTHON, HERE'S A
03:23:55   ONE-ELEMENT LIST WITH A 0 IN IT, MAKE ME A LOT OF
03:23:59   THESE.
03:24:00   A PLAY -- SORRY, 2%, A PLAIN LIST OF INT OBJECTS
03:24:04   THAT HAPPEN TO BE IN THE RANGE 0 TO 255, IT WILL
03:24:07   RUN EVEN FASTER THAN THE BYTEARRAY.
03:24:10   WHY?
03:24:11   WELL, IT'S BECAUSE, THINK OF WHAT THE BYTEARRAY
03:24:13   IS DOING.
03:24:14   IT'S STORING REAL BYTES.
03:24:16   LOW-LEVEL IN YOUR COMPUTER, THAT MUST EACH BE
03:24:19   TRANSLATED INTO AN INT OBJECT ADDRESS WHEN THE
03:24:25   VALUE IS BEING HANDED OUT INTO YOUR PYTHON CODE,
03:24:28   AND THEN WHEN AN INT VALUE -- EXCUSE ME, YEAH,
03:24:32   WHEN AN INT OBJECT IS HANDED BACK, IT HAS TO BE
03:24:35   CHANGED BACK INTO A SIMPLE BYTE IN ORDER TO BE
03:24:38   STORED.
03:24:40   THE LIST SKIPS ALL THAT.
03:24:41   IT JUST STORES THE ADDRESSES YOU GIVE IT.
03:24:44   THE -- NOW, THE BYTEARRAY, BY THE WAY, DOESN'T
03:24:49   HAVE TO PAY ANY PENALTY TO ALLOCATE OR CREATE ANY
03:24:52   OF THOSE INT OBJECTS BECAUSE IT JUST SO HAPPENS
03:24:55   THAT THE PYTHON -- THE CPYTHON INTERPRETER, WHEN
03:24:58   IT STARTS UP PREALLOCATES ALL THE INTEGER OBJECTS
03:25:03   NEGATIVE 5-256 SO THEY NEVER HAVE TO BE CREATED
03:25:07   OR DESTROYED OVER THE LIFETIME OF THE
03:25:09   INTERPRETER.
03:25:09   SO WHEN YOU ASK THE BYTEARRAY WHAT'S AT POSITION
03:25:12   100 AND IT WANTS TO SAY 70, IT CAN GRAB THE
03:25:16   EXISTING 70 INTEGER OBJECT THAT ALWAYS EXISTS IN
03:25:18   MEMORY AND HAND IT BACK SO IT'S NOT HAVING TO GO
03:25:21   DO A MALLACK OR ANYTHING, IT'S NOT HAVING TO GOOD
03:25:26   MEMORY BUT IT STILL HAS TO DO THE STEP OF
03:25:28   TRANSLATION AND IT'S HONESTLY EASIER TO STORE THE
03:25:32   ADDRESS OF THE 70 OBJECT.
03:25:33   THAT'S WHY THE LIST OBJECT RUNS FASTER, AND SO
03:25:36   THIS IS INTERESTING.
03:25:37   WE HAVE THIS NEW SPECIAL CASE CONTAINER THAT'S
03:25:42   SLIGHTLY SLOWER THAN JUST USING PYTHON'S
03:25:45   WELL-HONED DEFAULT DATA TYPES.
03:25:47   A PLAIN OLD LIST IS A FASTER BIT VECTOR THAN THE
03:25:50   FANCY NEW BYTEARRAY.
03:25:52   EXCEPT IF YOU'RE USING PYPY, WHERE THEY'RE ALL
03:25:55   THE SAME BECAUSE IT BECOMES THE SAME C-CODES
03:25:59   UNDER THE HOOD -- MACHINE CODE, I SHOULD SAY, AND
03:26:02   ALL THREE RUN MUCH FASTER AS WELL AS BEING
03:26:04   EXACTLY EQUIVALENT.
03:26:05   I TRIED IT OUT IN PYPY, IN EACH CASE FIGURED OUT
03:26:09   I WAS TRYING TO DO EXACTLY THE SAME THING.
03:26:12   I GUESS THEY'RE DONE ALREADY.
03:26:13   I'LL JUST KEEP GOING.
03:26:14   SO FOR THIS FIRST EXPERIMENT, WHAT IF I NEED A
03:26:18   LIST OF INTEGERS BETWEEN 0 AND 255?
03:26:21   MY VERDICT IS THAT THE BIT VECTOR IS SPACE
03:26:26   EFFICIENT.
03:26:27   YOU DON'T CHOOSE IT BECAUSE IT'S GOING TO BE
03:26:29   OBVIOUSLY FASTER, IT'S NOT, OR OBVIOUSLY SIMPLER,
03:26:33   IT'S DOING A LITTLE MORE UNDER THE HOOD.
03:26:35   BUT THE GOOD, OLD-FASHIONED LIST OF INTEGERS HAS
03:26:39   TO STORE IN EACH SLOT THE ADDRESS OF THE REAL
03:26:44   INTEGER OBJECT 70.
03:26:45   THE BIT VECTOR JUST STORES THE 7 BITS -- 8 BITS
03:26:51   THAT REPRESENT 70 AND, THEREFORE, USES ON A
03:26:54   64-BIT MACHINE, WHICH IS WHAT I'LL PRESUME FOR
03:26:56   ALL OF THESE CALCULATIONS, EIGHT TIMES LESS
03:27:00   SPACE.
03:27:00   AND THE POINT AFTER A BLOOM FILTER IS TO SAVE
03:27:04   SAYS IN RAM.
03:27:05   THAT FOR BIT OPERATIONS IS WHY YOU GO TO THE
03:27:09   BYTEARRAY BECAUSE IT SCORES BYTES AS HONEST TO
03:27:12   GOODNESS BYTES WITH NO EXTRA OVERHEAD PER BYTE.
03:27:16   IT'S A GREAT WAY TO GET NUMBERS BETWEEN 0 AND
03:27:19   255, PACKED IN THE MINIMUM SPACE POSSIBLE.
03:27:23   SO IT IS A WIN BUT NOT IN THE WAY YOU MIGHT
03:27:28   INITIALLY EXPECT.
03:27:29   ALL RIGHT.
03:27:31   SECOND, IT IS A RE-USABLE BUFFER, WHEN YOU READ A
03:27:35   STRING THIS, YOU CAN'T DO ANYTHING TO IT BECAUSE
03:27:37   IT'S IMMUTABLE BUT A BYTEARRAY CAN BE REUSED.
03:27:41   FOR A QUICK BENCHMARK, I GOT -- MADE A RANDOM
03:27:43   FILE OF A GIGABYTE OF RANDOM DATA, READ IT WITH
03:27:47   CAT SO I WAS ABLE TO ESTIMATE THAT PROBABLY
03:27:50   PYTHON WON'T BE ABLE TO DO BETTER THAN .11
03:27:54   SECONDS ON MY MACHINE, READ CRINGE IN THE SAME
03:27:56   DATE AT THAT TIME I TRIED IT WITH TCP.
03:27:58   ANYONE HERE EVER USE TCP TO REWRITE DATA?
03:28:03   IT TOOK SIX TIMES LONGER.
03:28:04   ANYONE KNOW WHY?
03:28:06   I STRACED THEM AND IT'S BECAUSE OF THE BLOCK
03:28:11   SIZE.
03:28:11   DD, ALAS, IS AN OLD AND CRAFTY AND LOW-LEVEL
03:28:15   TOOL, WHILE CAT WILL ZOOM ALONG WITH 128K BLOCKS,
03:28:20   SO IT ASKS THE OS FOR SOME DATA AND GETS 128,000
03:28:24   BYTES IN A SINGLE SHOT.
03:28:27   DD, BECAUSE IT'S AN OLD-LEVEL FOR WRITING TO
03:28:30   ANCIENT 70s BLOCK DEVICES READS AND WRITES
03:28:34   5R.512 BYTES BY DEFAULT, GIVING DD THE SAME BLOCK
03:28:39   SIZE DOES MAKE IT PERFORM THE SAME, YOU CAN GIVE
03:28:42   IT A BLOCK SIZE OF 128K AND GETS .11 SECONDS
03:28:47   RIGHT THERE WITH CAT BUT IT'S NOT THE DEFAULT
03:28:51   DESPITE I SAME TO KNOW ALL THESE PEOPLE THAT
03:28:55   THINK DD WOULD BE FASTER BY DEFAULT.
03:28:57   IT'S NOT.
03:28:58   IT'S THE SAME READS AND WRITES.
03:29:00   AND CAT IS THE SAME -- DD CAME FROM IBM.
03:29:05   BUT THIS TEACHES US A FIRST LESSON THAT WE WILL
03:29:08   NOW APPLY AS WE LOOK AT PYTHON I.O., WE NEED TO
03:29:11   KEEP BLOCK SIZE IN MEANT, THE SIZE OF THE CHUNKS
03:29:14   YOU READ DETERMINES HOW MANY CHUNKS YOU NEED TO
03:29:16   READ, DETERMINES HOW OFTEN YOU NEED TO CONVERSE
03:29:18   WITH THE OPERATING SYSTEM.
03:29:19   WHICH IS OFTEN THE EXPENSE THAT CAN COME TO
03:29:22   DOMINATE YOUR RUN TIME.
03:29:23   HERE'S HOW WE DO IT IN NORMAL PYTHON.
03:29:28   READ A BLOCK AND WRITE THE DATA BACK OUT.
03:29:31   NOTE, THIS IS PERFECTLY SAFE IF AN UNDERSIZED
03:29:33   BLOCK COMES IN BECAUSE THE STRING THAT I'M HERE
03:29:37   CALLING DATA THAT COMES BACK IS LABELED WITH ITS
03:29:39   LENGTH.
03:29:40   IT COULD BE 5 BYTES, IT COULD BE 128K, IT --
03:29:45   PYTHON STRINGS KNOW THEIR LENGTH AND SO WRITE CAN
03:29:49   JUST ASK THE LENGTH AND SEND THAT MANY BYTES OF
03:29:52   DATA BACK OUT.
03:29:52   MY FIRST ATTEMPT AT DOING A READ INTO SEEMED TO
03:29:56   WORK, AT FIRST, UNTIL I NOTICED THAT EVERY FILE I
03:30:00   WROTE, HOWEVER BIG IT WAS ORIGINALLY, THE COPY
03:30:06   THAT I MADE WITH THIS ROUTINE WOULD ALWAYS BE A
03:30:09   MULTIPLE OF MY BLOCK SIZE.
03:30:11   WHY IS THAT?
03:30:12   BECAUSE WHEN I CREATE ONE OF THESE NEW BYTEARRAYS
03:30:15   OF, LET'S SAY, 128K, WHAT THIS LOOP WAS DOING IS
03:30:20   READING SOME NUMBER OF BYTES, WHO KNOWS HOW MANY
03:30:23   COME IN IN THE NEXT BLOCK OF THE FILE IF I'M NEAR
03:30:26   THE END, READS SOME NUMBER OF BYTES INTO ANY
03:30:30   BYTEARRAY, AND THEN WRITES OUT THE WHOLE
03:30:34   BYTEARRAY, INCLUDING ALL THE JUNK AT THE END
03:30:36   THAT'S MAYBE NOT PART OF THE CURRENT BLOCK OF THE
03:30:39   FILE.
03:30:40   I WAS DOING MY WRITE OF THE WHOLE 128K BLOCK
03:30:45   WITHOUT CONSULTING THE LENGTH TO SEE IF I SHOULD
03:30:48   HAVE BEEN WRITING THE ENTIRE 128K BLOCK.
03:30:51   ONE FIX IS TO SIMPLY USE SLICING.
03:30:57   IS TO GET THAT BYTEARRAY CALLED DATA AND TAKE
03:31:03   FROM IT TO WRITE EACH TIME THE SLICE THAT IS
03:31:07   LENGTH LONG.
03:31:08   SO IF I GET A FULL-SIZED BLOCK, I'M WRITING OUT
03:31:12   ALL OF THE DATA, BUT IF I GET ONLY HALF A BLOCK
03:31:15   AT THE END OF THE FILE, I ONLY WRITE THAT --
03:31:18   WELL, LAST HALF BLOCK OUT FROM THE INITIAL PART
03:31:21   OF MY BYTEARRAY.
03:31:23   WHAT IF WE DIDN'T WANT THE EXPENSE, THOUGH, OF
03:31:26   HAVING TO DO THAT, BACK ONE SLIDE, EXPENSIVE
03:31:29   SLICING OPERATION, BECAUSE ASKING A PYTHON STRING
03:31:34   UNICODE STRING OR BYTEARRAY FOR A SLICE CREATES A
03:31:37   WHOLE NEW ONE, AND COPIES AS MUCH DATA INTO THE
03:31:41   NEW ONE AS YOU ASK FOR WITH THE LIMITS YOU SET IN
03:31:44   THE SLICE.
03:31:46   IF WE WANT TO ACHIEVE ZERO COPY, THE PEOPLE WHO
03:31:49   ADDED BYTEARRAY TO THE LANGUAGE, THEY THOUGHT OF
03:31:52   THAT, AS WELL.
03:31:53   THEY ADDED A SECOND FEATURE THAT WORKS WITH
03:31:56   BYTEARRAY CALLED A MEMORY VIEW.
03:31:59   A MEMORY VIEW IS A SLICEABLE OBJECT.
03:32:04   HERE I TAKE THE SLICE 3:6 OF THAT BYTEARRAY, IT'S
03:32:15   A SLICE WITH NO MEMORY OF ITS OWN BUT IS LETTING
03:32:18   YOU REACH INTO THE MEMORY IT WAS SLICED FROM TO
03:32:20   MAKE THE CHANGE.
03:32:21   ESSENTIALLY THIS MEMORY VIEW, THE "V" THAT I
03:32:26   CREATE HERE, IS JUST A -- ESSENTIALLY, IT'S LIKE
03:32:30   A STRING OBJECT BUT THE ADDRESSES IT WANTS TO
03:32:33   WRITE TO IN MEMORY ARE THE ADDRESSES RIGHT THERE
03:32:35   IN THE MIDDLE OF THE BYTEARRAY, SO WHEN I TRY TO
03:32:38   SET ITS INDEX 0 VALUE, IT REALLY GOES TO INDEX 3
03:32:46   IN THE REAL BYTEARRAY.
03:32:48   WHEN I SET ITEM 1, IT REALLY GOES TO SLOT 4.
03:32:51   WHEN I SET ITEM 2, IT GOES TO SLOT 5.
03:32:55   IT REALLY IS JUST CREATING AN OBJECT THAT ACTS
03:32:58   LIKE IT'S A ALSO BYTEARRAY BUT IS, IN FACT, JUST
03:33:03   AN OFFSET.
03:33:05   IT'S ADDING SOMETHING TO EACH INDEX YOU USE AS
03:33:08   YOU READ AND WRITE FROM IT.
03:33:10   AND THIS IS WHAT CAN HELP US IN THE SITUATION
03:33:14   WE'RE IN.
03:33:15   HERE IS A 0 COPY VERSION OF MY FIXED CODE TO TRY
03:33:20   TO READ IN LOTS OF BLOCKS.
03:33:22   BEFORE, I WAS ASKING DATA, THE BYTEARRAY ITSELF
03:33:26   TO DO THE SLICING AND, LIKE ALL PYTHON STRINGS,
03:33:29   IT GIVES ME A WHOLE NEW ONE WHEN I ASK FOR A
03:33:32   SLICE.
03:33:33   NOW I'M LOOKING AT IT THROUGH A MEMORY VIEW SO IF
03:33:36   I ASK, LET'S SAY, FOR VIEW OF -- YOU KNOW, IF
03:33:40   LENGTH IS 128K, I'M ASKING FOR ALL THE DATA, IT
03:33:44   JUST GIVES ME A LITTLE MEMORY VIEW OBJECT WHOSE
03:33:46   ADDRESSES ARE POINTING AT THE WHOLE BLOCK OF
03:33:49   DATA, A VERY CHEAP OPERATION, AND SO MEMORY VIEWS
03:33:52   ARE OFTEN NECESSARY TO GET THINK KIND OF
03:33:54   PERFORMANCE OUT OF THE BYTEARRAY WHEN DOING IO,
03:33:58   ESPECIALLY WHEN YOU CAN'T PREDICT HOW BIG THE
03:34:00   NEXT DELIVERY OF INFORMATION WILL BE.
03:34:02   HERE ARE THE RUNTIMES OF DD AND CAT THAT WE
03:34:07   DISCUSSED EARLIER.
03:34:09   COMPARED TO JUST PLAIN OLD READ, WITH NORMAL
03:34:13   PYTHON STRINGS, READ INTO, MY FIRST VERSION THAT
03:34:18   WAS BROKEN BECAUSE IT WASN'T CAREFUL ABOUT HOW
03:34:20   MUCH IT WROTE, DOES RUN SLIGHTLY FASTER THAN THE
03:34:24   TRADITIONAL PYTHON WAY OF DOING THINGS, BUT WHEN
03:34:27   YOU THEN PIVOT TO USING A SLICE BYTEARRAY AND
03:34:33   SLICING IT, BECAUSE YOU'RE COPYING EVERY PIECE OF
03:34:36   DATA INTO MEMORY TWICE, IT'S MUCH MORE EXPENSIVE.
03:34:38   IT IS THE MEMORY VIEW, IT IS THAT ZERO EXPENSE,
03:34:44   VERY LITTLE EXPENSE, CONSTANT TIME EXPENSE, I
03:34:47   SHOULD SAY, ABILITY TO SLICE WITHOUT COPING DATA,
03:34:51   THAT LETS US CREATE A CORRECT VERSION OF A FILE
03:34:54   COPY WITHOUT -- WHILE STILL SLIGHTLY BEATING READ
03:35:01   AND WRITE.
03:35:02   AND TRADITIONAL STRINGS.
03:35:04   SO THAT WAS A LOT OF WORK, AND WE GOT A 4%
03:35:08   SPEED-UP WITH BYTEARRAY.
03:35:10   NOW, SMALL BLOCKS, THINGS GET WORSE FOR
03:35:13   BYTEARRAY.
03:35:15   BECAUSE WHAT WILL SLICING HERE SO OFTEN DO, IT
03:35:20   CREATES A NEW OBJECT EVERY TIME AND CREATING ONE
03:35:21   OF THESE LITTLE VIEW OBJECTS WITH ITS HE POINTERS
03:35:25   IN THE PART OF THE BYTEARRAY I WANT TO LOOK AT
03:35:28   WAS FINE WHEN I WAS ONLY DOING IT EVERY FEW
03:35:31   HUNDRED K OF DATA BUT WHAT IF I WANT THE DEFAULTS
03:35:34   OF DD AND I'M GOING TO BE RUNING 1200 BYTES AT A
03:35:38   TIME, WHAT IF I HAVE TO SPIN UP A NEW MEMORY VIEW
03:35:41   FOR EVERY HALF K OF DATA?
03:35:43   THEN THINGS START TO LOOK VERY BAD AND, IN FACT,
03:35:47   THE MEMORY VIEW USED CORRECTLY, WHERE YOU'RE
03:35:49   CAREFUL OF YOUR LINKS, IS SIMPLY A LOSS.
03:35:52   IT'S MUCH -- READING, WHERE IT JUST RETURNS A
03:35:56   PYTHON STRING IS REALLY EFFICIENT.
03:36:01   A WRITE OF A PYTHON STRING IS REALLY EFFICIENT.
03:36:03   YOU CAN EASILY GET INTO SITUATIONS WITH THE FANCY
03:36:07   ATTEMPTS ONE MAKES WITH A BYTEARRAY TO CREATE
03:36:10   MORE EXPENSIVE IO THAN YOU HAD WHEN YOU JUST USED
03:36:13   TRADITIONAL IMMUTABLE STRINGS THAT, YES, REQUIRED
03:36:17   PYTHON TO BUILD A NEW STRING FOR EVERY CALL TO
03:36:21   READ BUT CUT OUT ALL OF THE REST OF THAT EXPENSE.
03:36:24   I WAS SAD FOR THE BYTEARRAY.
03:36:28   AT THIS POINT IN MY TALK.
03:36:30   SO I STARED AT THE EXAMPLE.
03:36:32   20% SLOWDOWN FOR A SMALL BLOCK SIZE.
03:36:39   BUT THEN, I THOUGHT OF SOMETHING.
03:36:44   WHAT IF WE DON'T ALWAYS SLICE, BECAUSE WHEN
03:36:48   READING FROM A FILE, DIFFERENT FROM A NETWORK,
03:36:50   WHEN READING FROM A FILE, THE NORMAL CASE IS THAT
03:36:53   UNLESS YOU'RE AT THE VERY END OF THE FILE, YOU'RE
03:36:54   GOING TO GET AS MUCH AS YOU ASK FOR.
03:36:57   ASK FOR 128K, YOU'RE GOING TO GET IT.
03:37:00   THE NORMAL CASE IS THAT THE LENGTH EQUALS THE
03:37:02   BLOCK SIZE AND IN THAT CASE, THERE'S NOT ONLY NO
03:37:06   REASON TO ASK THE BYTEARRAY TO TAKE A SLICE OF
03:37:09   ITSELF AND COPY ALL THAT DATA, THERE'S NO REASON
03:37:11   TO USE THE VIEW TO LIMIT THE AMOUNT OF DATA
03:37:15   YOU'RE USING FROM THE BLOCK.
03:37:16   YOU'RE GOING TO USE ALL OF IT AND SO IF YOU
03:37:18   HANDLE THAT SPECIAL CASE, YOU DON'T INCUR AN
03:37:22   OBJECT CREATION STEP IN ORDER TO GET THAT WRITE
03:37:29   CALL STARTED, AND YOU SLIGHTLY BEAT THE
03:37:31   PERFORMANCE OF THE TRADITIONAL READ-WRITE LOOP BY
03:37:37   4%.
03:37:37   JUST LIKE...
03:37:42   JUST LIKE FOR THE BIG BLOCK CASE, SO EVEN IF YOUR
03:37:49   IO IS IN A SITUATION WHERE THE BLOCK SIZE WILL BE
03:37:52   VARYING OR MIGHT BE SMALL, YOU CAN, IF YOU'RE
03:37:56   CAREFUL AND CUT AND PASTE FROM MY TALK SLIDES,
03:37:59   YOU CAN RUN SLIGHTLY FASTER THAN THE TRADITIONAL
03:38:03   READ AND WRITE WITH IMMUTABLE DRINKS.
03:38:06   PYTHON 2.7, BY THE WAY, HAS THE SAME RELATIVE
03:38:10   BEHAVIORS BETWEEN THOSE DIFFERENT CHOICES ON MY
03:38:13   MACHINE, SLIGHTLY SLOWER.
03:38:14   AND I THINK THE LESSON HERE IS THAT IT IS JUST
03:38:17   HARD TO BEAT OLD-FASHIONED STRINGS WHEN YOU'RE
03:38:19   PULLING IN DATA AND THEN JUST IMMEDIATELY SENDING
03:38:22   IT BACK TO THE OPERATING SYSTEM OVER SOME OTHER
03:38:27   CHANNEL.
03:38:28   IT'S REALLY SOMETHING HOW THE GOOD-OLD-FASHION
03:38:32   IMMUTABLE STRING THAT MAKES FUNCTIONAL
03:38:34   PROGRAMMERS' HEARTS SING IS PRETTY MUCH AS GOOD
03:38:38   IN THIS CASE AS OUR WEIRD SIDE EFFECTY IDEA OF
03:38:42   CONSTANTLY MODIFYING THIS SINGLE BYTES ARRAY THAT
03:38:46   WE HAVE CREATED.
03:38:48   SO, MY VERDICT IS THAT IT IS DANGEROUS, BECAUSE
03:38:50   IT'S SO EASY TO WRITE WHAT LOOKS LIKE PRETTY
03:38:53   CODE, IT LOOKS LIKE ALMOST THE SAME LITTLE
03:38:56   READ-WRITE LOOP BUT GOING TO OPERATE
03:38:59   SUBSTANTIALLY WORSE IN SITUATIONS THAT YOU MIGHT
03:39:01   NOT THINK TO TEST FOR UNLESS YOU THINK OF THE
03:39:03   SMALL BLOCKS INDICATION.
03:39:05   THE ONE ADVANTAGE IT DOES OFFER IS A GREAT MEMORY
03:39:07   PROFILE BECAUSE THERE IS A LINK LATER TO A GREAT
03:39:13   BLOG POST ONLINE ABOUT SOMEONE WRITING AN AUDIO
03:39:15   SERVER THAT NEEDED TO KEEP LOTS OF STRINGS IN A
03:39:18   BUFFER AND HIS MEMORY USAGE WAS GOING THROUGH THE
03:39:20   ROOF BECAUSE IF YOU'RE CONSTANTLY ALLOCATING AND
03:39:23   DE-ALLOCATING DIFFERENTLY SIZED STRINGS BECAUSE
03:39:25   EVERY CALL TO READ NEEDS TO MAKE A NEW STRING TO
03:39:28   HANDS IT BACK TO YOU, THEN YOU CAN GET A LOT OF
03:39:30   MEMORY FRAGMENTATION.
03:39:31   IF INSTEAD YOU HAVE ONE BYTEARRAY AND YOU USE IT
03:39:34   OVER AND OVER AND OVER AND OVER, THERE'S NOTHING
03:39:38   HAPPENING TO GET FRAGMENTED.
03:39:40   SO DON'T DO THE BYTEARRAY.
03:39:42   I WOULDN'T DO THE BYTEARRAY FOR THE 4% SPEED-UP.
03:39:45   I WOULD DO IT BECAUSE I WANTED TO CONTROL MY
03:39:48   MEMORY PROFILE BUT ONLY IF I KNEW THAT WAS A
03:39:50   PROBLEM IN MY APPLICATION DOMAIN.
03:39:52   NOW WICK GO ON TO ANOTHER AND MORE INTERESTING
03:39:57   SITUATION, USING THE BYTEARRAY AS THE
03:39:59   ACCUMULATOR.
03:40:00   FUN QUESTION FOR PEOPLE DOING NEW NETWORK
03:40:04   PROGRAMMING.
03:40:04   HOW MANY BYTES WILL RECEIVE 1024 RETURN?
03:40:07   THE ANSWER IS...
03:40:11   ONE.
03:40:11   OR MORE, IF THE NETWORK STACK IS IN THE MOOD, BUT
03:40:16   YOU'RE ONLY GUARANTEED ONE, AND THIS IS THE
03:40:19   OPPOSITE OF FILE IO.
03:40:21   FILE IO, YOU ASK FOR 128K, IF THERE'S 128K LEFT
03:40:26   IN THE FILE, IT WILL WAIT FOR THE DISK TO SPIN,
03:40:29   WAIT FOR THE HEAD TO BE IN THE RIGHT PLACE.
03:40:31   IT WILL LEAVE YOU PAUSED UNTIL A FULL 128K IS
03:40:34   READY FOR DELIVERY AND THEN WAKE YOU BACK UP.
03:40:36   THE NETWORK IS THE OPPOSITE.
03:40:38   RECEIVE WILL BLOCK ONLY UNTIL AT LEAST A SINGLE
03:40:41   BYTE IS AVAILABLE AND THEN SET YOU OFF RUNNING TO
03:40:45   PROCESS IT.
03:40:45   AND THAT CAN HAPPEN IF YOUR BUFFER SIZE HAPPENS
03:40:50   TO BE JUST A LITTLE LESS THAN THE SIZE OF THE
03:40:52   LAST FEW PACKETS THAT ARRIVED.
03:40:54   YOU CAN HAVE A CALL TO RECEIVE THAT FIND ONLY ONE
03:40:57   OR TWO BYTES LEFT.
03:40:59   MEANING, UNLIKE IN THE CASE WHERE WE WERE
03:41:02   CHOOSING OUR READ SIZE FOR FILES, USUALLY IT'S
03:41:06   THE NETWORK, IT'S THE CLIENTS, YOU'RE
03:41:08   COMMUNICATING WITH THAT KIND OF DECIDE HOW BIG
03:41:11   YOUR CHUNKS OF IO ARE WHEN YOU'RE TALKING ON THE
03:41:14   NETWORK, SO YOU'RE ALWAYS POTENTIALLY IN THE CASE
03:41:16   WHERE YOU'RE DEALING WITH LITTLE PIECES OF DATA.
03:41:19   THIS FACT, BY THE WAY, THAT YOU ALWAYS ARE GIVEN
03:41:22   AN ANSWER WHEN EACH JUST A FEW BYTES CAN BE SENT
03:41:26   OR RECEIVED IS WHY NEW NETWORK PROGRAMMERS TEND
03:41:29   TO GET INTO THE, "BUT IT WORKED WHEN I RAN
03:41:32   AGAINST LOCAL HOST PROBLEM."
03:41:34   THEY GET INTO THAT SITUATION BECAUSE WHEN YOU RUN
03:41:36   YOUR SERVER THAT YOU'VE JUST WRITTEN IN YOUR
03:41:39   LITTLE CLIENT YOU'VE JUST WRITTEN ON LOCAL HOST,
03:41:41   THE OS WILL SEND ENORMOUS BLOCKS OF DATA BACK AND
03:41:45   FORTH BETWEEN THE TWO PROCESSES.
03:41:47   THEN, THEY'LL TAKE IT TO THEIR TEAM AND SAY, LOOK
03:41:50   WHAT I WROTE, TRY IT BETWEEN TWO DIFFERENT
03:41:52   MACHINES.
03:41:52   AND IT WILL HANG AND NEVER GET ALL THE DATA
03:41:54   BECAUSE THEY DIDN'T LEARN ON LOCAL HOST THAT YOU
03:41:59   RECEIVE WILL OFTEN JUST GIVE YOU A FEW THOUSAND
03:42:01   BYTES AND YOU NEED TO KEEP AT IT AND WATCH UNTIL
03:42:04   EVERYTHING YOU NEED HAS ARRIVED.
03:42:05   SO WHAT IS IT LIKE TO USE A TRADITIONAL RECEIVE
03:42:10   SOLUTION GETTING A NEW STRING EACH TIME, HOLDING
03:42:14   THE NEW DATA THAT'S COME IN?
03:42:16   THIS IS WHAT IT LOOKS LIKE, AND, AGAIN, HERE,
03:42:21   WE'RE GETTING LOTS OF MAYBE LITTLE PIECES OF DATA
03:42:23   WHICH I'M SIMULATING BY ONLY ASKING FOR A SINGLE
03:42:27   ETHER NET PACKAGE LENGTH SO EACH WHEN I RUN THIS
03:42:31   ON LOCAL HOST, IT WILL PRETEND LIKE PACKETS ARE
03:42:35   COME IN.
03:42:36   AND THE -- THIS IS WHAT MANY PYTHON PROGRAMMERS
03:42:39   START WITH, THEY JUST CREATES AN EMPTY STRING AND
03:42:42   THEY PLUS-EQUAL MORE DATA TO IT EACH TIME.
03:42:46   IN PYTHON TUTORIALS, YOU DOUBTLESS -- MANY OF YOU
03:42:50   WILL HAVE SEEN THIS, THE CREATING OF THE STRING
03:42:52   AND DATA PLUS EQUALS MORE AS AN ANTI-PATTERN THAT
03:42:55   YOU AVOID BECAUSE I TRIED RUNNING THIS.
03:42:57   HOW LONG DOES IT IS PLUS-EQUALS APPROACH TAKE?
03:43:00   INFINITY TIME, MEANING THAT I FINALLY NEEDED MY
03:43:03   LAPTOP BACK SO I KILLED IT AND I'LL NEVER NOW HOW
03:43:06   LONG THE LOOP WOULD HAVE TAKEN TO READ MY BIG
03:43:08   ABYTE OF DATA BUT WHEN YOU DO PLUS-EQUALS, YOU'RE
03:43:10   ASKING PYTHON TO CLEATS A LITTLE STRING AND THEN
03:43:13   YOUR FIRST PLUS-EQUALS MAKES A SLIGHTLY LONGER
03:43:16   ONE.
03:43:17   YOUR NICKS PLUS-EQUALS THROUGH THE LOOP CREATES A
03:43:20   SLIGHTLY LONGER ONE INTO WHICH ALL THE DATA FROM
03:43:23   THE SECOND STRING HAS TO BE COPIED TO MAKE THE
03:43:26   THIRD ONE AND NOW YOU HAVE TO GO THROUGH THE LOOP
03:43:28   AGAIN AND COPY ALL THAT DATA AGAIN TO MAKE YOUR
03:43:30   FOURTH STRING AND IF YOU HAVE A MILLION BYTES TO
03:43:32   READ, YOU WIND UP DOING HALF A TRILLION
03:43:35   OPERATIONS.
03:43:36   IT'S CALLED AN ORDER IN SQUARED ALGORITHM,
03:43:39   GENERALLY TO BE AVOIDED IF YOU WANT IT TO FINISH
03:43:41   BY LUNCHTIME.
03:43:43   SO THIS IS WHAT WE TELL EVERYONE TO DO.
03:43:45   PIVOT TO KEEPING A LIST OF BLOCKS THAT YOU'VE
03:43:48   RECEIVED AND JOIN THEM TOGETHER AT THE END IN A
03:43:51   SINGLE STEP, PYTHON'S MUCH BETTER AT THAT.
03:43:55   THIS ACTUALLY FINISHED ON MY LAPTOP, IT IS
03:43:57   TRADITIONAL WAY OF ACCUMULATING DATA FROM THE
03:44:00   INTERNET ON PYTHON OR FROM A NETWORK, TOOK ABOUT
03:44:02   A LITTLE MORE THAN A SECOND TO READ IN A GIG OF
03:44:06   DATA IN THOSE SMALL 1.5K CHUNKS.
03:44:09   NOW, THERE IS A VERSION, LIKE READ INTO, BUT THAT
03:44:15   RECEIVES INTO A BYTEARRAY YOU'VE ALREADY BUILT
03:44:18   INSTEAD OF BUILDING A NEW STRING, BUT IT NOW RUNS
03:44:21   INTO A PROBLEM.
03:44:22   WHEN WE DO READ INTO, OR RECEIVE INTO, WHERE DOES
03:44:26   IT PUT THE DATA?
03:44:27   AT THE BEGINNING OF THE ARRAY AND ALL OF OUR
03:44:30   INCOMING BLOCKS WILL OVERWRITE EACH OTHER.
03:44:32   WHOA WE WANT AS MORE AND MORE BLOCKS COME IN FROM
03:44:35   THE NETWORK, IS TO ARRAIGNING THEM ALONG OUR
03:44:38   BYTEARRAY.
03:44:39   SO THAT MEMORY VIEW SLICING EXPENSE THAT I ADDED
03:44:41   AN "IF" STATEMENT TO AVOID WHENEVER POSSIBLE IN
03:44:44   THE PREVIOUS CODE?
03:44:45   IT NOW BECOMES MANDATORY.
03:44:47   AGAIN, THIS ABILITY WITH A VIEW TO WRITE INTO
03:44:52   BYTE LOCATIONS THAT AREN'T AT THE BEGINNING BUT
03:44:54   ARE SOMEWHERE IN THE MIDDLE OF THE BYTEARRAY
03:44:56   YOU'VE BUILT.
03:44:57   THE FIRST BLOCK CAN GO AT THE BEGINNING BUT YOU
03:44:59   NEED TO BUILD A MEMORY VIEW TO TARGET THE SECOND
03:45:02   BLOCK AFTER THE FIRST BLOCK.
03:45:04   THE THIRD BLOCK AFTER THAT, AND SO FORTH.
03:45:07   AND SO YOU NEED TO BUILD A MEMORY VIEW AND YOU'RE
03:45:12   GOING TO NEED TO USE IT TO TARGET THAT RECEIVE V
03:45:16   INTO AT SUBSEQUENT POSITIONS INSIDE OF YOUR BIG
03:45:21   BYTEARRAY, PRESUME THAT YOU KNOW THE CONTENT
03:45:24   LENGTH AHEAD OF TIME AND IF PREALLOCATED IT AND
03:45:28   YOU'RE WAITING TO FILL IT WITH DATA.
03:45:30   THIS TAKES ABOUT EIGHT-TENTHS OF A SECOND BECAUSE
03:45:33   WE -- A BIT OF A WIN HERE BECAUSE YOU HAVEN'T HAD
03:45:36   TO BUILD A LIST, YOU HAVEN'T HAD TO CALL JOIN,
03:45:38   YOU HAVEN'T BUILT A BUNCH OF INTERMEDIATE CALL
03:45:42   STRUCTURES, IT ACTUALLY IS A SIGNIFICANT WIN WHEN
03:45:44   YOU NEED TO KEEP THE DATA THAT YOU'RE READING
03:45:46   RATHER THAN JUST IMMEDIATELY PASSING IT BACK TO
03:45:48   THE OS.
03:45:49   ANOTHER POSSIBILITY I SAW ON SOMEONE'S BLOG IS TO
03:45:54   DO AN OLD-FASHIONED RECEIVE OF A NEW STRING AND
03:45:56   THEN TRY TO DO A BYTEARRAY EXTEND TO GROW YOUR
03:46:00   BYTEARRAY WITH THESE NEW STRINGS.
03:46:01   IT COPIES THE DATA TWICE BUT DOES GET RID OF THAT
03:46:07   JOIN CONCATENATION.
03:46:09   IT LOOKS SOMETHING LIKE THIS, DATA.EXTEND NEAR
03:46:13   THE BOTTOM.
03:46:14   IT IS NOT A WIN OVER THE NORMAL WAY OF USING
03:46:17   BYTEARRAYS, BECAUSE IT TURNS OUTS BYTEARRAY
03:46:20   EXTEND IS PRETTY INEFFICIENT.
03:46:22   IT ASKS FOR AN ITERATOR OVER ITS ARGUMENT AND
03:46:26   THEN CALLS -- THE ITERATOR'S NEXT FUNCTION OVER
03:46:30   AND OVER FOR EVERY BYTE AND THEN ASKS THE INT
03:46:33   OBJECT WHAT ITS VALUE IS, SO THAT IT CAN THEN PUT
03:46:37   IT IN AN INTERMEDIATE ARRAY, AND THAT INVOLVES
03:46:40   HAVING TO INCREMENT AND DECRIMENT THE NUMBER IT'S
03:46:46   IN AND BY THE TIME YOU'RE DONE, YOU'VE COMPUTED
03:46:49   AT LEAST 40 BYTES OF BAND WIDTH OF RAM EVEN
03:46:54   IGNORING THE ARGUMENTS AND STACKS THAT YOU'RE
03:46:56   PASSING IN ORDER TO GET THAT SINGLE BYTE VALUE
03:46:58   EXTENDED ON TO THE END OF YOUR BYTEARRAY.
03:47:01   PLUS, IT DOESN'T WRITE TO YOU BYTEARRAY.
03:47:05   IT WRITES TO AN INTERMEDIATE BUFFER THAT GROWS
03:47:08   DYNAMICALLY AND THEN DOES THE APPEND WHEN IT'S
03:47:10   DONE SO THAT SHOULD THAT ITERATION DIE PARTWAY
03:47:13   THROUGH, YOU DON'T WIND UP HAVING MODIFIED THE
03:47:15   BYTEARRAY SOME.
03:47:16   IT WANTS TO EITHER SUCCEED OR FAIL AS AN
03:47:19   AUTONOMIC OPERATION.
03:47:21   SO THAT'S WHY IT'S KIND OF SLOW, KIND OF KLUGY,
03:47:27   BUT SEEING THAT BLOGS POST MADE ME ASK A
03:47:29   QUESTION.
03:47:29   DOES THE BYTEARRAY HAVE AN APPEND OPERATION
03:47:31   THAT'S ANY GOOD?
03:47:33   I MEAN, SURELY THE PEOPLE WRITING IT KNEW THAT
03:47:35   WE'D WANT TO DO THAT BUT SPINNING UP AN ITERATOR
03:47:38   AND CALLING IT 1500 TIMES?
03:47:40   DOES IT HAVE AN OPERATION THAT'S REALLY GOOD?
03:47:42   AND, YES, IT DOES.
03:47:45   I READ THE C-CODE TO FIND IT.
03:47:47   NOW, THINK ABOUT IT.
03:47:48   WHERE WOULD YOU PUT THE REAL EXTEND OPERATOR, THE
03:47:53   REAL ABILITY TO MAKE YOUR BYTEARRAY LONGER?
03:47:56   OBVIOUSLY, YOU WOULD HIDE IT BEHIND THE OPERATOR
03:48:01   THAT WE'VE SPENT 20 YEARS TELLING PEOPLE NEVER TO
03:48:04   USE WITH STRING VALUES.
03:48:05   [ Laughter ]
03:48:06   [ Applause ]
03:48:07   THIS MIGHT BE SO DIFFICULT THAT SOME OF YOU WILL
03:48:13   NEVER DO IT BUT IF YOU CAN CONVINCE YOURSELF TO
03:48:16   TYPE THIS AFTER ALL OF THIS TIME, THIS IS
03:48:19   ACTUALLY SOMETHING THAT BYTEARRAYS DO
03:48:21   MAGNIFICENTLY, JUST PLUS-EQUAL THE ADDITIONAL
03:48:25   DATA TO YOUR BYTEARRAY AND YOU WILL BEAT EVEN
03:48:29   RECEIVE INTO'S ABILITY TO GROW YOUR ARRAY WITH
03:48:34   DATA.
03:48:34   SO THIS CASE WHERE WE NEED TO ACCUMULATE AND KEEP
03:48:37   THE WHOLE PAY ROAD IS A REAL WIN FOR THE
03:48:41   BYTEARRAY IN ALL THE APPROACHES AND THERE DON'T
03:48:44   SEEM TO BE SHARP EDGES THAT CAN SUDDENLY MAKE IT
03:48:46   BEHAVE MUCH WORSE THAN THE LISTEN JOIN.
03:48:51   30% SPEED-UP IN THAT LAST VERSION OF THE
03:48:54   ALGORITHM AND CLEANER CODE.
03:48:56   ADMIT IT, YOU'VE ALWAYS WANTED TO JUST JUST --
03:49:00   JUST PLUS-EQUAL, HAVEN'T YOU?
03:49:02   IT'S THE NATURAL WAY TO WRITE IT IN PYTHON AND
03:49:04   THIS IS ONE OF THOSE NEAT INTERSECTIONS WITH WHAT
03:49:10   LOOKS GOOD AND READS ON THE PAGE, AS WELL.
03:49:12   SO I'M NOT GOING TO TALK ABOUT SEND.
03:49:14   YOU MIGHT THINK ABOUT THE FACT THAT I'LL GET INTO
03:49:17   SEND DOESN'T ALWAYS SEND THE WHOLE PAY LOAD BUT
03:49:19   PYTHON HAS LONG HAD YOU COVERED HERE.
03:49:21   PYTHON SOCKETS HAVE FOR A VERY LONG TIME HAD A
03:49:24   SEND ALL THAT SITS IN A LOOP IN C, SENDING
03:49:26   SHORTER AND SHORTER TAILS OF YOUR DATA UNTIL
03:49:31   FINALLY THE OS BUFFERS HAVE BEEN ABLE TO RECEIVE
03:49:33   IT ALL.
03:49:34   SO I DON'T SEE THAT WE NEED BYTEARRAYS FOR THAT.
03:49:36   AND I CAN DECLARE THE BYTEARRAY THE WINNER.
03:49:40   IF YOU NEED AN ACCUMULATOR, IF YOU NEED TO VERY
03:49:44   QUICKLY N A PERFORMANCE-SENSITIVE ENVIRONMENT,
03:49:46   ACCUMULATE A LOT OF INCOMING DATA, IT IS A
03:49:49   NOTICEABLY GOOD WIN WITH TWO DIFFERENT TECHNIQUES
03:49:52   THAT WORK PRETTY WELL.
03:49:53   I'LL BRIEFLY MENTION THAT SOME PEOPLE WANT A
03:49:56   FREESTYLE MUTABLE STRING.
03:49:58   WHEN THEY SEE THE BYTEARRAY, THEY DON'T THINK OF
03:50:01   IO, THEY DON'T THINK OF BLOOM FILTERS AND BIT
03:50:04   VEHICLESTORS, THEY WANT TO MESS WITH A STRING.
03:50:06   THEY WANT A STRING THAT THEY CAN JUST CHANGE.
03:50:10   AND ALL -- I HAVE NOT FOUND YET A GOOD USE FOR
03:50:14   THIS.
03:50:15   AND I'LL SORT OF SHOW YOU WHY IT WINDS UP BEING
03:50:18   AWKWARD.
03:50:18   YOU WANT TO CHANGE PART OF THE PAY LOAD BEFORE
03:50:21   USING, STORING OR RE-TRANSMITTING.
03:50:24   THAT WOULD BE THE USE CASE HERE BECAUSE IF YOU
03:50:25   WANT TO LOWERCASE THE WHOLE THING, YOU HAVE TO
03:50:28   TOUCH ALL THE BYTES ANYWAY SO YOU MIGHT AS WELL
03:50:30   BUILD A NEW ONE.
03:50:31   GOOD THINGS, THE BYTEARRAY IS IMMUTABLE, GET IT
03:50:34   AND CHANGE IT BUT NONE OF THE METHODS THAT IT
03:50:36   SHARES WITH STRINGS DO MUTATION TO IT.
03:50:41   IF YOU CALLED UPPER ON YOUR BYTEARRAY, YOU GET A
03:50:44   NEW BYTEARRAY.
03:50:45   SO YOU HAVE A MUTABLE STRING TYPE THAT DOES
03:50:48   NOTHING STRING-LIKE MUTABLY.
03:50:50   A BYTEARRAY ONLY CHANGES WHEN SUBJECTED TO
03:50:54   LIST-LIKE OPERATIONS, LIKE ASSIGNMENT TO AN INDEX
03:50:58   OR ASSIGNMENT TO A SLICE OR .CLEAR, AND SO THE
03:51:02   RESULT, IF YOU TRY WRITING A NETWORK ALGORITHM OR
03:51:05   SOMETHING WITH THIS IS CURIOUS.
03:51:06   YOU HAVE A MUTABLE STRING, BUT, ALAS, THAT DOES
03:51:12   NO MUTATION PRECISELY WHEN YOU START CALLING ITS
03:51:14   STRING METHODS.
03:51:15   WANTS TO LOWERCASE A WORD ENOUGH TO MAKE A COPY
03:51:18   TO CALL LOWER ON, YOU'RE GOING TO HAVE TO DO
03:51:22   SLICING GIVING YOU A COPY, CALL LOWER, MAKING
03:51:25   ANOTHER COPY AND THEN ASSIGNMENT TO COPY IT A
03:51:27   THIRD TIME BACK INTO THE DATA STRUCTURE IN ORDER
03:51:30   TO GET THAT ACCOMPLISHED.
03:51:32   THERE ISN'T, I LOOKED, THERE ISN'T A LOWER INTO
03:51:35   AND AN UPPER INTO THAT WOULD LET YOU DO
03:51:38   SMALLER-GRAINED MANIPULATION THAT IS WROTE
03:51:42   DIRECTLY TO YOUR NEW BYTEARRAY.
03:51:44   CAN THE MEMORY VIEW SAVE US, THOUGH?
03:51:46   IT DID IN ALL THE PREVIOUS OCCASIONS.
03:51:48   NO.
03:51:49   BECAUSE MEMORY VIEWS DON'T DO ANYTHING
03:51:54   STRING-LIKE.
03:51:55   THE MOMENT YOU MOVE TO A MEMORY VIEW WHICH LETS
03:51:57   YOU LOOK AT A PIECE OF STRING EFFICIENTLY, YOU'RE
03:52:02   NOT GOING TO BE ABLE TO DO ANYTHING STRING-LIKE
03:52:04   TO IT.
03:52:04   SO YOU HAVE TO DO A ROUND-TRIP OUT TO A SMALLER
03:52:08   STRING TO DO A MANIPULATION AND STORE DATA BACK.
03:52:13   TO MUTATE A BYTEARRAY WITHOUT REWRITING ITS WHOLE
03:52:17   CONTENT, YOU'RE GOING NEED INDICES.
03:52:20   DO YOU REMEMBER INDEX EBBS?
03:52:23   BACK THE FIRST WEEK BEFORE YOU FOUND STRIP, SPLIT
03:52:26   AND JOIN, AND WERE DOING EVERYTHING LIKE THIS,
03:52:28   YOU GET TO DO IT AGAIN IF YOU DECIDE TO TRY
03:52:31   MUTATING A BYTEARRAY.
03:52:32   THE BYTEARRAY WILL LET YOU ENJOY THOSE DAYS ALL
03:52:35   OVER AGAIN BECAUSE ALL THE MUTATION OPERATIONS
03:52:37   ARE POWERED ONLY BY INDICES.
03:52:39   ONE HINT, REGULAR EXPRESSIONS, WHILE THEY TURNED
03:52:43   OFF A LOT OF OTHER STRING-LIKE THINGS WERE LEFT
03:52:46   TURNED ON AND DO WORK AGAINST BYTEARRAYS AND CAN
03:52:49   HELP GIVE YOU SOME USEFUL INDICES TO USE.
03:52:52   FREESTYLE MUTABLE STRING, IT'S AWKWARD.
03:52:56   I HAVE HERE AT THE END OF THE SLIDES SOME LINKS
03:53:02   TO OTHER DOCUMENTATION, INCLUDING THE BLOG POSTS
03:53:04   THAT INSPIRED THIS TALK AND MAYBE WANT TO BRING
03:53:06   EVERYTHING TOGETHER IN ONE PLACE AND IN
03:53:09   CONCLUSION, THE BYTEARRAY, IT IS A VERY
03:53:11   MEMORY-EFFICIENT, NOT FASTER BUT MEMORY-EFFICIENT
03:53:15   STORE OF BYTE INTEGERS, SHOULD YOU EVER NEED
03:53:18   THEM.
03:53:19   IT CAN HELP CONTROL MEMORY IMPLEMENTATION WHEN
03:53:23   DOING HIGH-PERFORMANCE IO BECAUSE YOU DON'T HAVE
03:53:26   TO CREATE A NEW STRING BUT IT'S HARD TO MAKE IT
03:53:28   FASTER IN A RELIABLE WAY.
03:53:30   BE CAREFUL.
03:53:31   IT'S A GREAT WAY TO ACCUMULATE DATA THAT'S COMING
03:53:35   IN A PIECE AT A TIME.
03:53:37   THAT'S ITS REAL SUPER POWER, AND EVEN THOUGH IT'S
03:53:40   TEMPTING FOR STRING OPERATIONS, IT'S A BIT
03:53:43   UNDERPOWERED AND A BIT AWKWARD.
03:53:44   THAT'S WHAT I'VE LEARNED SO FAR.
03:53:47   THANK YOU VERY MUCH.
03:53:48   [ Applause ]
03:54:02   >> WE ARE OUT OF TIME, SO I WILL MEET BYTEARRAY
03:54:07   INTERESTED FANS OUTSIDE THE DOOR IN A FEW
03:54:09   MINUTES.
03:54:10













