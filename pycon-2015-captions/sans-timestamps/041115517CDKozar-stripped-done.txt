ALL RIGHT.
SO I'M GOING TO BE INTRODUCING YOU TO WHO IS GOING
TO BE GIVING YOU A TALK ON PACKING AND DEPLOYMENT.
SO LET'S GIVE A WARM WELCOME.
[APPLAUSE]
>> ALL RIGHT.
SO HI, EVERYONE.
I HOPE YOU'RE ENJOYING PYTHON.
I'M DOMEN KOZAR.
I DO THIS THING FOR ALMOST TEN YEARS.
I COME FROM 2 MILLION PEOPLE COUNTRY IN EUROPE.
AND I JUST STARTED, YOU KNOW, WORKING ON PACKAGING
BACK, IT WAS PART OF GOOGLE SUMMER OF CODE.
I WAS PART OF G MINUS PIP PROJECT.
IF ANYONE KNOWS TO ULTIMATE PROJECT OF PYTHON
PACKAGES.
ANYHOW, I'M GOING TO TALK ABOUT WAY OF LEARNING
THAT FIVE YEARS, AND HOW FAR WE HAVE COME.
SO JUST, THERE ARE LIKE THREE AREAS IN PYTHON
PACKAGING THAT ARE KIND OF INTERESTING TO ME TO
FOLLOW.
AND ONE IS --
AND THE INFRASTRUCTURE, MOSTLY THE PIPING.
AND YOU KNOW PYTHON PACKAGING IS HARD.
DONE AN AWESOME JOB KEEPING THAT IN PROGRESS, AND
IMPROVING THAT.
AND THERE IS A PACKAGING AT PYTHON.ORG.
WHO KNOWS ABOUT PYTHONPACKAGING.ORG?
IT'S IMPLEMENTATION FOR PACKAGING THESE DAYS, AND
BEST PRACTICES.
HOW TO APPROACH THAT.
EVEN IF YOU'RE DOING THIS EVERY DAY, YOU SHOULD GO
OVER THERE AND CHECKOUT WHAT'S NEW AND HOW YOU
SHOULD BE DOING IT.
A LITTLE BIT INTERESTING PART IS THAT PYTHON IS, AS
FAR AS I KNOW, THE ONLY LANGUAGE THAT HAS -- YOU
HAVE TO RUN A SCRIPT THAT ACTUALLY KNOWS SOMETHING
ABOUT THE PACKAGING.
AND THIS IS REALLY, REALLY A BIG PROBLEM.
AND THERE IS ACTUALLY A PIP THAT'S IN A DRAFT MODE
THAT'S TRYING TO ADDRESS THAT.
BUT THERE ARE A LOT OF THINGS TRYING TO DO BEFORE
ADDRESS THAT AND IMPLEMENTING AND START USING AND
MIGRATE TO THE STATIC META DATA.
THIS IS THE THIRD AREA, WHICH IS THE MOST
INTERESTING TO ME, WE'RE IN 2015.
AND WE DON'T JUST USE PYTHON ANYMORE.
WE USE AT LEAST, IF YOU'RE DOING WEB JAVA SCRIPT --
THIS IS LIKE UNKNOWN AREA.
HOW DO WE PACKAGE THOSE THINGS TOGETHER?
AND JUST, YOU KNOW, TO GIVE YOU FOOD FOR THOUGHT,
WHAT'S -- WHAT'S BIG PROBLEM THAT WE HAVE WITH
PACKAGING THESE DAYS?
IF YOU THINK ABOUT ANY BUILD SYSTEM, EVEN PYTHON'S,
AS A FUNCTION, YOU KNOW, WE HAVE TWO INPUTS.
ONE IS THE META DATA AND INSTRUCTION TO PACKAGE,
BUT THE OTHER ONE IS OUR FALL SYSTEM.
BUILD SYSTEM GOES INTO THE FILE SYSTEM.
THAT CIRCLES AROUND TO EVERY PACKAGE.
THAT'S KIND OF STAGE THAT WE MODIFY.
PACKAGES ARE INSTALLED IN THE USER, BUT, YOU KNOW,
IT'S GOING TO BE/USER OR/USER LOCAL.
NOT USING ONE PACKAGE LOCAL, AND TO HAVE NO ONE HAS
ANY IDEA WHAT'S THE ACTUAL STATE THERE, RIGHT?
IT'S JUST, YOU TAKE THAT WHOLE BLOB AND YOU TEST IT
AND YOU HOPE IT WORKS.
SO I'M GOING TO TALK ABOUT THE NEXT PACKAGE
MANAGER, AND HOW IT TRIES TO APPROACH, AND SO THAT
-- AND SOLVE THAT PROBLEM.
THIS IS THE RUN TIME GRAPH OF PYTHON.
A FEW INTERESTING POINTS HERE.
YOU SEE THAT -- WELL, IT'S -- WELL, SO PYTHON IS AT
THE BOTTOM, AND YOU SEE IT DEPENDS ON OPEN SSL, IF
YOU WANTED TO SSL.
AND OPEN SSL ACTUALLY TIME DEPENDS ON PERL IF THERE
ARE A FEW SCRIPT.
ACTUALLY HAVE PERL AS RUN TIME.
OPEN SSL DOES HAVE PERL.
AND, YOU KNOW, THIS IS -- THIS IS THE GRAPH THAT WE
HAVE IN NIX IF I INSTALL THE -- THE WHICH IT LOOKS
IN NIX IS THIS.
EVERY PACKAGE IS PREFIXED WITH THE LONG HASH AND
NAME AND VERSION.
THIS IS THE WHOLE RUN TIME.
SO ACTUALLY, THAT -- THE -- I -- INSTEAD OF HAVING
SLASH USER, WE HAVE A LONG PATH.
AND INSIDE, THERE YOU WOULD SEE EVERYTHING YOU
WOULD NORMALLY FIND.
SO YOU KNOW, IT WILL EVEN INCLUDE --
[NO AUDIO]
ABSOLUTE PATH.
[NO AUDIO]
THE SPECIFIC LIBRARIES AND AS LONG AS YOU DON'T
REMOVE THEM, THIS PYTHON WILL WORK.
EVEN IF YOU FIDDLE WITH YOUR SYSTEM IN ANY WAY.
SO, ALL RIGHT.
SO NOW WE HAVE PACKAGES.
HOW DO WE MAKE AN ACTUAL ENVIRONMENT?
HOW DO WE GET A WORKING, YOU KNOW FILE SYSTEM
STRUCTURE?
AND USER ENVIRONMENT AND STRUCTURE COMES INTO MIX.
AND YOU KNOW THE PACKAGE POINT TO EACH OTHER,
DYNAMIC THINKER AND OTHER WAYS.
AND WE HAVE THIS IDEA CALLED USER ENVIRONMENT,
WHICH IS ACTUALLY SOMETHING WHERE YOU INSTALL
PACKAGES INSIDE.
[NO AUDIO]
IF YOU INSTALL PYTHON, FOR EXAMPLE.
AND BECAUSE WE HAVE ALL THIS, BECAUSE WE HAVE THIS
NICE FRAMEWORK, WE CAN ACTUALLY CREATE PROFILES AND
THOSE PROFILES ARE BASICALLY A LIFE CYCLE OF YOUR
PACKAGE MANAGER.
SO EVERY OPERATION YOU DO INSTALL A PACKAGE, REMOVE
IT, UPGRADE IT, WE WILL CREATE A SIMILAR --
THAT MAKES FOR EVERY OPERATION, THAT MAKES SURE
THAT WE CAN ROLLBACK TO ANY PREVIOUS VERSION IN
YOUR HISTORY OF, YOU KNOW, OF OPERATIONS ON THE
PACKAGE MANAGER.
AND THOSE PROFILES CAN BE -- BY DEFAULT, INSTALLED
FOR EVERY USER, AND THERE IS A SYSTEM PROFILE, BUT
YOU CAN MAKE THOSE PROFILES, YOU KNOW, FOR A
PROJECT OR SOMETHING LIKE THAT.
SO IN EVERY PROFILE HAS ITS OWN CYCLE, WHAT'S
INSTALLED AND HOW IT UPGRADES.
WHEN DO YOU UPGRADE THOSE PACKAGES?
SO NIXOS IS A PACKAGE MANAGER, AND A LANGUAGE.
IT'S ESSENTIALLY A BUNCH OF FUNCTIONS AND DATA
TYPES.
THE ONLY -- IT'S VERY SIMILAR TO PYTHON, BIG
DIFFERENCE IS -- EVALUATED, AND GIVES IT MOST POWER
FOR CONFIGURATION MANAGEMENT.
THOSE PACKAGES ARE OUTPUT, WHEN WE BUILD PACKAGE,
ARE IMMUTABLE.
WHEN YOU MODIFY, A NEW FOLDER WILL BE CREATED WITH
THAT HASH.
I WILL EXPLAIN LATER WHAT THAT MEANT.
THAT ALLOWS US, WE CAN ROLLBACK AND WE CAN, YOU
KNOW, DELETE SOFTWARE OR MODIFY.
JUST CREATE NEW VERSIONS AND SEND LINK INSIDE OUR
ENVIRONMENT.
SO SOURCE IS FOR HAVING ALL THE FREEDOM TO MODIFY
YOUR SYSTEM AND BINARY IS FOR THOSE WHO HAVE TIME
CONSTRAINTS, WHICH WE ALL DO.
AND THE NICE THING IS, IT'S CROSS-PLATFORM.
IT SUPPORTS BOTH.
SO WE HAVE HUGE -- IN THE COMMUNITY, X USERS GROUP,
AND THERE'S ACTUALLY NOW, JUST ONE COMPANY CALLED
ROAD CODER USING, AND YOU KNOW, IT WORKS.
SO HOW DOES THIS SPEC LOOK LIKE.
THERE'S ONE FUNCTION, YOU PASS A BUNCH OF VALUES TO
IT, AND THERE ISN'T ONE OF THE VALUE -- ONE OF THE
ARGUMENTS IS BUILDER, THAT'S THE SCRIPT IT WILL
EXECUTE, AND THAT SCRIPT WILL BE EXECUTED IN
ISOLATED ENVIRONMENT.
IT'S GOING TO BE IN THE CHANGE ROOT ENVIRONMENT,
WITHOUT ANY NETWORKING, AND A BUNCH OF OTHER THINGS
TO MAKE SURE THAT THIS BUILD WILL NOT INTERFERE
WITH YOUR SYSTEM AND PICK ANYTHING UP.
AND THE BUILDER IS, IN OUR CASE, IT'S ALL THE TIME
BASH, BUT IT COULD BE PRETTY MUCH ANYTHING THAT CAN
BE SUITED AND PAST ARGUMENTS.
AND THAT BUILDER WILL GET ALL THE ARGUMENTS THAT
ARE IN THE DURATION.
AND THEN YOU CAN WRITE YOUR SCRIPT TO BUILD
SOFTWARE.
AND ACTUALLY, THE HASH THAT YOU SAW BEFORE, THAT IS
THE HASH OF ALL THE INPUTS TO THE -- FUNCTION.
AND THAT WAY WE CAN ACTUALLY BE SURE THAT WE HASH
ALL THE META DATA WE HAVE FOR THE PACKAGE.
INCLUDING THE DEPENDENCY DATA.
THAT THAT HASH UNIQUELY IDENTIFIES THE PACKAGE
ACCORDING TO THE SOURCE.
SO BECAUSE IT'S, YOU KNOW, YOU DON'T WANT TO REPEAT
ALL THOSE ARGUMENTS ALL THE TIME, WE HAVE THIS
THING CALLED STANDARD ENVIRONMENT WHICH IS
DIFFERENT FOR EVERY PLATFORM.
IN LINUX YOU WILL GET TRLS AND SO ON.
THIS IS FOR EXAMPLE, HOW YOU WOULD PACKAGE.
ENGINE X.
A BUNCH OF SIMPLE KEY VALUES AND YOU KNOW, BUILD
INPUTS IS THE MOST INTERESTING PART.
BUILDS ON DEPENDENCIES.
AND THE WAY THAT WE FIND RUN TIME DEPENDENCIES IS A
BIT TRICKY.
IT SOUNDS REALLY, YOU KNOW, MAGIC, BUT IT WORKS.
AND WE ACTUALLY SCAN ALL THE PACKAGES FOR THOSE
HASHES.
AND IF -- IF THE PACKAGE -- IF THAT SCAN SUCCEEDS,
THAT IS THE RUN TIME DEPENDENCY.
AND IF IT'S NOT IN THE PACKAGE, WE'LL SKIP IT AND
IT'S NOT GOING TO BE PART OF THAT.
SO, ALL RIGHT.
SO PYTHON.
WE HAVE A FUNCTION CALLED BUILD PYTHON PACKAGE,
WHICH IS LIKE A 200-LINE SCRIPT.
THAT TAKES -- THAT'S BASICALLY, INSTEAD OF USING A
BUILD SYSTEM IT WILL USE PYTHON SET UP TOOLS,
THAT'S WHAT YOU WANT TO DO.
IF YOU WANT TO PACKAGE, FILO, USE LIBRARIES THAT
PILLAR USES AND THAT'S YOUR PYTHON PACKAGE.
AT THE TOP THERE IS ONE FUNCTION THAT ACCEPTS ALL
THE DEPENDENCIES, AND ALL THE FUNCTIONS THAT PEOPLE
USE.
AND AT THE BOTTOM, THIS IS THE DURATION FUNCTION,
UNDERNEATH THAT WILL ACTUALLY BUILD AND CREATE.
SO IF YOU TO WANT BUILD PYTHON, FOR EXAMPLE, YOU
SAY, NEXT BUILD PYTHON, YOU GET A PYTHON BACK, AND
IT WILL CREATE THIS SIMILAR LINK IN YOUR CURRENT
DIRECTORY RESULT -- CALLED RESULT FOR CONVENIENCE.
IF YOU RUN RESULT IN PYTHON, YOU GET A PYTHON
INTERPRETER.
YOU SEE THE TIME STAMP IS LIKE UNIX PLUS ONE
SECOND.
WE'RE TRYING TO ACHIEVE THE BINARY ALSO AND ONE
THING WE HAVE TO DO IS FIX TIME.
AND YOU KNOW EXACTLY WHAT IS THE RUN TIME,
DEPENDENCY GRAPH OF PYTHON, WE HAVE A NAME FOR
THAT, IT'S CALLED CLOSURE.
AND THE RESULT -- TMUX COPY -- TMUX COPY CLOSURE
DEMAND.
SO IT'S LIKE A VERY DUMMY WAY TO DEPLOY NIX
SOFTWARE.
AND IF YOU LOOK AT THIS, AND YOU GIVE IT TO OPS
PEOPLE, IT'S LIKE JAVA.
IT'S LIKE I HAVE THIS JAR, WHICH I COPY AND I PASS
LIKE A THOUSAND PARAMETERS, AND, YOU KNOW, IT
WORKS.
AND THEY'RE HAPPY BECAUSE IT'S SIMPLE.
SO ALL RIGHT.
SO NOW WE KNOW HOW TO BUILD...
SO ONE REALLY NICE WAY IS TO THINK ABOUT THIS, IS
INSTEAD OF ACTUALLY BUILDING, FOR EXAMPLE, PYTHON,
IF YOU WANT TO DEVELOP IT, WHAT WE REALLY WANT TO
DO IS ENTER THIS BUILD ENVIRONMENT ON THE RIGHT
THAT YOU SEE.
AND THIS HAS ALL THE TAR BALLS AND EVERYTHING
NEEDED TO BUILD PYTHON.
SO IF WE ENTER THIS ENVIRONMENT, IT WILL HAVE
EVERYTHING WE NEED TO BUILD PYTHON AND WE CAN
ACTUALLY DEVELOP IT.
SO THIS IS NIX-SHELL.
THINK ABOUT IT AS VIRTUAL ENVIRONMENT FOR ALL
SOFTWARE THAT YOU HAVE ON YOUR SYSTEM.
SO, YOU KNOW, IT CAN CREATE ON THE FLY, SHELLS WITH
SOFTWARE, SO YOU CAN SAY, GIVE ME DATA IN A BUNCH
OF LIBRARIES AND YOU CAN COMPILE...
[NO AUDIO]
INSTALLED NIX ON THERE, AND YOU KNOW IT GAVE ME A
SHELL WITH PYTHON TREE AND I DIDN'T CARE THAT I'M
USING -- THERE IS A FLAKE CALLED PURE AND THAT
FLAKE MAKE SURE IT DOESN'T INHERENT YOUR CURRENT
BASH.
[NO AUDIO]
MAKE SURE THAT THEY WORK WITH A SET OF TOOLS THAT
YOU DEFINE.
AND OTHERWISE, YOU KNOW, THE SCRIPT WILL BREAK.
BECAUSE WE'RE USING A LAZY LANGUAGE, WE HAVE -- A
LOT OF POWER TO CONFIGURE IT AS A USER.
AND AS A, YOU KNOW, DISTRIBUTION OR SOMEONE THAT
ACTUALLY DOES THE PACKAGING.
AND YOU CAN OVERWRITE PRETTY MUCH EVERYTHING.
TWO THINGS TO OVERWRITE.
THERE WAS A TOP LEVEL FUNCTION DEPENDANCIES.
AT THE TOP, GIVE ME PYTHON IN NEWER VERSION OF OPEN
SSL, AND YOU GET THAT, YOU KNOW, VALUE BACK.
AND THEN YOU HAVE, YOU KNOW, TWO VERSIONS OF PYTHON
USING OPEN SSL.
AND THEN THERE IS A WAY TO GLOBALLY OVERRIDE FOR
ALL THE PYTHONS ON YOUR -- YOU KNOW, FOR THE GLOBAL
PYTHON THAT OTHER PACKAGES USE.
AND THAT'S, YOU KNOW, A BIT OF A DIFFERENT
FUNCTION, BUT IT LOOKS PRETTY SIMILAR.
AND AT THE BOTTOM, YOU SEE ACTUALLY TO OVERRIDE THE
DURATION PARAMETERS.
SO IN THIS CASE, I GET A PYTHON THAT POINTS THE
SOURCE, NOT TO TAR BALL, BUT TO MY LOCAL CHECKOUT
OF PYTHON.
SO I COULD USE THAT AND THEN DEVELOP PYTHON AND GO
-- AND ENTER A NIX-SHELL INTO THIS EXPRESSION.
SO IN NIX WE HAVE --
[NO AUDIO]
AND BUILD PYTHON PACKAGES IS THE SET OF TOOL
SUPPORT, AND YOU KNOW, THE WAY THAT YOU BUILD, FOR
EXAMPLE, A PYRAMID FOR PYTHON 3, 4 --
AND BUILD PYTHON 3, 4 PACKAGES AND PYRAMID.
AND THERE ARE ALSO TOOLS TO AUTOMATICALLY GENERATE
PYTHON PACKAGES OUT OF PYTHON, YOU KNOW, SET OF
PYFILES AND THIS IS REALLY HARD AND I'M GOING TO
TALK ABOUT THIS A BIT LATER.
SO NIX DISTRIBUTION.
AND THINK ABOUT WHAT A DISTRIBUTION IS, YOU KNOW,
IT'S LIKE LINUX KERNEL, PROCESSER, ID 1, AND YOU
KNOW, A BUNCH OF --
[AUDIO CUTTING IN AND OUT]
SOFTWARE PACKAGE, RIGHT?
IT'S JUST ONE FILE.
ONLY DIFFERENCE IS, YOU KNOW, YOU AS A USER WOULD
INPUT THAT FILE, AND THE PACKAGES ARE DONE BY, YOU
KNOW, DISTRIBUTION GUYS.
BUT IN NIX IT DOESN'T MATTER BECAUSE WE'RE USING
THE SAME LANGUAGE AND TOOL.
SO IN NIX, DECLARATIVELY FINE YOUR SYSTEM IN ONE
FILE AND SAY "ACTIVATE" AND IT GIVES YOU A SYSTEM
WHICH, JUST AS YOU CONFIGURED IT.
AND HERE I ENABLED THE FIREWALL.
WHAT'S MY FILE SYSTEM?
YOU KNOW, WHAT PACKAGES TO INSTALL, AND AT THE
BOTTOM I DEFINE A SYSTEM PROCESS USING PYRAMID.
AND IT WILL START PYRAMID AND SERVE THAT.
AND THIS IS JUST, AGAIN, ANOTHER LOOK AT HOW TO
PACKAGE, YOU KNOW, MAKEUP LINUX DISTRIBUTION.
AND ON THE LEFT AND RIGHT SIDE YOU'LL SEE THERE'S
APACHE AND THIS IS, BASICALLY, WHAT HAPPENS BETWEEN
TWO DIFFERENT VERSIONS OF -- WHEN I HAVE -- SO THE
FIRST TIME I ACTIVATE NIXOS AND THAT'S AT THE
BOTTOM, YOU KNOW, ALL THE DEPENDENCY GRAPH, THAT'S
THE CLOSURE OF THE OPERATING SYSTEM.
AND THEN I MODIFY APACHE AND I GET THE SAME THINGS,
EXCEPT, A NEW APACHE SERVICE.
SO, YOU KNOW, IF IF -- FOR EXAMPLE, I UPGRADE TO
APACHE PACKAGE.
SO ALSO HAVE NIXOPS.
THAT'S A WAY TO DEPLOY TO DIFFERENT CLOUD
PROVIDERS.
SO YOU WOULD TAKE A PREVIOUS XIOS CONFIG AND WRITE
A SMALL SNIPPET OF WHAT...
[AUDIO CUTTING IN AND OUT]
VIRTUAL BOX FOR YOU, AND, YOU KNOW, PUT YOUR SYSTEM
IN A STATE, AS YOU DESCRIBED IT IN THAT FILE.
BECAUSE WE WANT, YOU KNOW, TO MOVE FAST, AND NOT
HAVE A PAINFUL LONG PROCESS, WE HAVE HIDRA WHICH
BUILD ALL THE BINARIES AND LOTS OF TESTS BEFORE WE
SAY NIX WORKS.
THIS IS THE HISTORY OF PACKAGE, OF TESTS
SUCCEEDING, AND YOU SEE SOMEONE BROKE PRINTING SPEC
BACK THERE.
AND THAT MEANS THE BINARY PACKAGES WON'T UPDATE AND
YOU WOULDN'T GET A NIXOS UPDATE UNTIL ALL THE TESTS
PASS.
SO WE'VE BEEN DOUBLING REQUESTS EVERY YEAR.
WE'RE AT ABOUT 400 REQUESTS A MONTH.
A LITTLE MORE THAN TEN PER DAY.
WHICH IS A LOT.
TWO MINIMUMS.
DECEMBER.
SECOND ONE IS JULY, AND THE AUGUST IS THEN, WAY UP,
BECAUSE WE HAD A SPRING.
SO, YOU KNOW, WHAT'S NEXT?
WHERE DO WE GO FROM HERE?
YOU KNOW, THE MOST IMPORTANT THING IS FOR PEOPLE TO
START USING IT AND GIVE FEEDBACK.
THE INFRASTRUCTURE IS THERE.
WE HAVE TO IMPROVE THE DOCS.
WE'RE AWARE OF THAT.
BUT YOU KNOW, IT'S A -- IT'S AN ONGOING PROCESS AND
WE NEED FEEDBACK AND YOU KNOW, SO THAT WE KNOW WHAT
TO FIX, EXACTLY.
YOU KNOW, WE ALSO WANT TO USE -- WE ALSO, AS
INTERNAL, WE ARE USING X, STILL, BUT THOSE ARE
STILL LIKE NICE THINGS TO HAVE.
WE DON'T REALLY BENEFIT.
AND YOU KNOW, PYPI 3 SOMETHING IS SOMETHING WE
COULD PACKAGE.
SO IF YOU LOOK AT -- ANOTHER THING TO IMPROVE, IF
YOU LOOK AT THE DEPENDENCY GRAPH, OF PYTHON, YOU
CAN SEE THAT IN OUR CASE, IT'S LIKE 250 MEGABYTES,
WHICH IS A LOT.
AND YOU KNOW, PERL, THAT'S, 50.
AT LEAST.
AND THE WAY THAT WE WANT TO IMPROVE THAT AND HANDLE
IT, IS THAT WE WANT TO SPLIT, ACTUALLY, PACKAGES,
INTO A PACKAGES THAT ONLY -- AND EVERYTHING ELSE IS
ANOTHER PACKAGE.
AND OFFERING DELIP --
AND THIS IS A REALLY NICE WAY TO MAKE THIS NUMBER
100 MEGABYTES OR EVEN LESS.
AND WHEN YOU THINK ABOUT IT, THIS IS ALSO THE
PROBLEM THAT THE PEOPLE HAVE.
THEY WANT VERY SMALL, YOU KNOW, RUN -- YOU KNOW,
BLOBS THAT YOU WANT IN YOUR DOC OR 1 GIGABYTES, AND
NIX COULD BE USED AND IMPROVED TO HANDLE THAT.
AND HOPEFULLY YOU WILL GET SMALLER IMAGES.
THERE ARE IS A BRANCH ON GITHUB THAT HAS THAT, BUT
IT'S STILL NOT FINISHED AND HOPEFULLY WE'LL GET IT
DONE IN THE NEXT FEW MONTHS.
SO THIS IS SOMETHING THAT'S MY PERSONAL GOAL AND
THAT'S, YOU KNOW, TO PACKAGE THE WHOLE PYPI AND
PROVIDE SYSTEM DEPENDENCIES.
AND THE HARDEST PART IS THE FIRST STEP, YOU KNOW.
TO ACTUALLY GET THAT PIP DONE AND GET IT OUT THERE,
SO THAT WE CAN ACTUALLY HAVE SET OF PYPI AND SAY
PYPI GIVE ME ALL THE DATA ABOUT YOUR PACKAGES, AND
YOU WOULD GET THAT.
BECAUSE NOW YOU HAVE TO DOWNLOAD THE PACKAGE, RUN
SET OF PY AND THEN GET DEPENDENCY AND FOR EACH
DEPENDENCY, YOU HAVE TO REPEAT THAT.
THIS IS TERRIBLE AND TAKES A LOT OF TIME TO DO
THAT.
AND YOU KNOW, THE SECOND STEP WOULD BE TO GENERATE.
WE HAVE TOOLS ALREADY TO DO SO.
AND TOOLS TO ACTUALLY PROVIDE THE OVERWRITES AND
THE SYSTEM PACKAGES.
SO THAT IS A QUICK OVERVIEW OF WHAT'S GOING ON IN
THE NIX LAND.
AND WE WILL HAVE, JUST LIKE A QA LIVE
DEMONSTRATIONS, 515B ROOM IF YOU HAVE QUESTIONS OR
SOMETHING LIKE THAT.
I ENCOURAGE YOU TO READ THE THINGS.
ONE IS, THE MAIN AUTHOR ABOUT OUR NIX, AND HE WROTE
A Ph.D. THESIS WHICH IS A REALLY NICE THESIS HOW
PACKAGES WE HAVE TODAY ARE BROKEN AND NIX ACTUALLY
DOES IMPROVE THAT.
AND SECOND IS AN ARTICLE I WROTE WHICH IS DOCS A
LITTLE BIT ON CONFIGURATION MANAGEMENT AND HOW THE
CURRENT TOOLS WE HAVE ACTUALLY MANAGE THE STATE OF
OUR MACHINES.
AND, YOU KNOW, THAT STATE IS ALSO HARD TO MANAGE.
IT'S NOT JUST THE STATE OF PACKAGING.
ALSO THE STATE OF THE...
[AUDIO CUTTING IN AND OUT]
[APPLAUSE]
>> ALL RIGHT.
THANKS, EVERYONE.
SO WE HAVE A FEW MINUTES FOR QUESTIONS.
IF YOU HAVE ANY, LINE UP TO THE MIC -- THE
MICROPHONE OVER THERE.
LET'S KEEP IT QUICKLY AND ONLY QUESTIONS REGARDING
TO THE --
>> AUDIENCE: THANK YOU FOR THAT.
THEY ARE VERY COOL.
SO THEY KEEP VERY --
DEPENDENCY GRAPH --
[NO AUDIO]
THAT YOU CAN BASICALLY TELL NIX THAT RELIES ON
GLIBC?
>> WE HAVE TO RECOMPILE EVERYTHING, WHICH IS
PROBLEMATIC IF YOU WANT TO MOVE FAST AND WE HAVE
WAYS TO WORKAROUND THAT.
BUT HERE, THE WHOLE IDEA IF YOU CHANGE SOMETHING
THAT IS VERY CORE, YOU HAVE TO RECOMPILE
EVERYTHING.
>> AUDIENCE: COOL, THANK YOU.
>> SO THERE'S SOME REALLY COOL THINGS YOU CAN DO
WITH NIX SOUNDS LIKE A GREAT OPTION FOR LOTS OF
SITUATIONS.
NAME SOME SITUATIONS WHERE IT WOULD BE A BAD IDEA
TO USE NIX SO WE CAN COMPARE AND CONTRAST?
>> ONE OF THE THINGS WE'RE AWARE OF, AND WE ADMIT
THAT, IS THAT WE DON'T REALLY -- WE HAVE SECURITY.
WE HAVE A STABLE CHANNEL FOR NIXOS.
WE ARE A COMMUNITY.
THERE IS NO VENDOR BEHIND THIS.
AND, YOU KNOW, WE WANT TO -- WE WANT TO WRITE TOOLS
THAT WILL HELP US PROTECT THINGS.
WE ALSO HAVE MONITORED NIX.ORG FUZZY MATCH THE
PACKAGES AND MAP THEM TO -- TO ALERT US WHEN
THERE'S SECURITY HOLES.
THIS IS NOT PERFECT.
SO IF YOU WANT, LIKE, IF YOU WANT LIKE DEBIAN TYPE
THING, UPGRADE SECURITY UPDATES, THAT'S WHAT WE
DON'T OFFER.
THAT'S ONE AREA.
BUT ANYTHING ELSE, I THINK IT GOES PRETTY WIDE.
WE HAVE A LOT OF DESK MANAGERS AND PEOPLE USE IT ON
THE SERVER SIDE.
I THINK THERE'S A LOT OF POTENTIAL FOR DOCKER AND
SO ON.
>> ALL RIGHT.
SO I THINK THAT'S IT.
THANK YOU, ONCE AGAIN.
[APPLAUSE]
[MUSIC PLAYING]
