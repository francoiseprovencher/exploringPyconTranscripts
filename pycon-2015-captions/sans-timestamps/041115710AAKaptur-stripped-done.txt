WELCOME TO DAY TWO OF PYCON.
SO, ALLISON WILL NOW BE GIVING THE FIRST OF HER
TWO TALKS FOR THIS SESSION.
THIS ONE IS CALLED "BYTES IN THE MACHINE."
ALLISON WORKS AT DROPBOX.
I'LL LET HER TAKE IT AWAY.
PLEASE GIVE HER A WARM WELCOME.
[ Applause ]
>> THANKS VERY MUCH.
CAN YOU HEAR ME OKAY?
HOW DOES THIS SOUND?
CAN EVERYONE HEAR ME OKAY?
GREAT.
SO AS ESTHER SAID, I'M ALLISON KAPTUR, I WORK AT
DROPBOX.
I WAS PREVIOUSLY A PROFESSOR AT HACKER'S SCHOOL
AND THIS IS WHERE YOU CAN FIND ME ON THE INTERNET
AND THIS IS BASICALLY MY HANDLE ANYWHERE ON THE
INTERNET.
I'M GOING TO TALK ABOUT WRITING A PYTHON
INTERPRETER IN PYTHON, PARTICULARLY CPYTHON.
THIS IS BYTES RUN, AND DONE WITH NED BATCHELDER,
HE DID MOST OF THE PYTHON 2 SUPPORT, HE CAME IN
AND DID PYTHON 3 SUPPORT.
WORKING ON THIS WITH NED FOR ABOUT A YEAR, AND
IT'S BEEN A REALLY INTERESTING AND EDUCATIONAL
EXPERIENCE AND I WANT TO SHARE THAT WITH ALL OF
YOU TODAY.
SO BEFORE WE GET STARTED, THE WORD "INTERPRETER"
IS USED IN A VARIETY OF DIFFERENT WAYS WHEN
PEOPLE ARE TALKING ABOUT PYTHON.
SOMETIMES WHEN SOMEONE SAYS THE INTERPRETER THEY
MEAN, THE REPL, THE INTERACTIVE YOU GET,
SOMETIMES PEOPLE SAY THE PYTHON INTERPRETER TO
MEAN ALL OF PYTHON, THE WHOLE PROCESS OF
EXECUTING CODES.
TODAY WE'RE GOING TO TALK ABOUT IT IN A MORE
NARROW SENSE.
AN INTERPRETER FOR OUR PURPOSES IS THE LAST STEP
IN THE PROCESS OF RUNNING A PYTHON PROGRAM.
WHEN PYTHON EXECUTES YOUR CODE, YOU CAN THINK OF
THERE BEING 4 STAGES.
THERE'S LEXING AND PARSING, WHICH IS GOING FROM
SOURCE CODE INFILES TO AN AST THAT THE COMPILER
KNOWS WHAT TO DO WITH.
THEN THERE'S COMPILING, WHICH IS TAKING THE AST
AND TURNING IT INTO A CODE OBJECT THE INTERPRETER
KNOWS HOW TO HANDLE, AND THEN THERE'S
INTERPRETING, WHICH IS TAKING THE CODE HANDLE AND
DOING WHATEVER IT SAYS.
SO BYTE RUN IS A PYTHON INTERPRETER IN THIS
SENSE, TAKES COMPILE CODE OBJECTS AND MAKES THEM
RUN.
YOU MAY BE SURPRISED TO HEAR THAT COMPILING IS A
STEP IN PYTHON AT ALL, SINCE PYTHON IS FAMOUSLY
AN INTERPRETED LANGUAGE IN CONTRAST WITH THE
COMPILED LANGUAGE LIKE C OR REST.
IT TURNS OUT THAT THIS TERMINOLOGY IS NOT AS
PRECISE AS IT SEEMS.
AND IN FACT, MOST INTERPRETED LANGUAGES INCLUDING
PYTHON DO INVOLVE A COMPILATION STEP.
SO THE REASON WHY PYTHON IS CALLED INTERPRETED
INSTEAD -- EVEN THOUGH IT INVOLVES COMPILATION,
IS THAT THE COMPILATION DOESN'T DO A LOT OF WORK
IN PYTHON AND THE COMPILER KNOWS VERY LITTLE.
AND BY CONTRAST, THE INTERPRETER DOES A LOT MORE
WORK AND THE INTERPRETER IS RESPONSIBLE FOR A LOT
MORE.
AND THE PYTHON COMPILER HAS MUCH LESS INFORMATION
ABOUT THE PROGRAM THAT IT'S GOING TO EXECUTE THAN
A C-COMPILER DOES.
A PYTHON INTERPRETER IS A VIRTUAL MACHINE WHICH
JUST MEANS THAT IT'S SOFTWARE THAT EMULATES A
PHYSICAL COMPUTER.
AND THIS PARTICULAR VIRTUAL MACHINE IS A STACK
MACHINE, SO IT MANIPULATES SEVERAL STACKS TO
PERFORM ITS OPERATIONS.
THIS IS IN CONTRAST WITH A REGISTER MACHINE WITH
WHICH YOU COULD MANAGE A VIRTUAL REGISTER MACHINE
IS A DIFFERENT THING BUT THE IDEA WOULD BE YOU
WRITE TO AND READ FROM VARIOUS LOCATIONS IN
MEMORY, INSTEAD OF DOING THAT, WE'RE OPERATING ON
A STACK.
AND IN PARTICULAR, THE PYTHON INTERPRETER IS A
BYTECODE INTERPRETER, SO ITS INPUT IS IN THESE
INSTRUCTION SETS CALLED BYTECODE.
WHEN YOU WRITE PYTHON, THE LEXER, COMPILER
GENERATE THE BYTECODE, IN ADDITION TO SOME EXTRA
PARTS THAT THE INTERPRETER NEEDS TO RUN.
AND THE INTERPRETER THEN CONSUMES THOSE
INSTRUCTIONS.
BYTECODE IS OFTEN CALLED AN INTERMEDIATE
REPRESENTATION OF PYTHON CODE BECAUSE IT
EXPRESSES THE SOURCE CODES THAT YOU WROTE IN A
WAY THE INTERPRETER CAN UNDERSTAND.
THIS IS ANALOGOUS TO THE WAY ASSEMBLY LANGUAGE IS
BETWEEN C-CODE AND A PIECE OF HARDWARE.
AN INTERMEDIATE REPRESENTATION LIKE THIS ADDS A
LAYER OF COMPLEXITY TO YOUR EXECUTION MODEL, SO
THERE IS A COST TO IT IN THAT SENSE.
BUT THE ADVANTAGE IS THAT ALL THIS WORK, THE
LEXING, PARSING, COMBINING Y, ONLY HAS TO BE DONE
ONCE FOR EACH CODE OBJECT INSTEAD OF EVERY TIME
YOU NEED THE CODE OBJECT LATER.
SO OUR GOAL TODAY IS A BYTECODE INTERPRETER.
WHY WOULD YOU WRITES AN INTERPRETER?
CPYTHON IS PRETTY GOOD AND REWRITING IT
PARTICULARLY USING THE STRATEGY WE TOOK WHICH IS
TO REWRITE IT IN PYTHON WON'T MAKE IT BETTER OR
FASTER IN MOST WAYS.
SO FOR NED BATCHELDER, YOU MAY KNOW HIM AS THE
EDITOR OF COVERAGE TEST -- THIS IS A REALLY
TRIVIAL EXAMPLE OF A LINE OF CODE WHERE LINE
LEVEL COVERAGE CAN BE MISLEADING.
YOU MAY HAVE WRITTEN A TEST, THE TEST A BUT NOT B
SO YOU COULD HAVE A BUG IN YOUR PROGRAM HERE AND
LINE LEVEL COVERAGE WOULDN'T CATCH THAT.
SO THE ORIGINAL GOAL OF BYTE RUN WAS TO
INVESTIGATE WHETHER BYTECODE LEVEL COVERAGE WOULD
BE AN INTERESTING THING TO PURSUE.
AND ONE OF THE LESSONS FROM WORKING ON THIS
PROJECT IS THAT IT'S EXTREMELY FIDDLY AND WE HAVE
NOT ENDED UP PURSUING THAT.
I WAS IN THIS PROJECT MOSTLY AS AN INTELLECTUAL
EXERCISE, I THINK IT'S VERY FUN AND INTERESTING
>> SO THE NEXT QUESTION IS WHY WRITE A PYTHON
INTERPRETER IN PYTHON AND PARTICULARLY DOING IT
IN THIS RELATIVELY NAIVE WAY THAT WE WERE DOING
AS OPPOSED TO SOMETHING MORE SOPHISTICATED THAN
PYPY HAS TAKEN.
THE OBVIOUS DISADVANTAGE IS SPEED, THIS WON'T BE
A FUNCTIONAL INTERPRETER IN ANY INTERESTING WAY.
BUT SINCE THE GOAL IS TO UNDERSTAND THE REAL
CPYTHON INTERPRETER, WE DON'T CARE ABOUT SPEED OF
EXECUTION SO WE'RE RUNNING IN A HIGH LEVEL
LANGUAGE PYTHON THAT WE KNOW HOW TO READ AND
WRITE EFFECTIVELY SO WE ENDS UP WITH A PRODUCT
THAT IS EASILY UNDERSTANDABILITY.
THE OTHER SIGNIFICANT ADVANTAGE IS BECAUSE WE
IMPLEMENTED AN INTERPRETER IN PYTHON, WE DIDN'T
HAVE TO IMPLEMENT THE OBJECT SYSTEM.
WHERE YOU JUST SAY, OKAY, WHEN YOU GET TO AN
OBJECT, FALL BACK TO THE REAL OBJECT SYSTEM
ALREADY THERE IN PYTHON, SO THE INTERPRETER CAN
DO SORT OF JUST THE BYTECODE STAGE OF THINGS.
SO THIS IS AN EXAMPLE OF A TEST IN BYTE RUN.
THE IDEA HERE IS THAT WE RUN THE CODE UNDER THE
REAL PYTHON INTERPRETER AND THEN AGAIN UNDER
BYTERUN AND WE MAKE SURE THAT THE SAME THING
HAPPENS, SO WE CAPTURE STANDARD OUT, WE CAPTURE
EXCEPTION STATE, WE COMPARE WHAT GOT PRINTED AND
THE EXCEPTIONS AND SO ON.
COMPARE BYTE RUN TO A REFERENCE IMPLEMENTATION IS
A REALLY GREAT WAY TO DO QUICK DEBUGGING AND THIS
IS IN FACT THE SAME STRATEGY USED FOR MANY NEW
STRATEGIES, LIKE PISTON WHICH IS BEING USED IN
DROPBOX.
THIS ONE PASSES.
SO WE HAVE IMPLEMENTED FOUR LOOPS IN A WAY THAT
WORKS CORRECTLY.
IN FACT, AS OF ABOUT A YEAR AND A HALF AGO, MOST
THINGS WORKED CORRECTLY.
WE COULD DO LOOPS, WE COULD DO FUNCTION CALLS, WE
COULD DO EXCEPTION HANDLING, WE COULD DO CONTEXT
MANAGERS, DECORATORS, GENERATORS, SO ON.
WE HAD ONE PROBLEM THAT WAS STUMPING US.
IN PARTICULAR, WE GOT ERRORS ON NESTED
GENERATORS.
WE GOT A REALLY WEIRD ERROR, TOO.
WE WERE TRYING THIS CODES, WHICH SHOULD WORK AND
WE GET A TYPERROR THAT WE WERE TRYING TO MULTIPLY
TO NONE OBJECTS, WHICH IS OBVIOUSLY NOT GOING TO
SUCCEED AND ALSO NOT AT ALL CLEAR WHERE THAT'S
COMING FROM IN THIS CODES.
SO I'M GOING TO TALK A LITTLE BIT ABOUT THE
STRUCTURE OF BYTE RUN, WHICH MIRRORS THE
STRUCTURE OF THE REAL C-PYTHON INTERPRETER TO
UNCOVER THIS BUG AND IT'S AMAZING HOW WELL THIS
WORKED CONSIDERING HOW WRONG WE WERE ABOUT THE
STRUCTURE.
TO BE CLEAR, EVERYTHING I'M GOING TO DESCRIBE IS
THE CORRECT STRUCTURE AND THEN I'LL REVEAL WHAT
OUR MISUNDERSTANDING WAS TOWARDS THE END.
SO TO MAKE THIS CONCRETE, LET'S START WITH A VERY
MINIMAL INTERPRETER.
THIS INTERPRETER UNDERSTANDS USE THREE
INSTRUCTIONS.
HERE THEY ARE.
LOAD OF VALUE, ADD-TO VALUES AND PRINT THE
ANSWER.
ALL THE CODE IT CAN EXECUTE CONSISTS OF THESE
THREE INSTRUCTIONS IN DIFFERENT COMBINATIONS.
SINCE WE'RE NOT CONCERNED AT ALL TODAY ABOUT
LEXER OR PARSER OR COMPILER, WE DON'T CARE HOW
YOU GOT THE INSTRUCTIONS.
YOU COULD IMAGINE YOU PROPERTY SEVEN PLUS FIVE IN
A PYTHONEE SYNTAX AND SOME FRIENDLY COMPILER
GENERAL RAILS THE FOUR INSTRUCTIONS YOU SEE AT
THE BOTTOM.
OR IF YOU HAD A DIFFERENT COMPILER, YOU COULD
WRITE LISP SYNTAX AND GET THE INSTRUCTIONS AT THE
BOTTOM.
TODAY WE DON'T CARE.
THE INTERPRETER JUST CARES THERE IS A
WELL-INFORMED ARRANGE.
OF THESE THREE INSTRUCTIONS, AND THIS IS ONE THAT
IS WELL-FORMED.
SO NOW LET'S TALK ABOUT WHAT WE WANT THE
INSTRUCTIONS TO DO.
THE PYTHON INTERPRETER IS A STACK MACHINE SO IT'S
GOING TO MANIPULATE STACKS TO ADD TO NUMBERS.
IT WILL MANIPULATE STACKS TO DO EVERYTHING.
NOW, WHEN YOU HEAR ABOUT STACKS, YOU'RE PROBABLY
THINKING FIRST OF THE CALL STACK.
THAT IS NOT THE STACK THAT WE'RE TALKING ABOUT
RIGHT NOW, SO HOLD THAT THOUGHT.
WE WILL COME BACK TO THE CALL STACK IN A MINUTE
BUT FOR NOW, IGNORE IT COMPLETELY.
SO WE HAVE SOME STACK THAT CAN HOLD DATA.
AND WHEN THE INTERPRETER BEGINS, THE STACK IS
EMPTY.
IT EXECUTES THE FIRST INSTRUCTION, WHICH PUSHES
THE FIRST NUMBER ON TO THE STACK, THAT'S SEVEN.
THEN IT PUSHES THE SECOND NUMBER ON TO THE STACK,
THAT'S FIVE.
THEN IT ADDS THEM TOGETHER, PUSHES THE RESULT ON
TO THE STACK, THAT'S 12, AND THEN WHEN PRINT
ANSWER, WE'LL POP THE RESULT OFF THE STACK AND
PRINT IT.
SO THE MANIPULATION HERE IS LOAD VALUE IS
RESPONSIBLE FOR GETTING VALUES ON TO THE STACK.
ADD-20 VALUES IS RESPONSIBLE FOR POPPING THEM OFF
AND ADDING AND PRINT ANSWER CONSUMES WHATEVER IS
ON THE STACK AND PRINTS IT.
YOU MAY BE WONDERING AT THIS POINT WHY
INSTRUCTIONS OTHER THAN ADD-TO VALUES ARE
NECESSARY AT ALL.
AND ADMITTEDLY, FOR THE CASE WHERE WE JUST ADD
TWO VALUES, IT IS SLIGHTLY CONTRIVED.
BUT THIS CREATES A STRONG FRAMEWORK THAT WE CAN
USE TO ADD A LOT OF COMPLEXITY SO JUST WITH THE
INTERPRETER INSTRUCTIONS WE'VE DESIGNED SO FAR,
WE CAN ADD THREE VALUES, OR ANY NUMBER OF VALUES.
IF WE HAVE THIS WELL-INFORMED SET OF
INSTRUCTIONS.
AND THE STACK PROVIDES A REALLY CLEAN WAY TO
TRACK THE INTERPRETER STATE AND IT WILL SUPPORT A
LOT MORE COMPLEXITY AS WE GO ON.
SO THE NEXT QUESTION IS, WHERE DO THESE NUMBERS
COME FROM?
IN OUR EXAMPLE OF THE INSTRUCTIONS, IT JUST SAYS
LOAD VALUE BUT DOESN'T SAY WHAT VALUE TO LOAD.
SO WE HAVE TO TELL THE INTERPRETER THAT.
LET'S EXPAND OUR INSTRUCTIONS A LITTLE BIT.
INSTEAD OF HAVING JUST A LIST OF INSTRUCTIONS,
WE'LL HAVE THIS DICTIONARY, CALL WHAT TO EXECUTE.
THERE ARE TWO PIECES, THE INSTRUCTIONS THEMSELVES
AND THEN THE NUMBERS WHICH WE'LL ALSO NEED.
AND WE ALSO NEED TO LINK EACH NUMBER TO THE
CORRECT INSTRUCTION.
SO LOAD VALUE THE FIRST TIME SHOULD LOAD THE
FIRST NUMBER AND THEN THE SECOND TIME WILL LOAD
THE SECOND NUMBER.
IN PYTHON WHAT I'M CALLING INSTRUCTIONS HERE IS
THE BYTECODE ITSELF AND THE WHOLE WHAT TO EXECUTE
OBJECT IS ANALOGOUS TO THE CODES OBJECTS.
SO WHY NOT JUST PUT THE NUMBERS DIRECTLY INTO THE
INSTRUCTIONS?
IMAGINE IF WE WERE ADDING TOGETHER STRINGS
INSTEAD OF NUMBERS.
WE MIGHT NOT KNOW HOW LONG THOSE STRINGS ARE, AND
WE MIGHT NOT KNOW -- WE MIGHT WANT TO PACK THE
INSTRUCTIONS IN A WAY WHERE THE LENGTH IS ALREADY
PREDETERMINED.
THE OTHER ADVANTAGE TO THIS DESIGN IS IF WE'RE
ADDING 7 PLUS 7, INSTEAD OF 7 PLUS 5.
WE ALL NEED ONE COPY OF THE NUMBER 7 IN THE CODE
OBJECT.
THIS COMES IN HANDY IN A LOT OF PLACES.
OKAY, SO LET'S START WRITING OUR INTERPRETER
ITSELF.
WE KNOW THAT OUR INTERPRETER NEEDS A STACK.
RIGHT NOW THAT'S ALMOST THE ONLY THING THAT WE
NEED IN OUR INTERPRETER.
AND WE NEED TO IMPLEMENTS THE INSTRUCTIONS SO THE
INTERPRETER KNOWS WHAT TO DO WHEN IT HITS THAT
INSTRUCTION.
SO HERE WE HAVE THREE FUNCTIONS THAT ARE NAMED
ANALOGOUS TO THE INSTRUCTIONS, VALUE LOADER FOR
LOAD VALUE, ANSWER PRINTER FOR PRINT ANSWER AND
TWO VALUE ADDER FOR ADDING INSTRUCTIONS.
FOR ADDING THE VALUES.
YOU'LL NOTICE THAT EACH OF THESE INTERACT WITH A
STACK IN THE WAY WE JUST OUTLINED, THE VALUE
LOADER PUSHES SOMETHING ON TO THE STACK AND TWO
LOADER POPS SOMETHING OFF AND SO OPEN.
SO WE NEED ONE MORE PIECE, A WAY TO MAKE THE
THING GO.
HERE WE HAVE A METHOD CALLED RUN CODE WHICH TAKES
THAT WHAT TO EXECUTE OBJECT AND DOES WHAT IT SAYS
IN IT.
SO THE FIRST THING WE DO IS UNPACK INTO
INSTRUCTIONS AND NUMBERS, JUST FOR CLARITY AND
READABILITY.
THEN WE LOOP OVER THE INSTRUCTION.
WE PROCESS THE ARGUMENT TO THAT INSTRUCTION, IF
THERE IS ANY, WHICH THERE MIGHT NOT BE.
AND THEN WE CALL THE CORRESPONDING METHOD ON THE
INTERPRETER OBJECT.
AND WE JUST DO THAT WITH AN "F" STATEMENT.
WE HAVE A METHOD DEFINED FOR EACH INSTRUCTION.
WE SAY IN WE'RE LOOKING AT LOADS VALUE, CALL THE
VALUE LOADER WITH THE CORRECT ARGUMENT.
SO THIS INTERPRETER IS QUITE LIMITED, BUT THIS
PROCESS IS ALMOST EXACTLY HOW THE REAL PYTHON
INTERPRETER ADDS TWO NUMBERS.
AND THERE ARE A COUPLE OF THINGS WE CAN NOTICE
FROM THE SMALL EXAM WILL.
THE FIRST ONE IS THAT SOME INSTRUCTIONS DO NEED
ARGUMENTS, AND REAL PYTHON BYTECODE IS ABOUT HALF
THE INSTRUCTIONS THAT NEED ARGUMENTS AND HALF DO
NOT.
THE SECOND THING TO NOTICE IS THE ARGUMENTS TO
THE INSTRUCTION ARE PACKED IN WITH A BYTECODE
WHERE WE HAD LOAD VALUE ZERO, THAT'S BASICALLY
THE WAY THE BYTECODE IS STRUCTURED, AS WELL.
AND WE CAN NOTICE THAT THE ARGUMENTS TO THE
INSTRUCTIONS ARE DIFFERENT THAN THE ARGUMENTS TO
THE FUNCTION BEING CALLED.
SO FOR LOAD VALUE, WE NEED TO GO LOOK UP WHAT THE
CORRECT ARGUMENT IS, AND THEN PASS THAT NUMBER,
NOT THE INDEX INTO THE NUMBERS LIST THAT WE SAW
EARLIER, PASS THE ACTUAL NUMBER AT THAT POINT
INTO THE VALUE LOADER FUNCTION.
AND FINALLY, NOTICE THAT THE ADD-TO VALUES DID
NOT REQUIRE ANY ARGUMENTS SO THE INSTRUCTION
ITSELF JUST SAYS, TAKE WHATEVER IS ON THE TOP OF
THE STACK AND ADD IT TOGETHER.
THE TOP TWO THINGS ON THE STACK, ADD THAT
TOGETHER.
THIS IS THE DEFINING FEATURE OF A STACK-BASED
INTERPRETER, IS THAT WE WILL BE MANIPULATING THE
STACK AND ANY TIME WE'RE DOING A CALCULATION,
BASICALLY, THE VALUES HAVE BEEN ON THE STACK AT
SOME POINT.
SO LET'S NOW GRADUATE TO REAL PYTHON BYTECODE.
AS I MENTIONED, THESE INSTRUCTIONS SETS IN PYTHON
ARE CALLED BYTECODE AND THE OVERALL OBJECT IS
CALLED THE CODES OBJECT.
ONE GREAT THING ABOUT PYTHON IS IT EXPOSES A TON
OF INTERNAL IMPLEMENTATION DETAILS IN THE
WRAP-OUT SO IT'S EASY TO POKE AROUND AND EXPLORE
AND SEE WHAT'S GOING ON, SO IT WON'T BE TOO HARD
FOR US TO DO.
SO HERE'S A FUNCTION THAT WE CAN USE TO EXPLORE.
IT'S SIMPLE, CALLED MOD, TAKES TWO ARGUMENTS,
CALCULATES THE MODULUS OF ONE AGAINST THE OTHER,
AND THEN RETURNS THE RESULTS.
SO WE CAN GET A HANDLE ON THE FUNCTION OBJECT,
WHICH IS MOD.
ON THE MOD FUNCTIONS CODE OBJECT, WHICH IS
FUNCTION CODES, AND THEN WE CAN GET A HANDLE ON
THE BYTECODE WHICH IS STORED UNDER CODE CODE.
BYTECODE IS A SUBSET, NOT THE SAME THING AS A
CODE OBJECT.
SO LET'S LOOK AT THIS.
SO JUST PRINTING THIS DOESN'T FEEL VERY
ENLIGHTENING, BUT THERE IS IN FACT ONE THING THAT
WE CAN LEARN JUST FROM DOING THIS AND THAT IS
THAT BYTECODE IS A SERIES OF BYTES.
A SERIES OF NUMBERS BETWEEN 0 AND 255 AND IT
LOOKS A LITTLE FUNNY IN THE TERMINAL BECAUSE SOME
OF THEM ARE PRINTABLE AND SOME ARE NOT BUT WE
ALREADY KNOW SOMETHING ABOUT BYTES JUST FROM
THAT.
WE CAN MAKE THIS SLIGHTLY MORE INTELLIGIBLE BY
CONVERTING TO ORDINALS AND THIS REALLY SHOWS THIS
IS NUMBERS BETWEEN 0 AND 255 BUT STILL NOT
EXACTLY READABLE.
SO LUCKILY FOR US, THERE IS A TOOL WE CAN USE IN
THE STANDARD LIBRARY TO MAKE THIS INTELLIGIBLE.
YOU CAN JUST DIS, THE BYTECODE DISASSEMBLER AND
IN GENERAL, YOU WANT A DISASSEMBLER WHEN YOU HAVE
SOME SET OF INSTRUCTIONS INTENDED FOR A MACHINE
AND YOU WANT TO MAKE THEM READABLE FOR HUMANS.
SO ASSEMBLY LANGUAGE IS A CASE WHERE YOU WOULD
USE A DISASSEMBLER VERY OFTEN.
I CAN'T THINK OF A REASON WHY YOU WOULD WANT TO
USE DIS IN PRODUCTION, IN FACT, DIS DOESN'T EVEN
RETURN THIS OUTPUT, JUST PRINTS IT.
THIS IS INTENDED FOR OUR EYES AND NOT FOR MACHINE
CONSUMPTION.
SO WE RUN OUR FUNCTION THROUGH THE DISASSEMBLER,
WE GET THIS OUTPUT.
I'VE GOT THIS ANNOTATED SLIGHTLY JUST BELOW THE
CALL.
THE LEFT-HAND COLUMN IS THE LINE NUMBER IN THE
ORIGINAL SOURCE CODE SO OUR CODE WAS TWO LINES
AND THIS IS LINE TWO AND THREE FROM THE REPL.
THE SECOND COLUMN IS THE INDEX INTO THE BYTECODES
SO THIS IS TELLING US AT POSITION 0 IS LOAD FAST,
AT POSITION 7 IS STORE FAST AND SO ON.
THE THIRD COLUMN IS THE INSTRUCTION -- IS THE
BYTE MAPS TO A HUMAN-READABLE INSTRUCTION NAME,
SO 124 BECOMES LOAD FAST AND 22 BECOMES BINARY
MOD WHICH IS MUCH FRIENDLIER FOR US TO READ AS
HUMANS.
THE FOURTH COLUMN IS THE ARGUMENT TO THE
INSTRUCTION AND NOTICE AGAIN, HERE, THAT BINARY
MODULE LOAD DOES NOT TAKE ANY ARGUMENTS.
THE FIRST TIME I SAW THIS I WAS REALLY SURPRISED
AND CONFUSED BECAUSE I WOULD ASSUME THAT A BINARY
FUNCTION IS ONE THAT TAKES TWO ARGUMENTS, THAT
SEEMS DEFINITIONALLY TRUE, BUT IN BYTECODE, THOSE
ARGUMENTS WILL ALREADY BE ON THE STACK SO THE
INSTRUCTION ITSELF DOES NOT REQUIRE ARGUMENTS.
THE FIFTH COLUMN IS A HINT FROM ELSEWHERE ON THE
CODE OBJECT ABOUT WHAT THAT ARGUMENT MEANS, SO WE
CAN TELL THAT THE FIRST TIME YOU DO LOAD FAST,
YOU'RE GETTING A AND THE SECOND TIME YOU GET B
AND SO ON SO WHAT HAPPENS IN THE INTERPRETER WHEN
WE CALL THIS FUNCTION.
IT'S JUST LIKE OUR MINIATURE EXAMPLE BEFORE.
THE PYTHON INTERPRETER PUSHES THE VALUE OF A ON
TO THE STACK, THAT'S 7.
PUSHES THE VALUE OF B ON THE STACK, THAT'S FIVE.
THEN IT CALCULATES BINARY MOD OF ONE AGAINST THE
OTHER, GETS TWO AND PUSHES THAT ON TO THE STACK
AND THEN THE ANSWER GETS STORED BY THE STORE-FAST
INSTRUCTION WHICH MEANS THAT THE NAME ANSWER IN
OUR EXAMPLE WILL BE BOUND TO THE NUMBER TWO.
SO NOW WHAT?
WE COMPLETED THIS FIRST LINE OF CODE HERE, THE
ANSWER IS A MOD B AND DOWN TO LINE THREE.
WE KNOW WHAT LOAD FAST DOES, HERE IN POSITION 10,
SECOND LINE UP FROM THE BOTTOM.
THAT PUSHES THE VALUE ON TO STACK.
AND THEN THERE'S RETURN VALUE, WHICH PRESUMABLY
IS RELATED TO THIS RETURN STATEMENT BUT IN OUR
CURRENT MENTAL MODEL, THE INTERPRETER, THERE'S
NOWHERE TO RETURN TO.
SO AT THIS MOMENT, I WOULD LIKE YOU TO REMEMBER
THE CALL STACK THAT I ASKED YOU TO FORGET EARLIER
AND ZOOM OUT A LEVEL.
THE CALL STACK NOW IS MODEL TOP TO BOTTOM AND THE
DATA STACK, WHICH IS THE STACK WE'VE BEEN LOOKING
AT SO FAR IS GOING LEFT TO RIGHT.
THE STACK THAT THE INTERPRETER IS USING FOR
CALCULATIONS, I DON'T KNOW IF DATA STACK IS
COMMON TERMINOLOGY BUT CERTAINLY IT IS A STACK
THAT CONTAINS DATA SO THAT'S THE TERM I WILL BE
USING TODAY.
MEANWHILE, THE CALL STACK IS MADE UP OF FRAMES.
YOU HAVE ONE FRAME ON THE CALL STACK FOR EACH
LEVEL OF YOUR CODE, AND THIS IS SOMETHING THAT
YOU'RE PROBABLY VISCERALLY REALLY FAMILIAR WITH
BECAUSE YOU SEE IT ALL THE TIME IN TRACE-BACKS,
SO YOUR TRACE-BACK SAYS MOST RECENT CALL ASKED
AND THEN HAS SEVERAL LEVELS.
EACH ONE OF THOSE LEVELS CORRESPONDS TO A FRAME.
THE ONE FRAME FOR FUNCTION CALL, ONE FRAME FOR A
MODULE AND SO ON.
EACH FRAME HAS ITS OWN DATA STACK AND THEN ALSO
HAS ANOTHER STACK OF BLOCKS WHICH I WON'T TALK
ABOUT TODAY.
SO THIS IS WHAT THE INTERPRETER LOOKS LIKE IN THE
MIDDLE OF EXECUTING MOD, WHICH IS RIGHT BEFORE
THE BINARY MODULAR HAPPENS.
THERE'S TWO FRAMES ON THE STACK, ONE FOR THE MAIN
SCOPE AND ONE FOR OUR FUNCTION MOD.
AND WHEN RETURN VALUE IS EXECUTED, WHAT THAT'S
DOING IS IT TELLS THE INTERPRETER TO PASS A VALUE
FROM ONE FRAME TO ANOTHER.
NOW, RETURN VALUE IS ONE OF ONLY TWO WAYS TO
ACCOMPLISH THAT.
THE OTHER WAY IS WITH YIELD.
I WANT TO EMPHASIZE THAT THERE'S ONE FRAME ON THE
STACK FOR EACH FUNCTION CALL, NOT FOR EACH
FUNCTION OBJECT OR SOMETHING ELSE LIKE THAT.
AGAIN, PICTURE YOURSELF MAYBE HITTING THE
RECURSION LIMIT WHERE YOU GET A TRACE-BACK THAT
IS 500 FRAMES LONG, EVEN THOUGH THE SAME
FUNCTION.
SO WE HAD A RECURSIVE CALL, LIKE THIS FACTORIAL
CALCULATION AND IT WILL START OUT LOOKING LIKE
THIS.
I'M NOT SHOWING THE BYTECODES HERE BUT AT THIS
POINT WE'RE IN THE MIDDLE OF THE CALL TO FACTOR
OF 3 AND ABOUT TO CALCULATE THREE MINUS ONE, SO
WE DO THAT, GET THE ANSWER TWO.
AT THIS POINT, WE HAVE THE FUNCTION OBJECT
FACTORIAL ON THE PREVIOUS FRAME'S DATA STACK.
I KNOW THIS IS A LITTLE BIT WEIRD.
CALL A FUNCTION CONSUMES A FUNCTION OBJECT OFF OF
THE STACK IN THIS WAY AND WHEN IT'S ACTUALLY
CALLED, IT CREATES A NEW FRAME FOR THE DEEPER
RECURSIVE CALL.
SO THEN THE INTERPRETER IS LOADING UP N, WHICH IS
NOW TWO AND PUSHING THAT ON TO THE STACK.
NOTICE, ALSO, THAT THERE IS A VALUE LEFT ON THE
DATA STACK IN THE PREVIOUS FRAME.
SO THAT'S THE N IN THE RESULT THAT IS WAITING FOR
FACT OF N MINUS ONE TO FINISH EXECUTING SO WE CAN
COME BACK TO IT.
WE'LL NEED IT THERE TO MULTIPLY WHEN THE CALL
STACK IS UNWINDING.
SKIPPING AHEAD A LITTLE BIT, WE'LL HIT THE BASE
CASE AND WE START UNWINDING SO THAT ONE GETS
RETURNED FROM THE TOP FRAME DOWN TO THE NEXT ONE
DOWN AND MULTIPLIED, MULTIPLY IT AGAIN, GET SIX
AND PASS THAT BACK TO THE CALLING FRAME.
SO THESE ARE THE BASIC PIECES THAT WE NEED TO
IMPLEMENT A PYTHON INTERPRETER, OUR OWN VIRTUAL
MACHINE.
WE NEED SOME WAY TO CREATE FRAMES, WE NEED TO
PROVIDE A DATA STACK FOR THAT FRAME AND ALSO
BLOCK STACK, AND WE NEED TO DEFINE A WAY TO RUN
THE FRAMES, AND TO RUN THE FRAMES, WE NEED TO
DEFINE THE CORRECT OPERATIONS FOR EACH
INSTRUCTION THAT WE MAY HIT, JUST AS WE DID FOR
OUR TOY INTERPRETER AT THE BEGINNING.
THE ONLY DIFFERENCE IS NOW THERE ARE A LOT MORE
INSTRUCTIONS.
I'M OMITSING A COUPLE OF OTHER NECESSARY
INGREDIENTS, LIKE TRACKING THE EXCEPTION STATE
AND TRACKING NAME SPACES AND SCOPES AND THAT SORT
OF THING.
IF THERE'S TIME, I CAN TALK ABOUT THAT IN Q AND
A.
SO WE HAVE A LOT MORE INSTRUCTIONS TO DEFINE FOR
A REAL PYTHON INTERPRETER AND OF COURSE THE
COMPLEXITY OF EACH INSTRUCTION IS ALSO GREATER.
SO WE NEED TO WRITE THE OPERATIONS THAT THE
INTERPRETER SHOULD PERFORM FOR EACH OF THESE
INSTRUCTIONS FOR THIS TO BE ABLE TO EXECUTE.
SO WHAT SHOULD THOSE BE?
WELL, THE GOOD NEWS IS WE'RE NOT STARTING FROM
SCRATCH.
WE HAVE CPYTHON, THE REFERENCE IMPLEMENTATION AND
WE CAN LOOK AT HOW IT IS IMPLEMENTED IN THE
REFERENCE IMPLEMENTATION, IN THE ACTUAL C-PYTHON
INTERPRETER AND GET GUIDANCE.
THE MAIN LOOP IS IN THE C VAL.C.
I SAW ON TWITTER THE WAY TO GETS INTO THE CPYTHON
CODE BASE IS STARTED ON CCODE.C AND START FROM
THERE, SO TODAY WE'LL TWO TWO OF THOSE STEPS AND
HOPEFULLY THREE.
IN OUR TOY INTERPRETER...
CAN YOU SEE THIS OKAY IN THE BACK?
[ Laughter ]
IN OUR TOY INTERPRETER, WE HAD A BIG IF STATEMENT
OR WHAT WOULD HAVE BEEN A BIG IF STATEMENT, IF
THE INSTRUCTION IS THIS, DO THIS.
IF THE INSTRUCTION IS THIS, DO THIS.
CPYTHON IS IMPLEMENT HAD IN THE SAME WAY AND
THE...
THIS IS IT.
I LOVE THIS BECAUSE IT FEELS LIKE SUCH AN OBVIOUS
IMPLEMENTATION IN SOME WAYS, LIKE YOU CAN IMAGINE
SITTING IN THE NETHERLANDS IN 1989 AND SAYING,
OKAY, WE HAVE THESE INSTRUCTIONS AND EACH OF THEM
MAPS TO A SET OF THINGS THAT NEEDS TO BE DONE AND
WE'RE WRITING C, HOW SHOULD WE DO THAT?
HOW ABOUT A GIANT SWITCH STATEMENT AND THAT'S
EXACTLY HOW IT WORKS.
IN FACT, 1500 LINE SWITCH STATEMENT IS SO
LARGE -- SORRY -- 1500 SWITCH STATEMENT IS SO
LARGE IT BREAKS SOME C COMPILERS AND THERE IS A
MACRO YOU CAN TURN ON IF IT BREAKS IT, SO YOU CAN
TURN IT INTO TWO SWITCH STATEMENTS THAT ARE ONLY
750 LINES EACH.
[ Laughter ]
SO THE INTERPRETER IS BASICALLY TAKING EACH
INSTRUCTION AND THEN WHYSING A SWITCH STATEMENT
TO LOOK UP THE CORRECT THINGS TO DO AND THEN
DOING THOSE THINGS AND MOVING TO THE NEXT
INSTRUCTION.
IN PYTHON 3 AND UP, THIS IS NO LONGER LITERALLY A
SWITCH, IT IS COMPUTED GO-TOES INSTEAD BUT THE
IDEA REMAINS QUITE SIMILAR.
OKAY, SO THESE ARE IN THE INSTRUCTIONS THAT WE
NEED TO KNOW HOW TO IMPLEMENT FOR OUR PYTHON
INTERPRETER AND LET'S LOOK AT THAT
IMPLEMENTATION.
HERE'S LOAD FAST, THE FIRST INSTRUCTION TO FIND.
THE MOST COMMON INSTRUCTION IN MOOSE PYTHON CODE
BASES AND THE C IS PRETTY READABLE HERE.
YOU CAN SEE WE RUN THE MACRO GET LOCAL AND STORE
THE VALUE, AND IF ANYTHING GOES WRONG, THEN WE
THROW AN UNBOUND LOCAL ERROR -- HANDS-UP IF
YOU'VE THROWN AN UNBOUND LOCAL ERROR BEFORE.
SO THIS HAPPENS WHEN YOU TRY TO LOAD A LOCAL
VARIABLE AND SOMETHING HAPPENS.
BUT IN THE MEANTIME, IF SOMETHING HAS NOT FAILED,
THEN WE PUSH THE RESULT ON TO THE STACK AND MOVE
ON TO THE NEXT CODE.
SO HERE IS THE CODE THAT RAISES THAT ERROR, THE
ONLY PLACE IN THE CPYTHON CODES BASE WHERE THAT'S
RAISED, I THINK, THAT'S PRETTY COOL WE CAN FIND
THAT RIGHT THERE.
AND HERE'S BINARY MODULAR, SO WE POP TWO THINGS
OFF THE STACK, IN PRACTICE, IT'S NOT QUITE THAT
BUT CLOSE ENOUGH.
WE DO SOME STUFF, WE CALCULATE THE REMAINDER AND
THEN WE PUSH THE RESULT BACK ON TO THE STACK.
COOL.
SO I'VE DESCRIBED THE STRUCTURE OF CPYTHON AND BY
BY EXTENSION, THE EXTENSION OF BYTE RUN, BUT UP
UNTIL ONE YEAR AGO, WE HAD ONE THING REALLY WRONG
AND IN PARTICULAR WE ONLY HAD ONE DATA STACK FOR
THE ENTIRE INTERPRETER INSTEAD OF ONE DATA STACK
PER FRAME.
WHAT'S INTERESTING IS HOW MUCH IS POSSIBLE
DESPITE MAKING THAT ERROR.
IN THIS CASE, THE NESTING THE GENERATORS, PAUSES
AND RESUMPTION THE FRAME OF G SEVERAL TIMES, AND
IT HAS TO DO SOME WORK IN-BETWEEN PAUSING AND
RESUMING.
SO THAT WORK IS ALSO MANIPULATING THE STACK THAT
SHOULD BELONG TO THE SEPARATE FRAME BUT INSTEAD
WAS IN THE WRONG PLACE.
AND IT IS NONE APPEARED AND WE TRIED TO MULTIPLY
IT BECAUSE RESUMING THE GENERATOR PUSHES NONE ON
TO THE STACK AND THE GENERATOR FRAME KNOWS HOW TO
CONSUME THAT APPROPRIATELY.
UNDERSTANDING THE CORRECT STRUCTURE HERE THAT IN
FACT THERE IS ONE DATA STACK FOR EVERY FRAME,
GIVES US THE ABILITIES TO PAUSE AND RESUME
FRAMES, WHICH IS WHAT WE NEED FOR GENERATORS AND
BY CONTRAST, IF THE PYTHON INTERPRETER WERE
IMPLEMENTED WITH ONLY ONE DATA STACK, THE ONLY
FEATURE THAT YOU WOULD LOSE IS GENERATORS.
SO IN THE LAST COME OF MINUTE HERE BEFORE Q AND
A, I WANT TO TALK A LITTLE BIT ABOUT HOW PYTHON
IS DYNAMIC.
AND ONE THING YOU HEAR THIS A LOT, LIKE, OH,
PYTHON IS DYNAMIC LANGUAGE, HAS DYNAMIC TYPING
AND IF YOU LISTEN TO PETER'S KEYNOTE, I GUESS THE
CLOSING TALK TOMORROW, YOU'LL HEAR ABOUT THE
FUTURE OF TYPES AND PYTHON.
I THINK A LOT OF FOLKS, PARTICULARLY THOSE OF US
ON PYTHON 2, ARE NOT SUPER FAMILIAR WITH WHAT'S
GOING ON HERE.
BUT WITH THE CONTEXT THAT'S JUST -- WE'VE JUST
BUILT UP ABOUT THE INTERPRETER, WE CAN TAKE A
LOOK AT ONE OF THE PROBLEMS THAT THIS IS TRYING
TO SOLVE.
SO ONE THING IN THE DYNAMIC MEANS IS THAT A LOT
IS HAPPENING AT RUN TIME.
AND ANOTHER WAY OF PUTTING THIS IS THAT NOT A LOT
IS HAPPENING AT COMPILE TIME.
AND THE INTERPRETER HAS A LOT OF WORK TO DO.
SO LET'S LOOK AT ACTUALLY CALLING UP THIS
FUNCTION MOD.
IT'S PRETTY OBVIOUS WHAT'S GOING ON HERE, WE CALL
MOD ON 15 AND 4 AND WE GET THE RESULT 3.
ANY GUESSES FOR WHAT WILL HAPPEN WHEN WE CALL THE
FUNCTION LIKE THIS?
[ PYTHON.
>> RIGHT, GET PYCON RETURNED, SO THIS MIGHT LOOK
WEIRD TO YOU BUT YOU'VE ALMOST CERTAINLY SEEN IT
BEFORE, YOU'VE SEEN IT AS STRING FORM MATING.
DOING THAT WITH A MOD LIKE THIS IS INVOKING
BINARY MOD ON THE ARGUMENTS.
SO THIS IS THE BYTECODE FOR THIS FUNCTION AND
THIS IS ALWAYS THE BYTECODE FOR THIS FUNCTION.
THE ADVANTAGE IS THAT WE'VE BUILT THIS ONE AND
REUSE IT AGAIN AND AGAIN, SO NO MATTER WHAT
ARGUMENTS ARE PASSED TO IT, WE'RE GOING TO CALL
BINARY MODULO ON WHATEVER THE TOP TWO ITEMS ON
THE STACK ARE AND THEY MAY BE TWO INTEGERS OR
THEY MAY BE A 2PULL AND A STRING OR TWO STRINGS,
THE COMPILER DOESN'T KNOW AND DOESN'T CARE.
IT'S UP TO THE INTERPRETER TO DO THE RIGHT THING.
SO I WENT BY THIS KIND OF FAST, ON PURPOSE,
EARLIER.
BUT ONE THING THAT YOU NOTICE HERE IS THAT THERE
IS A F STATEMENT, SAYING IF V IS A STRING, THEN
DISPATCH TO STRING FORMATTING.
THIS KIND OF LOOKS LIKE IT'S TYPE-CHECKING, IT'S
WORSE THAN THAT.
THE TYPE-CHECKING HERE IS OPTIMIZATION.
BECAUSE OF COURSE WE COULD PASS ANYTHING TO OUR
MODULAR FUNCTIONING, DOESN'T HAVE TO BE EITHER A
STRING OR A NUMBER, AND SO THIS PY NUMBER
REMAINDER IS RESPONSIBLE FOR EVENTUALLY DOING
DISPATCH ON WHATEVER THE OBJECT IS.
SO THIS GETS EVEN WORSE THAN THIS, BECAUSE THIS
IS PYTHON, RIGHT?
SO WE CAN DEFINE OUR OWN TYPES AND WE CAN DEFINE
WHAT DIFFERENT OPERATIONS MEAN ON THOSE TYPES.
SO WE COULD WRITE AN OBJECT THAT HAS A SIDE
EFFECTING MOD FUNCTIONING.
SO HERE I'VE WRITTEN MOD THAT SAYS PRINT
SOMETHING, WHEN YOU PUT ONE MOD AGAINST ANOTHER.
I DON'T KNOW WHY YOU WOULD WANT TO DO THIS BUT
YOU COULD AND IT IS STRICTLY UP TO THE
INTERPRETER TO RESOLVE WHAT YOU MEAN BY BINARY
MOD ON THE OBJECT.
IT'S REALLY DEEP.
THERE IS THIS GREAT PAPER BY RUSSELL POWER AND
ALEX RUBINSTEIN CALLED "HOW FAST CAN WE MAKE
INTERPRETED PYTHON" AND THE CONCLUSION FROM THE
STRATEGIES THAT THEY TRIED WAS THAT IT'S VERY
CHALLENGING.
AND THE QUOTE HERE IS IN THE GENERAL ABSENCE OF
TYPE INFORMATION, ALMOST EVERY INSTRUCTION MUST
BE TREATED AS INVOKE ARBITRARY METHOD.
SO GIVEN THAT THE COMPILEER KNOWS SO LITTLE
WITHOUT RUNNING THE CODE, WE CAN'T REALLY
OPTIMIZE IT, WE DON'T KNOW WHAT INSTRUCTIONS WE
CAN TAKE OUT, WE CAN'T REASON ABOUT ITS
CORRECTNESS, ALL THOSE ARE VERY HARD TO DO
BECAUSE THE LANGUAGE IS SO DYNAMIC.
BUT NOTICE THE COPY OUT HERE, IN THE GENERAL
ABSENCE OF TYPE INFORMATION.
SO ONE WAY TO SOLVE THIS PROBLEM IS TO SAY, FINE,
LET'S ADD TYPE INFORMATION.
AND THERE'S A LOT OF NUANCE TO HOW YOU DO THAT
AND HOW TO MAKE THAT NOT BREAK FOR PEOPLE WHO ARE
NOT INTERESTED IN THOSE SORTS OF THINGS BUT IN
THE NEXT VERSION OF PYTHON, THIS IS BASICALLY
WHAT'S HAPPENING.
YOU CAN ADD OPTIONAL TYPE INFORMATION TO YOUR
PYTHON, AND THE STATIC ANALYSIS TOOLS WILL BE
MORE ROBUST BECAUSE OF IT.
AND IT OPENS UP A LOT OF INTERESTING
POSSIBILITIES THAT JUST AREN'T THERE WHEN
EVERYTHING IS SO DYNAMIC.
OKAY.
SO I'VE GOT -- I'LL PUT UP THE LINKS A LITTLE BIT
LATER, A COUPLE OF GREAT BLOGS, THERE ARE A
COUPLE OF GREAT ARTICLES ABOUT THE INTERPRETER
AND INTERNALS AND THE GO-TO STATEMENTS AND SO ON.
IN THE MEANTIME, I'LL GO AHEAD AND TAKE SOME
QUESTIONS.
[ Applause ]
>> THANK YOU, ALLISON.
IF ANYONE HAS ANY QUESTIONS, PLEASE COME TO THE
CENTER OF THE ROOM AND STAND BY THE MIC SO THE
VIDEO CAN PICK YOU UP.
>> AUDIENCE:  GREAT TALK, THANKS.
IS THERE ANY POSSIBILITY OF DOING, LIKE, DYNAMIC
OPTIMIZATIONS LIKE --
>> DOING WHAT SORT OF OPTIMIZATIONS?
>> AUDIENCE:  I'M NOT VERY AWARE OF THE INTERNALS
OF THE PYTHON INTERPRETER BUT CAN YOU DO LIKE --
LIKE THE EXAMPLE IN THE JAVA VM, IT WILL START
REWRITING THINGS AS IT'S RUNNING?
DOES PYTHON DO THAT?
>> YES, PYTHON DOES A COUPLE OF OPTIMIZATIONS
WHERE IT CAN, SO ONE IS CONSTANT FOLDING.
IF YOU HAVE A FUNCTION THAT SAYS RETURN THREE
PLUS TWO, THE PYTHON COMPILER WILL RETURN THAT
INTO RETURN 5.
BECAUSE PYTHON IS SO DYNAMIC, THERE'S VERY FEW
CASES WHERE UNDER THE CURRENT STRUCTURE YOU CAN'T
OPTIMIZE AND THE SOURCE IN THIS IS FAIRLY
READABLE, HAD A BLOG POST ABOUT CONSTANT FOLDING
AND THE WAY IT MESSES UP THE BYTECODE LEVEL
COVERAGE BECAUSE THE BYTECODE ENDS UP CHANGING
OUT FROM UNDER YOU, BUT IT HAPPENS A LITTLE BIT
BUT IT'S PRETTY LIMITED BECAUSE OF THE STRUCTURE.
>> AUDIENCE:  THANK YOU.
>> AUDIENCE:  HI.
I'M RESEARCHING ON INTERPRETERS AND JVMS AND
SMALL -- SO I'M NOT THAT VERY FAMILIAR WITH
CPYTHONS AND THE INTERPRETER BUT I WANTED TO
KNOW, IS IT REAL SIMPLE SWITCH CASE OR IS THERE
SMALL OPTIMIZATIONS LIKE TO DISPATCH OR DYNAMIC
THREADED DISPATCHES, SO THERE ARE MORE DIFFERENT
WAYS, SO IS IT JUST A SIMPLE SWITCH CASE OR IS IT
SOMETHING ELSE?
AND IS THERE A POSSIBILITY TO JIT THIS SCORE TO
OPTIMIZE IT LIKE PYPY DOES?
>> YEAH, SO TO THE FIRST QUESTION, IS THIS
LITERAL SWITCH STATEMENT, ARE THERE
OPTIMIZATIONS?
YES TO BOTH, SO THE CODE IS LIKE LITERALLY, YOU
KNOW, CASE LOAD FAST, CASE, SO ON.
IN PYTHON 2.
AND THERE ARE A COUPLE OF OPTIMIZATIONS WHERE IN
PARTICULAR THERE ARE PAIRS OF BYTES THAT OFTEN
FOLLOW EACH OTHER SO IF YOU HAVE LIKE A GET
ITTERS, THERE'S PROBABLY A 4 AFTER IT.
AND THE INTERPRETER IS SMART ENOUGH TO SAY OKAY,
CHECK FIRST AT THIS PARTICULAR BYTE AFTER IT.
THAT'S ONE OPTIMIZATION.
THERE ARE A NUMBER OF OTHERS, SOME WORK HAS TO BE
DONE IN-BETWEEN EACH INSTRUCTION, SOME WORK IS
DONE EVERY HUNDRED INSTRUCTIONS, THOSE SORTS OF
THINGS.
IN TERMS OF WHETHER THIS STRUCTURE CAN BE JITED,
I DON'T KNOW A WHOLE LOT ABOUT THE WAY THAT PYPY
IS IMPLEMENTED.
I THINK THAT PYPY IS SORT OF AN EXISTENCE PROOF
THAT THIS CANNOT.
LIKE YOU WOULDN'T HAVE TO GO THAT DIRECTION AND
SOLVE THAT PROBLEM WITH A COMPLETELY NEW
INTERPRETER AND A NEW SET OF BYTECODE IF THIS
WERE AMENABLE TO INCREMENTAL CHANGE.
>> AUDIENCE:  OKAY, THANK YOU.
>> AUDIENCE:  I'M SORRY, THIS MAY BE A STUPID
QUESTION BUT DO THE TYPE ANNOTATIONS HAVE
ANYTHING TO DO WITH JIT COMPILING?
>> NO, I THINK IS THE SHORT ANSWER.
THE TYPE ANNOTATIONS ARE DESIGNED TO HELP STATIC
ANALYSIS, SO WITHOUT RUNNING THE CODE WHAT, CAN
WE SAY ABOUT IT NOW?
DOING JIT COMPILATION I THINK IS MORE OR LESS A
SEPARATE PROBLEM.
>> AUDIENCE:  YOU ALLUDED TO THE BLOCK STACK A
COUPLE OF TIMES, CAN YOU EXPLAIN WHAT THAT IS?
>> IN SHORT, THE BLOCK STACK IS KEEPING TRACK OF
A DIFFERENT -- STATE IN A DIFFERENT WAY, SO THE
CLASSIC EXAMPLE IS FOR AN ITERATOR, IF YOU'RE ON
THE TOP INSTRUCTION OF AN ITERATOR, YOU'RE EITHER
GOING TO STEP TO THE NEXT INSTRUCTION, IF YOU'RE
IN THE BODY OF THE FORELOOP OR IF YOU'RE DONE,
YOU'RE GOING TO JUMP OUT OF THE FORELOOP.
SO THE BLOCK STACK IS RESPONSIBLE FOR KEENING
TRACK OF THAT.
IT'S USED FOR LOOPING AND EXCEPTION HANDLING AND
I THINK THAT'S PRETTY MUCH IT.
IT'S JUST LIKE ANOTHER WAY OF MANAGING STATE.
>> AUDIENCE:  OKAY.
>> AUDIENCE:  HI.
I NOTICED IN YOUR EXAMPLE OF MODULAR, YOU
ASSIGNED, LIKE, A MODULAR B TO ANSWER AND THEN
RETURN ANSWER.
IF YOU JUST DID LIKE RETURN A MODULAR B, IS
THERE -- DOES PYTHON, LIKE, CREATE A VARIABLE FOR
THAT STACK?
>> IT WOULD NOT CREATE A VARIABLE, YEAH, SO
YOU'RE TALKING ABOUT...
YEAH, SO WHAT WE WOULD SEE IN THAT CASE, IS YOU
WOULD HAVE BINARY MODULAR AND THEN IMMEDIATELY
RETURN VALUE BECAUSE ALL THE RETURN VALUE NEEDS
IS THE RESULT ON THE STACK.
SO THIS IS JUST FOR READABILITY, YEAH.
AND THE INTERESTING THING THERE IS THAT MY
BINDING A NAME ANSWER TO THIS IS WHAT MAKES
PYTHON SAY, OKAY, PULL THIS OFF THE STACK AND PUT
IT INTO THE ENVIRONMENT.
AND THEN IMMEDIATELY RETRIEVE IT FROM THE
ENVIRONMENT AND RETURN IT.
SO THERE'S -- THIS IS SOMETHING I DIDN'T GET INTO
TOO MUCH ABOUT THE WAY THAT THE FRAME ALSO HAS TO
MANAGE THE NAME SPACE, WHAT IS CURRENTLY IN THE
LOCAL SCOPE AND THAT GETS MODIFIED AS YOU DO
THINGS LIKE STORE FAST AND LOAD.
>> AUDIENCE:  THANK YOU.
>> THANK YOU VERY MUCH, ALLISON.
[ Applause ]
[ BREAK ]
[ MUSIC PLAYING ]
[ MUSIC PLAYING ]
01:53:4102:32:48