ALL RIGHT.
OUR LAST SPEAKER FOR THE DAY IS JOSH TRIPLETT,
HE'LL BE TELLING US HOW HE PORTED PYTHON TO RUN
WITHOUT AN OPERATING SYSTEM.
>> YES, THE WHOLE POINT OF THIS TALK IS WE PORTED
PYTHON TO WORK WITHOUT AN OS, AND I'LL GO INTO
THAT.
I'LL ALSO TALK ABOUT SOME OF THE OTHER THINGS WE
ADDED TO PYTHON IN ORDER TO BUILD UP A NICE
ENVIRONMENT TO WORK WITH AND WE MADE IT A
SUFFICIENTLY COMFORTABLE ENVIRONMENT THAT THE
ALTERNATE TITLE FOR THIS TALK WAS "WE
ACCIDENTALLY HAD AN OPERATING SYSTEM."
SO WITH THAT, YOU KNOW, THE BIG -- LET ME START
WITH THE PUNCH LINE.
WE PORTED PYTHON TO RUN IN THE GRUBE BOOT LOADER,
TO RUN ON BIOS AND EFI FIRMWARE.
SO THAT THEN RAISES A NUMBER OF QUESTIONS, THE
MOST POPULAR OF WHICH TENDS TO BE WHY -- USUALLY
IS YOU HAVE FIXED WITH SOMETHING LIKE WHY WOULD
YOU DO SUCH A THING!!
SO I WANT TO GO INTO THAT, WHAT THE MOTIVATION
FOR THIS IS, WHAT WE USE THIS FOR OTHER THAN AS A
NOVEL PARTY TRICK.
THEN I'LL GO INTO WHAT WE PROVIDE AS PART OF THIS
ENVIRONMENT, BOTH PYTHON ITSELF AND ABOVE AND
BEYOND THAT.
HOW IT WORKS, WHICH IS THE MAIN BULK OF THE TALK,
HOW WE GOT PYTHON RUNNING WITHOUT AN OS.
THEN, PLATFORM APIs THAT WE'VE ADDED ON TOP OF
PYTHON JUST AS YOU WANT ACCESS TO WINDOWS
SERVICES OR LINUX SERVICES, YOU WANT ACCESS TO
THE PLATFORM SERVICES FOR THIS NOT AN OPERATING
SYSTEM.
AND I'M GOING TO BE INCLUDING QUITE A NUMBER OF
DEMOS ALONG THE WAY, JUST SWITCHING OVER AND
RUNNING THINGS WITHIN A VIRTUAL MACHINE TO SHOW
OFF HOW THIS WORKS, THE WHOLE WAY THROUGH.
FIRST OF ALL, WHY WOULD WE DO SUCH A THING IS IN
THE ORIGINAL REASON IS THAT WE WANTED TO TEST
HARDWARE BIOS, ACPI AND EFI.
WE WANTED TO HAVE A NICE, CONVENIENT TEST
ENVIRONMENT FOR POKING AT ALL OF THESE THINGS
WITHOUT HAVING TO WRITE A WHOLE BUNCH OF ONE-OFF
PROGRAMS TO DO TESTS.
THAT WAS THE SECOND REASON, THE TRADITIONAL
APPROACH TO TESTING BIOS OR EFI -- TESTING BYE,
TESTING ACPI, WAS TO WRITE A WOULD YOU KNOW-OFF
TEST PROGRAM USUALLY TARGETING DOS.
THAT ISN'T REALLY A FULL OPERATING SYSTEM,
DOESN'T HAVE ANY PROTECTIONS, YOU CAN POKE
HARDWARE.
WITH CURRENT EFI, THE SAME TENDED TO BE TRUE, YOU
WOULD RUN AN EFI ENVIRONMENT AND RUN A ONE-OFF
TEST PROGRAM.
WE WANTED TO WRITE A SCRIPT WHICH IS MORE FUN.
WE ALSO WANTED TO AVOID WRITING ANY MORE C-CODE
OR FOR THAT MAT THE PREVIOUS INCARNATION OF THIS
ACTUALLY USED GRUB SHELL-LIKE HANK LANGUAGE
TOGETHER WITH A SHELL FUNCTION THAT EVALUATED
C-LIKE EXPRESSIONS WITHIN GRUB SHELL.
WE WANTED TO DO LESS OF THAT, AS WELL.
IN GENERAL, THE MORE SENTENCES I CAN END WITH,
WITHOUT WRITING ANY C-CODE, THE HAPPIER MY LIFE
SFINALLY, WE TURNED OVER TIME THIS TURNED INTO A
NICE EXPLORATORY ENVIRONMENT.
I HAD SOMEONE COMMENT TO ME THEY WERE LOOKING FOR
TO THIS ONE BECAUSE IT BROUGHT BACK SOME OF THE
FUN OF HACKING ON A COMMODORE 64 OR A DOS
ENVIRONMENT WHERE YOU CAN PEEK AND POKE THINGS.
AND YOU CAN'T REALLY DO THAT ON MODERN HARDWARE
ANYMORE.
SO WE'VE SAID WHY.
BUT WHAT AGENCY ARE WE PROVIDING HERE?
THIS RUNS ON A FEW DIFFERENT TARGET PLATFORMS,
RUNS ON BIOS IN 32 BIT, IFI IN EITHER 32 BIT OR
64 BIT.
SO EFFECTIVELY PC HARDWARE WITH WHATEVER KIND OF
FIRMWEAR YOU MIGHT BE RUNNING, THIS WILL RUN.
IT'S CPYTHON, I APOLOGIZE IT IS PYTHON 2.7.
THE REASON FOR THAT IS THE TARGET AUDIENCE FOR
THIS TEST SUITE IS VERY FAMILIAR WITH PYTHON 2.7,
USED IN A VARIETY OF OTHER TOOLS LIKE
OPERATING -- HARDWARE SIMULATING ENVIRONMENTS OR
TESTS FRAMEWORKS AND JTAGS AND VARIOUS SIMILAR
TYPES, SO IF THE TARGET AUDIENCE MOVES TO 2.7, WE
WOULD LOVE TO MOVE TO 3 IF WE CAN DO SO.
WE HAVE A FULL INTERACTIVE PREDEVELOPMENT PRINT
LOOP, SO TYPE AN ARBITRARY COMMAND, TAB-COMPLETE
ALL THE INTERESTING FUNCTIONS, FILLING HISTORY AN
LINE EDITING AVAILABLE AND WE HAVE A PRETTY
SUBSTANTIAL FRACTION OF THE STANDARD PYTHON
LIBRARY, AS WELL.
SO ON TOP OF THAT, WE HAVE SOME ADDITIONAL
MODULES FOR THINGS LIKE PLATFORM SUPPORT.
WE HAVE WAYS TO ACCESS THE FUNCTIONS OF YOUR CPU,
REGISTER CPUI. D.THAT KIND OF THING.
WE HAVE SMP SUPPORT SO YOU CAN RUN THINGS ON
CPUs THAT YOU DIDN'T BOOT ON.
WE HAVE ACPI SUPPORT SO YOU CAN EXPLORE THAT PART
OF YOUR FIRMWARE AND WE HAVE EFI SUPPORT IF
YOU'RE RUNNING THAT PLATFORM.
SO FINALLY, ON TOP OF ALL THAT, WE HAVE A TEST
SUITE AND A BUNCH OF EXPLORATORY TOOLS ALL OF
WHICH WE WERE ABLE TO WRITE IN PYTHON, WHICH IS
GREAT.
SO LET'S START WITH THE FIRST BUILT OF DEMO.
I HAVE A PYTHON PROMPT RUNNING INSIDE A VIRTUAL
MACHINE.
AND I'VE GOT THE FULL POWER OF PYTHON HERE.
I CAN DO LIST COMPREHENSIONS, FOR EXAMPLE.
AND I'VE GOT BIG NUMBS, SO FULL POWER OF PYTHON
AVAILABLE ON YOUR PROMPT.
BUT THAT'S NOT THE ONLY THING WE CAN DO.
SO LET'S TALK A LITTLE BIT ABOUT HOW WE GOT THAT
FAR, THOUGH.
SO IN OF CPYTHON, THERE'S ONE FUNCTION, SHOW THE
PROMPT, READS, DO LINE EDITING, HANDLE ALL OF
WHAT YOU'RE TRYING TO DO, PROCESS, RUN AND
EVALUATE YOUR OPERATION, KEEP STATE AND THAT'S
WHAT YOU DO WITH PI RUN INTERACTIVE LOOP.
THE FIRST STANDARD IN HERE IS JUST WHERE DO I GET
MY INPUT FROM.
AND THE QUOTED STANDARD IN IS WHAT YOU SEE IF YOU
GET AN EXCEPTION THROWN, YOU'LL SEE IN THE TRACE
BACK, LINE X OF STANDARD IN, AND THAT WILL BE THE
LAST ITEM IN YOUR TRACE BACK AND YOU MIGHT HAVE A
FUNCTION THAT YOU CALLED FROM SOME OTHER MODULE
BUT AT THE TOP LEVEL, YOU'RE TYPING AT THIS FILE
NAME STANDARD IN.
BUT THAT'S THE FUNCTION THAT WE CALL, THAT'S THE
ONE FUNCTION THAT WE WANTED TO RUN AT THE TOP
LEVEL.
WHAT DID WE DO TO GET THERE?
WELL, FIRST OF ALL, WE COULDN'T ACTUALLY USE
PYTHON'S CONFIGURE AND MAKE.
AUTOCOMP IS PORTABLE, RUNS ON A LOT OF PLATFORMS
BUT THE REASON WE COULDN'T GO THAT ROUTE IS WE'RE
BUILDING USING A HOST LINUX TOOL CHAIN, USING
JCC, BUILDING AND TARGETING THE SAME THING THAT
GRUB DOES.
SO IN PARTICULAR WHAT WE DON'T HAVE IS THE
CLASSIC CPU TRIPLE VENDOR YOU WOULD SEE FOR WHAT
IS MY TARGETS OPERATING SYSTEM, LIKE I-386 PC
LINUX GENU.
WE DON'T HAVE THAT SO WE CAN'T TARGET GRUB AND
BUILD PYTHON WITH CONFIGURE AND MAKE, AND WE
DON'T THAT HAVE TOOL CHAIN POINTING AT TARGET
HEADERS FOR GRUB IN ORDER TO RUN IN OUR
ENVIRONMENT.
SO INSTEAD, WHAT WE DID WAS ADDED ALL OF THE
PYTHON SOURCE FILES THAT MAKE UP THE PYTHON
DISTRIBUTION, WHAT YOU WOULD NORMALLY HAVE IN THE
MAKE FILE.
WE PUT A LIST OF THOSE INTO THE GRUB BUILD
SYSTEM, SAYING HERE'S ALL THE THINGS YOU NEED TO
MAKE UP PYTHON AND ALL THE EXTEND END SEES OF
PYTHON, A LIST OF C FILES.
OKAY.
AND THEN WE MANUALLY WROTE OUT THE CONFIGURATION
FILE, FILE CONFIG.8.
THIS IS THE FILE THAT AUTO O.COMP AND HEADER
WOULD WRITE OUT THAT TELLS YOU I HAVE THIS
FEATURE OR I DON'T EVER THIS FEATURE.
SO WE HAVE A LONG LIST OF NO, I DON'T HAVES, AND
A HANDFUL OF YES, WE DO HAVE THIS, FOR WAYS THAT
PYTHON NEEDS TO WORK AROUND SHORTCOMINGS OF THE
OPERATING SYSTEM.
WE DON'T HAVE AN OPERATING SYSTEM SO WE DON'T
HAVE A LOT OF THOSE FUNCTIONS, BUT ANYTHING THAT
PYTHON REQUIRES TO RUN AND A HANDFUL OF THE
OPTIONAL ITEMS WE ADDED.
AND THEN WE HAVE TO PROVIDE THOSE FUNCTIONS THAT
PYTHON EXPECTS.
SO WHAT KIND OF FUNCTIONS ARE THOSE, WHAT DO YOU
NEED TO REALLY RUN A CPYTHON?
A COUPLE OF EXAMPLES.
TURNS OUTS YOU NEEDS SOME NON-TRIVIAL FILE
OPERATION HE IS TO RUN PYTHON.
YOU NEEDS THINGS LIKE STATS OR -- IN ORDER TO
FIND OUT, OH, IS THIS A DIRECTORY THAT MIGHT
CONTAIN AN INCHIN.PI OR FOOD.PI.
YOU NEED TO KNOW IF IT IS A TEMP NATURAL, A TTY,
AND WE HAVE A SIMPLE IMPLEMENTATION OF THIS, IF
FILE SCRIPTER LIST THAN 3, YES, I'M TTY.
WE HAVE SEEK, WHICH THE GRUB FILE LAYER DIDN'T
HAVE AN L-SEEK FUNCTION SO WE ADDED ONE FOR
COMPATIBILITY AND IN ORDER TO SUPPORT ALL THESE
FILE SCRIPTERS, WE NEEDED A FILE DESCRIBER TABLE,
HERE, HAVE AN INTEGER THAT CORRESPONDENCE TO A
FILE.
GRUB'S LAYERS LIKE LIKE THE C-STANDS AROUND
I.-- LAYER, AND THAT WAS EASY TO SUPPORT.
BUT TO HANDLE SMALL INTEGER FILE DESCRIPTORS, WE
HAD TO WRITE OUR OWN TABLE.
THIS WAS ACTUALLY WHY IT TOOK SOME TIME TO IMPORT
64-BIT BECAUSE WHEN THEY WERE 32 WE POINTED THE
POINTER TO A BAD IT.
BAD US.
THERE IS A LOT OF OTHER THINGS WE HAD TO ADD.
TURNS OUT WE -- PYTHON WANTS UNGITSYNC.
PLEASE PUT THIS STANDARD CHARACTER BACK.
USES THAT AS PART OF THE PARSERS, SO WE WROTE --
RATHER THAN ADDING A ONE-CHARACTER BUFFER, WE
ADDED A QUICK HACK THAT SAYS PYTHON ALWAYS UNGETS
THE CHARACTER IT JUST GOT SO SEEK BACKWARD BY
ONE.
WE NEEDED A QSORT IMPLEMENTATION AND GRUB DIDN'T
HAVE ANY SORT FUNCTIONS SO WE ENDED UP HAVING TO
OPEN-CODE THAT.
WE NEEDED FLOATING POINT MATH BECAUSE PYTHON DOES
HAVE FLOAT TYPES AND I CAN DO A QUICK DEMO OF
THAT, AS WELL, IF I DO 2.5 TIME PLEA, WE HAVE
FLOATING POINTS.
WE NEEDED THAT, GRUB HAD NONE OF THAT, SO IT
TURNS OUT THERE IS AN OPEN SOURCE PERMISSIVELY
LICENSED LIB M IMPLEMENTATION FOR ALL THE MAJOR
MATH FUNCTIONS THAT IS AVAILABLE, IT DOES PURE
SOFTWARE, CALLED FDLIBIN'.
DOESN'T HAVE ANY HARDWARE ACCELERATION.
WE CONSIDERED THAT TO BE A BIT OF A FEATURE
BECAUSE IT DOESN'T REQUIRE THE REST OF THE
FIRMWARE TO HAVE PROPERLY INITIALIZED FLOATING
POINT SUPPORT.
IF YOU TRY TO USE FLOATING POINTS, IF THE
FIRMWARE HASN'T INITIALIZED, YOU WOULD END UP
BREAKING SO THAT'S GREAT.
WE ALSO NEEDED PRINTS F, S PRINT OF, PYTHON USES
THOSE.
FOR THE MOST MART, WE COULD USE GRUB'S
IMPLEMENTATION OF THESE FOR SOME OF THE BASIC
FUNCTIONALITIES BUILT WHICH HAD TO EXTENDS IT FOR
A FEW THINGS THAT GRUB DIDN'T KNOW HOW TO HANDLE.
SO, FOR EXAMPLE, IT DIDN'T HAVE THE PERCENT
PERCENT ESCAPE TO PUT A PERCENT IN THE FINAL
STRING AND PYTHON USES THIS TO CREATE A FORMAT
STRING AND THEN RUN THAT BACK THROUGH PRINT F,
WHEN YOU HAVE * WHENEVER YOU USE THE PERCENT
OPERATOR ON THE PYTHON COMMAND LINE SO UNTIL WE
FIGURED OUT WE DIDN'T HAVE THIS, WE HAD SOME VERY
INTERESTING BUGS.
SO APART FROM THAT, WE ALSO WANTED TO WORK
THROUGH A HANDFUL OF INTERESTING PERFORMANCE
ISSUES.
SO AT -- WHEN NOT TOO LONG AGO, WE FOUND OUT THIS
TOOK A SURPRISINGLY LONG TIME TO BOOT AND THAT'S
PAINFUL ENOUGH ON REAL HARDWARE, IT WAS EXTRA
PAINFUL IF YOU'RE IN A CPU CIRCUIT SIMULATION
ENVIRONMENT THAT RUNS VERY, VERY SLOWLY.
WE WOULDN'T WANT THIS TO TAKE THREE DAYS TO BOOT.
SO WHAT WE -- PART OF THIS COMES BECAUSE THE
PYTHON PARISSER IS FAIRLY INTRICATE, READS READ
CHARACTER BY CHARACTER, USES GITSYNC, GRUB HAS
VERY FULL DISK CACHES, SO WE USED BYTE SUPPORT.
WE BUILT AN EXTRA COPY OF PYTHON ON OUR HOST
SYSTEM AS PART OF THE BUILD SYSTEM, USED TO THAT
BYTE COMPILE INTO PI C FILES, AND THEN IT TURNS
OUT GRUB DOESN'T HAVE MODIFICATION TIME SUPPORT
BUT WE KNOW WE ALWAYS HAVE THE PI C FILES THAT WE
JUST BUILT SO WE ZERO OUT THE MTIME IN THE FILES
WHICH MATCHES THE ZERO FEEDBACK FROM OUR
IMPLEMENTATION.
YES, IT'S UP-TO-DATE.
SILL A LITTLE SLOW BECAUSE ON A LINUX SYSTEM YOU
EXPECT STAT TO TAKE MICROSECONDS AND OURS TAKES
MILLISECONDS BUT IT'S STILL FASTER FORWARD ADDING
THAT SUPPORTS.
SPEEDING IT UP FURTHER, WE CAN USE ZIP IMPORT,
ZIP UP THE BYTE CODES AND IMPORT IT THAT WAY AND
WE DO ONE BIG CONSISTENT READS OFF DISK SO WE ADD
THE Z-LIB SUPPORT NEEDED TO RUN ZIP SUPPORT.
APART FROM THAT, WE ALSO WANTED HISTORY, WE
WANTED COMPLETION, LINE EDITING, AND SO NORMALLY
YOU DO THIS WITH THE READ LINE LIBRARY, BUT THAT
DEPENDS ON POSIX AND DETAILS OF HOW TO RUN A
TERMINAL.
WE DON'T HAVE A DEV TTY OR PTC AREA LAYER, WE
DON'T HAVE THE USUAL HIGH OCTALS TO RUN THAT KIND
OF THING AND WE DIDN'T WANT TO RUN A PILE OF
C-CODE THAT WE FRESHLY WROTE TO SOLVE THIS
PROBLEM BECAUSE THAT'S WHAT WE'RE TRYING TO GET
AWAY FROM, WE WANT TO WRITE MORE PYTHON.
SO INSTEAD WE KIND OF HAD A SNAKE EATING ITS OWN
TAIL HERE AND WE WROTE PYTHON'S OWN WRITING IN
PYTHON.
TO DO THAT, WE IMPLEMENTED THE LINE EDITING, THE
COMPLETION IN THE PURE PYTHON AND IN C, IN THE
SMALL C STUBS WE HAVE, WE SET THE PI OS FUNCTION
POINTER TO A C FUNCTION THAT USES THE PYTHON API
TO CALL A CALL BACK THAT WAS PREVIOUSLY SET UP.
SO WE CALL IN TO PYTHON, GET THE DATA BACK, FEED
THAT BACK INTO PYTHON, WHICH IS THEN RETURNED TO
THE ORIGINAL PYTHON PROMPT SAYING HERE'S WHAT I
LINE EDITED AND READ.
SO THE MORE BITS THAT WE CAN WRITE IN PURE
PYTHON, EVEN IF THEY WERE INTENDED TO BE WRITTEN
IN C, THE BETTER.
APART FROM THAT, WE ALSO WANTED TO HAVE DYNAMIC
MENUS IN GRUB, SO THAT HAS A LOVELY MENU SYSTEM
SO YOU CAN CHOOSE, DO YOU WANT TO BOOT LINUX OR
WINDOWS OR SOME OTHER VERSION OF LINUX AND WE
WANTED THAT MENU TO DO TEST SUITES.
WHAT TESTS DO YOU WANT TO RUN, OR DO ALL OF THEM,
OR DO THIS EXPLORATORY ACTIVITY OR PULL UP A
PROMPT.
GRUB ALREADY HAS DISK AND FILE SYSTEM PROVIDERS
FOR THINGS LIKE ZERO HARD DISK, CDROM, FLOPPY
DRIVE, SO WE ADDED ONE FOR PYTHON.
THERE IS A GRUB N PYTHON DEVICE THAT WHEN YOU
CALL IT, IT WILL GO READS THE FILE YOU SPECIFIED
BY HANDING THAT TO PYTHON TO VERIFY IT AND
FEEDING THE DATA BACK TO GRUB.
YOU CAN ADD IN ANY MEMORY FILE YOU WANT, LIKE THE
FUSE FILE SYSTEM, AND YOU RUN A GRUB COMMAND.
MY CONFIG FILE IS IN THE PYTHON FILE SYSTEM,
MENU.CFG.
SO EVEN MORE C CODE WE DON'T HAVE TO WRITE.
>> SO APART FROM THAT, THAT'S A LOT OF THE STUFF
THAT WE'VE ADDED TO MAKE THAT INTERFACE WITH GRUB
TO WORK BETTER ON THE SYSTEM.
HOW DO WE HANDLE HARDWARE SPECIFIC FUNCTIONALITY.
WELL, WE WANT TO HAVE THINGS LIKE CPU I.D.,
MEMORY MAPPED IO, IO PORT SO WE DID THAT BY
ADDING A NEW MODULE CALLED BITS.
SO I CAN SHOW THAT OFF A LITTLE BIT, AS WELL.
LET ME IMPORT BITS AND RUN -- I'M ALSO GOING TO
NEEDS THE C-TYPES MODULE WHICH I'LL EXPLAIN IN A
BIT IN ORDER TO GO TALK TO LITTLE PIECES OF REAL
HARDWARE.
NOT BECAUSE WE'RE CALLING IF YOU THINKS FROM
THERE YET BUT BECAUSE WE NEED TO MANIPULATE RAW
MEMORY IN WAYS THAT YOU WOULDN'T NORMALLY WANT TO
DO ON A LIVE HOSTED SYSTEM.
SO I'M GOING TO CALL CPU I.D. ON CPU ZERO AND GET
THE NUMBER ZERO AND THAT GIVES YOU A CPU
I.D. RESULT WITH THESE PROCESSOR REGISTERS, SO,
FIRST OF ALL, HOW FUN IS THAT?
GETTING PROCESSOR REGISTERS FROM PYTHON AND THEN
I CAN INTERPRET THAT RESULT, THE LAST THREE
REGISTERS THERE ARE AN IDENTIFIER OF WHAT CPU I
RUN ON.
I CAN SET UP A BUFFER OF THREE 32s AND THAT IS
C.PDB, .EDX IN THAT ORDER AND THEN PART OF THE
REASON I NEED C-TYPES IS SO I CAN REINTERPRET
THAT IN A DIFFERENT WAY AS A C-CHARACTER ARRAY, A
12-CHARACTER STRING FROM THAT SAME BUFFER, AND
WHAT'S THAT VALUE?
THAT'S THE PROCESSER I'M RUNNING ON.
SO GOING OFF AND DOING A CPU I.D. INSTRUCTION
FROM PYTHON.
A C-FUNCTION UNDERNEATH TO DO CPU I.D. BUT I
DON'T HAVE TO ASSEMBLE THE RESULT FROM ANYTHING
BUT PYTHON.
SO BACK TO THE PRESENTATION.
ANOTHER ONE, I MENTIONED ON CPU0.
WE WANT TO TEST HIGHLY PARALLEL SYSTEMS WE, DON'T
CRUST WANTS TO TEST THE CPU BOOTED ON, GRUB ONLY
KNOWS ABOUT THE CPU YOU BOOTED ON SO WE NEED TO
GO COLLECT AND MODIFY STATE ON ANY RANDOM CPU.
SO WE WAKE UP EVERY CPU AT RUN TIME WHICH GRUB
DOESN'T DO, PUT THEM INTO A SLEEPING LOOP USING
MWAY AND SAY, OKAY, SIT THERE AND WAIT FOR ME TO
HAVE WORK FOR YOU.
AND THEN WE HAVE A FEW C FUNCTIONS THAT JUST SAY,
GO WAKE UP THAT CPU, RUN THIS INSTRUCTION ON IT
AND GET BACK TO ME WITH THE RESULT.
AND THEN WE BIND ALL THOSE FUNCTIONS TO PYTHON.
SO THE NICE THING IS THAT THEN WHEN WE COLLECT
ALL THOSE RESULTS, PYTHON'S GREAT DATA STRUCTURES
GIVE US THE ABILITY TO CORRELATES THOSE RESULTS,
LIKE IF I RUN CFI I.D.ON EVERY ONE BUT 0, IT HAD
THIS RESULTS AND 0 HAD THAT RESULT.
THAT HE THAT'S INTERESTING.
SAME THING WITH MSR, SAME THINGS WITH MEMORY READ
FROM DIFFERENT PROCESSORS, YOU GET CORRELATING
RESULTS THAT ARE HARD TO PUT TOGETHER AND SEE
BECAUSE OF LACK OF BASIC DATA STRUCTURES.
APART FROM THAT, WE WANTED TO TALK TO YOUR ACTUAL
FIRMWARE, NOT JUST THE HARDWARE BUT FIRMWARE
LAYER.
IN PARTICULAR, THERE'S ACPI, THE ADVANCED
CONFIGURATION POWER INTERFACE.
THAT IS WHAT YOU USE TO FIND HARDWARE ON MODERN
SYSTEMS, TO FIND OUT HOW TO PUT YOUR CPU TO SLEEP
OR YOUR WHOLE SYSTEM TO SLEEP.
IT HAS A BUNCH OF STATIC DATA TABLES AS WELL AS
BYTE METHODS, AND WE WANTED TO DRIVE THIS FROM
PYTHON, NOT FROM C, SO WE PULLED IN THE REFERENCE
IMPLEMENTATION OF ACPI C.A., WE PUT THAT IN BITS
AND HANDLED ITS PORTABILITY ISSUES, AS WELL.
THAT IS A C-LIBRARY AND WE ADDED PYTHON BINDINGS
TO IT.
IN PARTICULAR, IT'S POSSIBLE TO EVALUATE AN
ARBITRARY APCI METHOD, FEED IT ARGUMENTS FROM
PYTHON, THEY GET CONVERTED TO ACPI, GO CALL AND
INTERPRET THE BYTE KIDS METHOD, FEED THE RESULT
BACK TO PYTHON AND, AGAIN, NO EXTRA C-CODE
INVOLVED.
SO LET'S DO A QUICK DEMO OF THAT.
I CAN GO IMPORT ACPI.
AND I CAN DUMP EVERY METHOD ON MY SYSTEM THAT HAS
THE HARDWARE IDENTIFIER NAME SO GO FIND ME ALL MY
HARDWARE AND WHAT MAGIC NUMBER IT HAS FOR WHAT
THE KIND OF HARDWARE THIS IS AND YOU CAN SEE THAT
WE'VE GOT THINGS LIKE A COUPLE OF SERIAL PORTS, A
FLOPPY DISK CONTROLLER, A PS2 KEYBOARD AND MOUSE
ALL PROVIDED BY THIS VIRTUAL MACHINE AND THEY
HAVE DIFFERENT IDENTIFIERS, THIS ONE IS THE
I.D. OF A SERIAL PORT AND BOTH OF THEM HAVE THE
SAME I.D., SO THIS IS HOW YOUR MODERN LINUX
SYSTEM OR MODERN WINDOWS SYSTEMS FINDS THE
HARDWARE ON YOUR SYSTEM.
HERE'S HARDWARE, HERE'S ITS I.D.
SO I'M NOT GOING TO GO INTO GREAT DETAIL ABOUT
HOW TO EXPLORE HARDWARE, I'VE GIVEN TALKS ABOUT
THAT ELSEWHERE.
THE FOCUS OF THIS IS HOW WE MADE THIS WORK AND
HOW WE GOT THIS WORKING WITH FIRMWARE.
SO THE NEXT ITEM I WANT TO GO INTO IS EFI.
SO ON SYSTEMS THAT AREN'T JUST RUNNING BASIC BIOS
BUT RUNNING THE EXTENSIVE FIRMWARE INTERFACE, YOU
WANT SOME ABILITY TO CALL THE FUNCTIONS THAT
PROVIDES AND EXTENSIBLE HERE IN EFA MEANS THAT
EVERYTHING IS A PROTOCOL, IF YOU'RE FAMILIAR WITH
COM ON WINDOWS, THIS WAS SOMEWHAT INSPIRED BY
THAT.
LET ME GO GET THIS INTERFACE, CALL ALL THE
FUNCTIONS THAT IT PROVIDES, AND THOSE ARE ALL
NATIVE C FUNNELS USING A CALLING CONVENTION
PROVIDED BY C, SO LET'S TAKE A LOOK AT WHAT THAT
WOULD LOOK LIKE.
I CAN GO IMPORT THE EFI MODULE, WHICH ONLY EXISTS
SINCE I'M BOOTED VIA EFI AND I CAN GET A METHOD
FROM THE SYSTEM TABLE PROVIDED TO EFI APPS WHEN
THEY START UP.
IN PARTICULAR, A CONSOLE METHOD.
I CAN GET THE ACTUAL STRUCTURE OF THAT SINCE
THAT'S A POINTER, C-TYPE'S CONVENTION FOR
REFERENCING A POINTER SO NOW I HAVE AN OUTPUT
INTERFACE.
AND I CAN CALL METHODS LIKE CLEAR SCREEN, AND
PASS THAT INTERFACE AND CLEAR THE SCREEN BY
CALLING A FIRMWARE FUNCTION FROM PYTHON.
OR I COULD OUTPUT A FAMILIAR GREETING...
AGAIN, USING FIRMWARE FUNCTIONS, NOT USING
PYTHON.
SO HOW THAT ACTUALLY WORKS, C-TYPES IS AN
INTERFACE TO CALL C-TYPES AND C-FUNCTIONS FROM
PYTHON.
AND LIB FFI IS THE FOREIGN FUNCTION INTERFACE
LIBRARY THAT'S BUILT ON THAT ACTUALLY IMPLEMENTS
THE CALLING CONVENTIONS SO IT'S WHAT SAYS THAT IF
YOU WANT TO CALL A FUNCTION, THEN THIS ARGUMENT
IS IN THIS REGISTER THIS ONE HERE THE REMAINING
ARGUMENTS ARE PUSHED ON THE STACK IN THIS ORDER,
HERE'S HOW TO CLEAN IT UP.
AND IT IMPLEMENTS ALTHOUGH PLATFORM SPECIFIC
FUNCTIONALITY SO THAT PYTHON AND C-TYPES DON'T
HAVE TO.
SO WE PORTED LIB FFI TO LIVE INSIDE THE GRUB
ENVIRONMENT AND WE ADDED SUPPORT FOR THE EFI
CALLING CONVENTION WHICH IS DIFFERENT ON 32-BIT
AND 64 BIT, ON 32-BIT, IT IS THE STANDARD CALL
CONVENTION USED ON WINDOWS AND ON 64-BIT, IT'S
THE WINDOWS 64-BIT CALLING CONVENTION WHERE YOU
PASS A PILE OF ARGUMENTS IN REGISTERS.
SO ONCE WE ADDED THAT SUPPORT, WE CAN NOW DECLARE
AN EFI FUNCTION AND AN EFI FUNCTION PROTOCOL FULL
OF FUNCTIONS ENTIRELY IN PYTHON USING THE C TYPE
LANGUAGE, CALL THEM FROM PURE PYTHON AND WITHOUT
WRITING A SINGLE LINE OF C-CODE TO CALL IN
ARBITRARY FIRMWARE FUNCTION.
SO WHAT KINDS OF THINGS CAN WE DO WITH THIS
BEYOND JUST HELLO WORLD, THAT KIND OF THING.
WE'VE GOT A BINDING FOR THE EFI FILE LAYER THAT
USES EFI FILE PROTOCOL AND THE NICE THING ABOUT
THIS, UNLIKE GRUBS FILE ERRORS, IT KNOWS HOW TO
MAKE -- TO WRITES TO A FILE SYSTEM AND NOT JUST
READ IT.
SO WE CAN DO THINGS LIKE THIS, GO GET THE BOOT
FILE SYSTEM, MAKE A DIRECTORY IN IT, CREATE A
FILE IN THAT DIRECTORY, AND WRITE SOME CONTENTS
TO THAT.
WE CREATED A FILE-LIKE OBJECT ON TOP OF THIS
INTERFACE THAT GIVES YOU ALL THE STANDARD THINGS
YOU EXPECT FROM A PYTHON FILE.
ON TOP OF THAT, HOW ABOUT GRAPHICS?
WE'VE DONE TEXT BUT THERE IS AN EFI GRAPHICS
OUTPUT PROTOCOL THAT GIVES YOU FUNCTIONS TO READ
AND WRITE THE CONTENTS OF THE SCREEN.
SO WHAT KINDS OF THINGS MIGHT WE DISPLAY WITH
THIS ONE?
WELL, IT TURNS OUT PRESENTATION SLIDES ARE
GRAPHICS, SO WHEN I SAID THERE ARE DEMOS
THROUGHOUT THIS TALK, I SHOULD ALSO SAY THIS
ENTIRE TALK IS A DEMO AND IT'S ALL RUNNING INSIDE
OF THIS ENVIRONMENT.
[ Applause ]
THANK YOU.
SO IN PARTICULAR, EVERY TIME IT LOOKED LIKE I WAS
DOING AN ALT TAB BACK AND FORTH BETWEEN A PYTHON
WINDOW AND THIS, I WAS HITTING ESCAPE TO GET OUT
OF MY PRESENTATION AND A HOT KEY THAT BINDS INTO
OUR READ LINE LAYER TO JUMP BACK TO THE
PRESENTATION.
AND LOOKS A LOT LIKE I'M SWITCHING BUT IT'S ALL
RUNNING IN THE SAME APPLICATION, WITHOUT AN
OPERATING SYSTEM AND IMENTIRELY USING EFI
GRAPHICS PROTOCOL.
NO NEW C-CODE, NOT A SINGLE LINE.
SO WITH THAT, THE -- ONE LAST DEMO I WANT TO GIVE
SINCE I DO HAVE A MOMENT OF TIME, IS IF I CAN DO
GRAPHICS, WHO HERE REMEMBERS THE FUN OLD DAYS OF
COMMODORE 64, OF DOS, WHERE YOU COULD PEEK AND
POKE HARDWARE AND ESPECIALLY YOU COULD GET A RAW
POINTER TO THE SCREEN AND START SCRIBBLING ON IT
AND DRAWING.
ANYBODY?
AWESOME.
LOTS OF HANDS.
LET'S DO SOME OF THAT.
SO LET'S GET A POINTER TO THE FRAME BUFFER, WHICH
EVERY COLOR HAPPENS TO BE A 32-BIT VALUE IN BGR
DATE ORDER, FOR WHATEVER REASON.
I HAVE AN 800 BY 600 DISPLAY, SO I'LL CREATE A
GIANT TWO-DIMENSIONAL ARRAY.
I'LL PUT -- GO GET THAT FROM BITS.PRESENT, WHICH
IS ALREADY INITIALIZED GRAPHICS FOR ME.
THE GOP INTERFACE, GRAPHICS OUTPUT PROTOCOL, GO
GET THE VIDEO MODE STRUCTURE AND DE-REFERENCE IT
AND GO GET FRAME BUFFER BASE, WHICH TELLS YOU THE
EQUIVALENTS HERE WOULD BE GO CREATE A POINTER TO
C-BILLION OR A BILLION IN DOS WHERE A VIDEO
MEMORY HAPPENS TO LIVE.
WELL, HERE'S WHERE IT LIVES.
SO HERE'S MY FRAME BUFFER, LET'S DO A QUICK LOOP
AND OUTPUT SOME THINGS.
I'LL CREATE A 400 BY 400 IMAGE TO GET IT
SOMETHING BIG ENOUGH TO SEE WITHOUT TAKING TOO
LONG.
AND I'LL DECLARE A COUPLE OF BITS OF MATH HERE TO
BUILD SOMETHING INTERESTING.
DOING SOME SCALING TO MAKE IT 400 BY 400.
AND I'LL DO A LITTLE BIT OF ITERATIVE MATH.
25 ITERATIONS OUGHT TO BE ENOUGH.
LET'S ITERATE.
AND THE OTHER COMPONENT.
I HEAR SOME LAUGHTER FROM THE PEOPLE WHO
RECOGNIZE WHAT I'M DOING.
LET'S CHECK THE MAGNITUDE.
AND LET'S DRAW SOME COLOR.
BUT IT UP IN THE UPPER RIGHT CORNER.
ASSIGN IT AN APPROPRIATE COLOR.
DISTRIBUTE IT TO ALL THREE COMPONENT AND DRAW.
WE HAVE FRACTILES IN PYTHON VIA GRAPHICS
PROTOCOL.
[ Applause ]
>> AND WITH THAT, ANY QUESTIONS?
ALL RIGHTY.
THERE'S A MIC RIGHT THERE IN THE CENTER IF YOU
WANT TO BE AUDIBILITY.
>> AUDIENCE:  THAT IS LOUD.
YOUR FFI PORTS, DID YOU RUN INTO ANY PARTICULAR
STRUGGLES IMPORTING THAT TO THE EFI ENVIRONMENT
FOR ANY MEMORY MANAGEMENT OR POINTER HANDLING OR
THE LIKE?
>> SO MEMORY MANAGEMENT AND POINTER HANDLING IS
ACTUALLY ALMOST EXCLUSIVELY HANDLED BY C-TYPES
AND WE DIDN'T HAVE TO DO ANYTHING SPECIAL TO MAKE
THAT WORK.
THE NON-TRIVIAL EFFORT INVOLVED WAS ACTUALLY
PORTING LIB FFI ITSELF TO UNDERSTAND THE CALLING
CONVENTION USED BY EFI.
SO IN PARTICULAR, LIB FFI UNDERSTANDS HOW TO CALL
WINDOWS FUNCTIONS ON WINDOWS AND HOW TO CALL
LINUX IF YOU THINKS ON LINUX.
IT HAD NO IDEA HOW TO CALL WINDOWS FUNCTIONS ON
WHAT WE'RE PRETENDING IS A POSIX SYSTEM AND THAT
LAYER WAS NON-PORTABLE SHE IT ONLY RAN ON
WINDOWS, SO WE ENDED UP WRITING ABOUT 50, 75
LINES WORTH OF EXTRA CODE TO PORT THAT OVER,
INCLUDING SOME X-86 AND X-6866 ASSEMBLY CODE TO
MAKE THAT WORK IN BOTH PLAT FORAGES AND IT WAS
ONE OF THOSE CASES WHERE IT WAS ABOUT A WEEKEND
WORTH OF WORK TO RIGHT THE 55 LINES OF CODES AND
DEBUG IT BUT ONCE WE HAD THAT WORKING, V-TYPES
WAS REALLY TRIVIAL.
>> AUDIENCE:  GOTCHA.
THANK YOU.
>> AUDIENCE:  IS THERE ANY WAY TO HANDLE
INTERRUPTS?
>> SO, RIGHT NOW, WE DON'T HAVE A HOOK FOR THAT.
WE COULD EASILY ADD THAT ONE.
THAT WOULD EFFECTIVELY BE, LET'S WRITE A SMALL
HANDFUL OF LINES OF ASSEMBLY TO BUILD THE --
ACTUALLY, I TAKE THAT BACK.
LET ME COVER -- LET ME COVER ONE ITEM THERE.
YOU COULD ACTUALLY WRITE TO THE INTERRUPT
DESCRIPTOR TABLE EASILY ENOUGH AND YOU COULD USE
C-TYPES TO CREATES A FUNCTION THAT IS CALLABLE
FROM THAT ENVIRONMENT.
THE ONLY REALLY TRICKY BIT THERE IS THAT WITHOUT
A LITTLE EXTRA HELP FROM C, THERE'S NO WAY TO DO
AN INTERRUPT RETURN, SO WE WOULD NEED A COUPLE OF
EXTRA HELPER FUNCTIONS TO MAKE THAT WORK BUT WE
DON'T YET HAVE THEM.
FLIPPING THAT AROUND, WE SHOULD ALSO ADD THE
CLASSIC ENT86 DOS C COMPILER FUNCTION SO THAT YOU
COULD CALL THE SOFT WARE INTERRUPT BUT THOSE
WOULD BE MAYBE, 10, 15 LINES OF CODES AND A
PYTHON BINDING AND WE'RE DONE AND WE WRITE
EVERYTHING THAT USES THAT IN PYTHON.
SO FOR THAT MATTER, I WOULD BE HAPPY TO CHAT WITH
YOU IF YOU WOULD LIKE TO HACK ON THAT AND WORK ON
A PATCH FOR THAT.
A FUN ENVIRONMENT TO HACK ON.
NEXT QUESTION?
>> AUDIENCE:  I WANTED TO ANNOUNCE THAT THE
LIGHTNING TALKS WILL BE STARTING IN A COUPLE OF
MINUTES SO ANYONE WHO HAD SIGNED UP FOR THAT
SHOULD HEAD DOWN BUT WE CAN DO FIVE MORE MINUTES
OF QUESTIONS IN THIS ROOM.
>> AWESOME.
>> AUDIENCE:  REALLY INTERESTING TALK.
THERE IS ANOTHER THING CALLED MIRAGE OS WHICH IS
AN ML MACRO KERNEL, I BELIEVE IT'S CALLED, WHERE
IT'S JUST LIKE ML RUNNING ON A ZION HYPER
ADVISOR.
CAN YOU SEE SOMETHING LIKE THIS DOING THE SAME
THING FOR PYTHON SO YOU COULD RUN A WEB SERVICE
OR SOMETHING?
>> SO, THAT'S A REALLY INTERESTING POINT,
ACTUALLY, SO I AM FAMILIAR WITH MIRAGE OS AND
THERE ARE SEVERAL OTHER KINDS OF JUST ENOUGH OS
OR BARE OS KINDS OF EFFORTS OF, YOU KNOW, IT
WOULD BE DIFFICULT TO DO THAT ON REAL HARDWARE
BECAUSE YOU HAVE TO DRIVE REAL HARDWARE BUT IF
YOU'RE RUNNING IN A VIRTUAL MACHINE, IT'S NOT
THAT HARD TO HAVE A BARE METAL IMPLEMENTATION.
IT TAKES A DECENT AMOUNT OF WORK TO PROVIDE
BINDING BUT FOR PYTHON, WE'RE THERE.
SO IF SOMEBODY WANTED TO EXTEND THIS TO PROVIDE
THAT KIND OF ENVIRONMENT INSIDE A VIRTUAL
MACHINE, IT WOULD ACTUALLY NOT BE THAT HARD TO
DO.
THE NEXT FUN ITEM ON OUR TO-DO LIST, FOR WHAT
IT'S WORTH, IS EFI HAS A TCP/IP PROTOCOL, SO WE
WERE GOING TO PROVIDE BINDINGS TO THAT, MAKE IT
WORK WITH THE PYTHON SOCKET MODULE AND SEE IF WE
CAN'T RUN SIMPLE TCP/IPSERVEER.
SO THEN YOU COULD HAVE A WEB -- TO YOUR FIRMWARE.
SO, YES, BY ALL MEANS, WOULD BE AWESOME.
>> AUDIENCE:  SOUNDS LIKE A LOT OF FUN.
>> NEXT QUESTION.
>> AUDIENCE:  I LOVE THE -- KUDOSFOR THAT.
>> THANK YOU.
>> AUDIENCE:  WHAT'S THE SPEED COMPARISON BETWEEN
RUNNING WHAT YOU JUST DID FOR THIS SET VERSUS
RUNNING PYTHON THROUGH THE NORMALLY NUKES KERNEL?
>> SO, SPEED COMPARISON, IT'S FUNNY, THIS
RENDERED FAIRLY SLOWLY BUT NOT ACTUALLY FOR ANY
REASON HAVING TO DO WITH PYTHON.
THE PYTHON CODE ACTUALLY RUNS AT EFFECTIVELY THE
SAME SPEED AS C-PYTHON DOES ON ANY OTHER PLATFORM
AS LONG AS YOU DON'T TOUCH PLATFORM SERVICES,
THINGS LIKE STAT ARE A LITTLE SLOWER BECAUSE THE
FILE ON THE MY ZAG ISN'T AS OPTIMIZED AS LINUX,
NEVER NEEDED TO BE.
THE REASON THIS IS SLOW IS BECAUSE OF THE LIB FM
LIBRARY, THIS IS SLOW BECAUSE IT USES SOFTWARE
FLOATING POINT.
IF WE WERE TO PROVIDE A VERSION OF LIB M THAT
WOULD PROVIDE FLOATING POINT SUPPORT, THIS WOULD
BE AS FAST AS IT IS UNDER LIE NEXT OR UNDER
WINDOWS.
EVERYTHING ELSE IS REASONABLE SPEED TO WRITE OUT
THE FRAME BUFFER.
IF I WERE TO WRITE OUT, FOR EXAMPLE, PURE BLUE
AND JUST FILL THE WHOLE SCREEN WITH BLUE, ALMOST
INSTANTANEOUS.
SO THAT MUCH IS NOT A BIG DEAL.
THAT'S ALWAYS THE REASON I TYPED THIS OUT BY HAND
RATHER THAN USING THE PYTHON COMPLEX TYPE WHICH
WOULD HAVE MADE THIS BRIEFER AND SIMPLER TO
RECOGNIZE.
THAT MAKES IT SEVERAL TIMES SLOWER BECAUSE,
AGAIN, THE PYTHON COMPLEX LIBRARY DOES A LITTLE
BIT MORE FLOATING POINT MATH THAN IT NEEDS TO,
COMPARED TO THIS OPEN CODED VERSION.
>> AUDIENCE:  THANK YOU.
>> ANY OTHER QUESTIONS?
>>  OKAY.
LOOKS LIKE THAT'S IT.
THANK YOU SO MUCH, JOSH.
>> THANK YOU VERY MUCH.
[ Applause ]
04:24:19