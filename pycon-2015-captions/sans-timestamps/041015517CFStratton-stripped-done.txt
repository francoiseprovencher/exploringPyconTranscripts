MINUTE, SO PLEASE TAKE YOUR SEATS.
IT'S 2:35 P.M., AND TIME TO GET STARTED.
OUR NEXT SPEAKER, FRANK STRATTON, LIKES ROCK
CLIMBING AND DEVELOPER TOOLS.
>>  THANK YOU.
THANK ALL OF YOU FOR BEING HERE.
SO MY TALK IS ABOUT SMART SERVICES AND SMART
CLIENTS.
BASICALLY, HOW WE AT BUILD SERVICES AND BUILD
CODE.
I'M FRANK STRATTON, CT AND CO-FOUNDER OF
RUNSCOPE.
I WANT TO TELL YOU ABOUT WHAT RUNSCOPE DOES.
WE BUILD TOOLS TO HELP SOLVE PROBLEMS.
IT'S A WAY TO BUILD TESTS AND MONITORING FOR
APIS.
AND THE IDEA HERE IS THAT YOU CAN CHAIN
TOGETHER IS SERIES OF HTTP REQUESTS INTO A TEST
AND THEN EXTRACT DATA FROM THOSE REQUESTS AND
USE THEM AS VARIABLES IN FOLLOWING REQUESTS.
COME BACK BASICALLY LETTING YOU KNOW THAT APIS
ARE UP AND RUNNING ON THE CRITERIA.
YOU CAN WRITE ASSERTIONS ON THE RESPONSES THAT
THE OTHER TOOL WE HAVE IS OUR TRAFFIC
INSPECTOR, WHICH ALLOWS YOU TO CAPTURE INFLIGHT
HTTP REQUESTS, AND IT GIVES YOU THIS REAL-TIME
STREAM TO HELP YOU DEBUG BETWEEN YOUR CLIENT
AND THE APIS THAT YOU'RE USING.
TIMING INFORMATION AND ALL THAT KIND OF STUFF.
THE TOOLS THAT WE BUILD TO DO THAT, WE HAVE
OVER 60 SERVICES NOW THAT ARE INDEPENDENTLY
DEPLOYABLE BUT ONLY AN ENGINEERING TEAM OF
EIGHT PEOPLE.
AND KIND OF VERY EARLY ON, WE HAD THIS KIND OF
VERY INTENTIONAL GOAL TO BUILD LOTS OF SMALL
SERVICES.
IN THE LAST YEAR OR SO, THE HOT BUZZ WORD IS
MICRO-SERVICES.
BUT THIS WAS A VERY CONSCIOUS DECISION FOR US.
AND PART OF THAT YOU MIGHT ASK IS WHY.
WHY HAVE ALL THESE MOVING PARTS, ALL THIS
COMPLEXITY EVEN WHEN YOU HAVE JUST A SMALL TEAM
OF TWO PEOPLE OR FIVE PEOPLE OR, YOU KNOW,
EIGHT PEOPLE.
AND SO FOR US, THE ANSWER TO THAT WAS REALLY
ABLE TO HANDLE THE GROWTH OF OUR COMPANY AS WE
GROW AS WELL AS SCALING THE TEAM AND MAKING
ABOUT BOTH SCALING THE INFRASTRUCTURE, BEING
SURE THAT OUR PROCESSES AND OUR WAY OF
DEVELOPING SOFTWARE CAN MAP TO THE TEAMS AND
THE COORDINATION AND THE AMOUNT OF OVERHEAD
THAT COMES WITH GROWTH.
SO A LOT HAS BEEN SAID ALREADY ABOUT
MICRO-SERVICES, WHAT THEY ARE, HOW THEY WORK.
THERE'S A LOT OF GOOD TALKS, A LOT OF GOOD
ARTICLES OUT THERE.
SO THIS TALK IS REALLY -- WE'LL TOUCH ON SOME
OF THOSE THINGS.
BUT REALLY I WANTED TO FOCUS ON KIND OF HOW WE
DO THINGS IN PRACTICE, WHAT TECHNOLOGIES WE
USE, AND HOW WE ORGANIZE OUR CODE TO MAKE ALL
THIS WORK TO A HIGH LEVEL.
ONE OF THE REASONS WE CHOSE THIS ARCHITECTURE
IS THAT MICRO-SERVICES BY DEFINITION ARE HIGHLY
INDEPENDENT SMALL COMPONENTS.
AND FOR US THAT MEANS BOTH INDEPENDENT CODE
BASES, INDEPENDENT DEPLOYABILITY AND HAVING
DIFFERENT TEAMS OWN DIFFERENT PARTS OF THE
STACK WITHOUT HAVING TO COORDINATE WITH EACH
OTHER.
MOVING PARTS.
YOU HAVE A LOT OF DIFFERENT THINGS CHANGING, A
NEEDLESS TO SAY, THAT MEANS THERE'S A LOT OF
LOT OF THINGS BEING SHIPPED TO PRODUCTION ALL
THE TIME, AND IT TAKES A LOT OF WORK TO MAKE
SURE THIS WORKS SMOOTHLY, AND IT DOESN'T FALL
APART.
SO I THINK THE BIGGEST LESSON THAT WE'VE
LEARNED OVER THE LAST TWO AND-A-HALF YEARS FOR
RUNNING MICRO-SERVICES ARCHITECTURE IS THAT IF
YOU DON'T INVEST IN INFRASTRUCTURE, DON'T
INVEST IN MICRO-SERVICES.
ANOTHER WAY OF THINKING ABOUT THIS IS THAT A
MICRO-SERVICES ARCHITECTURE IS TAKING THIS IDEA
OF WHAT A SERVICE-ORIENTED ARCHITECTURE IS AND
APPLYING THAT TO A DEVOPS BENT AND STRUCTURE
TOOLING AROUND THAT TO MAKE THIS ALL POSSIBLE.
TO GET INTO MORE CONCRETE EXAMPLES, KIND OF IN
THE BEGINNING, WE HAD OUR DASHBOARD, WHICH IS
OUR WEBSITE.
AND THEN WE WANTED TO BUILD ANOTHER SERVICE TO
ENCAPSULATE ALL OF OUR CUSTOMER DATA AND GIVE
US A DATA ACCESS LAYER.
SO WE CALL THAT SERVICE IDENTITY.
AND IDENTITY LETS YOU GET THAT ABOUT CUSTOMERS,
GET CONFIGURATION DATA.
AND SO KIND OF IN THIS WORLD WE'VE GOT THESE
ABOUT TEAMS, AND KIND OF JUST GENERALLY PUT AND
TWO SERVICES.
ONE OF THEM IS LIVING ON HOST 001 AND ONE OF
THEM IS LIVING ON HOW DO I ACTUALLY IMPLEMENT
THIS FUNCTION AND GET TEAMS.
SO THE MOST STRAIGHTFORWARD WAY OF DOING THAT
IS HEY WE'LL JUST USE REQUESTS, WE'LL JUST
INPUT REQUESTS, I'LL JUST BUILD A URL TO HOST
TWO/TEAMS AND THEN I'LL DO A GET REQUEST TO
THAT AND RETURN THE JSON THAT COMES BACK.
SO NOW THIS IS CODE AND IT WORKS KIND OF.
SO THE TRICKY THINGS HERE ARE WHEN YOU START TO
TALK, WHEN YOU'RE GOING FROM LIKE A MONOLITHIC
CODE BASE TO THIS SERVICE ORIENTED ARCHITECTURE
IS THAT THINGS ARE ALWAYS CHANGING, HOSTS THAT
YOU HAVE BEEN UP AND RUN SOMETIMES DIE AND YOU
HAVE TO CHANGE AND REPLACE HOSTS.
SO WHAT HAPPENS WHEN YOU MIGRATE FROM HOST TWO
TO HOST THREE.
NOW YOU'VE GOT TO CHANGE YOUR CODE AND DEPLOY
THAT JUST SO YOU CAN ADDRESS THAT IN YOUR
SERVICE.
KIND OF A BIGGER QUESTION HERE IS WHAT HAPPENS
SO IF YOU'VE GOT A LOCAL ENVIRONMENT, A TESTING
ENVIRONMENT, AND A PRODUCTION ENVIRONMENT, ALL
IF YOU HAVE MULTIPLE ENVIRONMENTS.
THOSE THINGS NEED TO TALK TO DIFFERENT HOSTS
WHETHER IT'S YOUR LOCAL HOST, YOUR TEST CLUSTER
OR WHETHER IT'S YOUR PRODUCTION CLUSTER.
SO KIND OF HARD CODING THESE HOST NAMES TURNS
INTO A BIG MESS.
SO WE WANTED TO AVOID ALL OF THAT.
BUT REALLY THE FIRST QUESTION THAT YOU HAVE TO
ANSWER WHEN HAVING ALL THESE SERVICES IS JUST
HOW DO YOU FIND THE SERVICE.
SO OUR ANSWER TO THAT QUESTION WAS SOMETHING WE
CALLED SMART CLIENT.
SMART CLIENT DOES A FEW THINGS.
SO FIRST IT'S A WRAPPER AROUND PYTHON REQUESTS.
SO YOU CAN JUST DROP IT IN WHEREVER YOU USE
REQUESTS AND IT JUST WORKS.
SO IT HAS THE SAME API, AND GIVES YOU THE SAME
RESPONSE OBJECTS.
SO THE NEXT THING INSTEAD OF HARD CODING ALL
THESE DIFFERENT HOST NAMES IN OUR CLUSTER, WE
WANTED TO GO A DIFFERENT APPROACH, AND THAT WAS
TO INVENT SOMETHING CALLED SERVICE URLS.  AND
SO SMART CLIENT ACCEPTS THESE THINGS THAT LOOK
SO IT STARTS WITH SERVICE:// AND THEN THE NAME
OF A SERVICE.
LIKE HTTP URLS BUT AREN'T REALLY.
SO THE NICE THING ABOUT THIS IS THAT THIS
SERVICE URL WORKS IN YOUR LOCAL ENVIRONMENT, IN
YOUR TESTING ENVIRONMENT AND YOUR PRODUCTION
ENVIRONMENT, AND YOU DON'T HAVE TO CHANGE OR
UPDATE ANY OF THE CODE TO MAKE THAT HAPPEN.
SO SMART CLIENT REALLY DOES KIND OF TRANSLATE
THAT SERVICE URL INTO AN ACTUAL SERVICE HOST
NAME AT RUN TIME.
THE NEXT THING IT DOES IS IT WILL DO
AUTOMATICALLY -- IT WILL AUTOMATICALLY RETRY,
GET, PUT, DELETE REQUESTS JUST IN CASE THERE'S
A TEMPORARY NETWORK OUTAGE, OR, IF YOU'RE LOAD
BALANCING ACROSS LOTS OF BACK ENDS, AND ONE OF
THOSE REQUESTS FAILS, IT MIGHT SUCCEED ON THE
NEXT ONE.
THE OTHER THING IT DOES IS IT HAS AN OPTION TO
LET YOU RUN ASYNCHRONOUSLY.
SO IF YOU HAVE LOTS OF CALLS YOU NEED TO MAKE
IN PARALLEL, YOU CAN FIRE THEM ALL AT ONCE AND
WAIT FOR THE RESPONSES TO COME BACK SO YOU'RE
NOT KIND OF BLOCKING AND WAITING FOR EACH ONE
OF THESE IN SERIAL.
WORK, AND WHAT IS THE MECHANISM THAT'S POWERING
ALL OF THIS.
SO NOW THE QUESTION IS HOW DOES THIS ACTUALLY
AND FOR US, THE ANSWER TO THAT QUESTION IS ALSO
A SERVICE.
SO WE HAVE A SERVICE CALLED ATLAS WHICH IF YOU
CAN MAYBE GUESS CONTAINS INFORMATION ABOUT HOW
OUR CLUSTER IS MAPPED.
SO ATLAS STORES INFORMATION IN DYNAMODB AND
ZOOKEEPER, AND WE BASICALLY SAY WHENEVER A NEW
SERVICE IS CREATED, WHENEVER YOU ATTACH A
SERVICE TO A PARTICULAR HOST, WE RECORD THOSE
BITS AS META DATA, AND FOR INSTANCE, IN
ZOOKEEPER, IT STARTS WITH THE HOST NAME AND
WHAT PORT IT'S RUNNING ON, WHETHER OR NOT IT'S
ABLED OR DISABLED AND ALL THAT STUFF.
SO THAT IS REALLY A SERVICE THAT ENCAPSULATES
ALL OF THAT CLUSTER CONFIGURATION.
THE NEXT PART OF THIS IS PYTHON WE CALL SIDE
CAR, AND SIDE CAR RUNS ON EVERY SINGLE HOST IN
OUR CLUSTER AND DOES A FEW DIFFERENT THINGS.
IT RUNS A HAPROXY LOCAL ON THOSE HOSTS, AND IT
CONFIGURES IT BY READING ATLAS, AND THEN IT
DOES THAT BY SETTING UP ZOOKEEPER WATCHER TO
LET YOU KNOW IF YOU'VE DISABLED A HOST OR A
AND THOSE CHANGES WILL KICKOFF A RELOAD OF
HAPROXY.
SERVICE OR ADDED A NEW HOST OR SERVICE.
SO WHAT IN EFFECT HAPPENS IF YOU'VE GOT THIS
CLUSTER OF MACHINES AND SIDE CAR AND HAPROXY
ARE RUNNING ON EACH OF THEM, AND WHENEVER YOU
NEED TO MAKE A SERVICE CALL, YOU'RE ACTUALLY
TAKING THAT SERVICE CALL AND MAKING IT TO A
LOCAL HOST.
AND THAT SERVICE CALL GETS SENT TO SERVICE A
WHEREVER IT'S LIVING IN THE CLUSTER.
AND THEN IF YOU WANT TO ADDRESS SERVICE B, YOU
ADDRESS LOCAL HOST, AND IT GOES OFF TO SERVICE
B.
THAT MAKES THE IMPLEMENTATION OF WHAT IT'S
DOING PRETTY SIMPLE.
IT TAKES THAT SERVICE URL, PARSES OUT OF THE
SERVICE NAME AND THEN USES A CUSTOM HEADER THAT
WE'VE ADDED CALLED RUNSCOPE SERVICE AND PASSES
ON THAT SERVICE NAME.
AND THEN THE ACTUAL REQUEST IS MADE TO LOCAL
HOST AND THEN THE HAPROXY FRONT END BOARD.
SO THE INTERESTING THING WE'RE DOING WITH
HAPROXY, WE'RE ACTUALLY USING A FEATURE CALLED
ACL WHERE YOU CAN DYNAMICALLY ROUTE A REQUEST
REQUEST.
SO HERE, HTTP MODE, AND THEN WE'RE CONSTRUCTING
BASED ON INFORMATION THAT'S COMING IN IN THAT
AN ACL CALLED HOST API AND WE'RE DOING A
PATTERN MATCH ON THAT RUNSCOPE SERVICE HOST
ADDER THAT WE'VE ADDED IN SMART CLIENT.
AND IF IT MATCHES API, WE'RE GOING TO SET THAT
IN THE ACL, AND THEN WE'RE GOING TO USE API
BACK END.
SO WE'VE CONDUCTED ONE STANZA FOR ALL OF OUR
SERVICES AND THEN DYNAMICALLY AT RUN TIME,
BASED ON WHAT IS PRESENT, IT WILL CHOOSE THE
APPROPRIATE BACK ENDS AND THOSE BACK ENDS WERE
CONFIGURED WITH THE CLUSTER FROM ATLAS.
SO THAT MAKES THE IMPLEMENTATION OF THIS REALLY
EASY AND THE BIGGEST BENEFIT THAT WE GOT FROM
DOING IT THIS WAY BECAUSE WHEN WE ORIGINALLY
BUILT SMART CLIENT WE HAD A LOT OF HARD-CODED
SERVICE NAMES AND HARD-CODED PORT NUMBERS AND
LOTS OF INFORMATION THAT WE KNEW, BUT THAT WAS
ALL KIND OF BAKED INTO THE LIBRARY, SO WHENEVER
WE WOULD ADD A NEW SERVICE YOU WOULD HAVE TO
UPDATE THE LIBRARY, DO A NEW BUILD, AND THEN
DEPLOY ALL THE SERVICES THAT USED IT.
MOVING TO THIS HAPROXY DYNAMIC HEADER ROUTING,
AND NOW INSTEAD OF DOING A CODE DEPLOYING TO
PICK UP A NEW SERVICE, IT'S JUST ADDING A NEW
IT'S ALL KIND OF DATA DRIVEN NOW.
LINE AND A DATABASE ESSENTIALLY.
SO THE CODE FOR SMART CLIENT NOW IS PRETTY
STATIC.
WE'VE GOTTEN IT TO A GOOD PLACE AND WE DON'T
HAVE TO DO NEW BUILDS, NEW DEPLOYS JUST TO PICK
UP NEW SERVICES THAT GET ADDED TO THE CLUSTER.
SO THAT'S KIND OF, YOU KNOW, THE FIRST QUESTION
IS HOW DO YOU FIND A NEW SERVICE.
THE NEXT QUESTION WE HAD TO ASK OURSELVES IS,
OKAY, HOW DO I MAKE SERVICE BUILDING REALLY
EASY.
AND OUR ANSWER TO THAT UNSURPRISINGLY WAS
CALLED SMART SERVICE.
SO SMART SERVICE IS A LIBRARY THAT'S BUILT ON
TOP OF FLASK, FLASK-RESTFUL, A FLASK RESTFUL.
WE STARTED WITH THIS BASE AND STARTED ADDING
MORE AND MORE PACKAGES ON TOP OF IT TO KIND OF
BUNDLE TOGETHER A LOT OF COMMON FEATURES AND
FUNCTIONALITY THAT WE FOUND WE NEEDED.
SO ONE OF THEM IS AN OPEN SOURCE PROJECT THAT
WE HAVE CALLED HEALTH CHECK WHICH MAKES IT EASY
TO ADD HEALTH CHECKS TO FLASK APPS.
SET OF EITHER THIRD PARTY PROGRAMMING PACKAGES
OR OTHER INTERNAL SERVICES OR LIBRARIES THAT
THE KIND OF NEXT BIT BUILD ON TOP OF THAT IS A
WE'VE WRITTEN TO DEAL WITH A LOT OF THAT
BOILERPLATE CODE.
SO WE USE BUGSNAG FOR DOING LOGGING.
AND THERE'S COUPLE PRODUCTS WE HAVE CALLED
RUNSCOPE, DAEMON, WHICH MAKES RUNSCOPE TASKS
EASY, AND THEN ALCHEMIST, WHICH IS OUR LIBRARY
FOR DOING DATA COLLECTION AND TEARDOWN.
AND THEN SMART CONFIG, WHICH WORKS TOGETHER
WITH SMART WORKS, WHICH WE WERE DOING FROM THE
BEGINNING DEALING WITH HARD-CODED CONSTANTS AND
HARD KEYS AND OTHER CONFIGURATION THINGS.
WE DUMP THAT INTO A PYTHON FILE AND SAY CONFIG,
RUN ASDB AND RUN THAT ALL THROUGH OUR CODE.
WHEN WE BUILT SMART SERVICE, AND WE WANTED TO
KEEP THAT KIND OF INTERACTION BECAUSE IT WAS
VERY EASY AND VERY PREDICTABLE TO KNOW LIKE,
OKAY, I NEED TO FIND, YOU KNOW, THIS API KEY OR
I NEED TO FIND WHAT DATABASE I'M USING, IT WAS
ALL KIND OF LOCATED IN ONE PLACE.
SO THEN WE BUILT SMART CONFIG, WHICH BASICALLY
LETS YOU LOAD THAT CONFIG MODULE DIRECTLY AS A
SET OF DEFAULTS.
QUERY ATLAS AT RUNTIME AND GET OTHER VARIABLES
AND OVERWRITE THOSE DEFAULTS IF YOU NEED TO.
THE OTHER THING SMART CONFIG DOES IS IT CAN
SO THAT'S REALLY HELPFUL FOR PUTTING SECRET
TOKENS INTO YOUR SOURCE CONTROL AND CHECKING
THOSE INTO GITHUB BECAUSE YOU CAN EITHER EMPTY
PLACEHOLDERS OR NOT SET THOSE IN YOUR SOURCE AT
ALL AND HAVE THAT COME FROM ATLAS VIA SMART
CONFIG.
SO THE OTHER THING HERE IS THAT WE'RE
INITIALIZING SMART SERVICE.
AND THE THING WE GET OUT IS AN APP OBJECT.
AND THAT'S BASICALLY A WRAPPED FLASK APP.
SO IT HAS ALL THE THINGS THAT A NORMAL FLASK
APP HAS ON IT.
BUT BASED ON THE VALUES OF THAT CONFIGURATION,
WE GET A LOT OF EXTRA PROPERTIES ON THAT
OBJECT.
SO YOU CAN ALWAYS NO MATTER WHERE YOU'RE AT IN
YOUR CODE FROM FLASK IMPORT CURRENT APP AND
THEN USE CURRENT APP. REALM, WHICH WILL TELL
YOU AM I IN OUR LOCAL ENVIRONMENT, A TESTING
ENVIRONMENT, IN PRODUCTION.
IT HAS THINGS LIKE IF YOU SPECIFY A RED SDB IN
THAT CONFIG, IT WOULD CONSTRUCT AND PUT A READ
YOU DON'T NEED TO KNOW IF YOU NEED DOES IT MAP
TO, WHERE DO YOU ROUTE THIS REQUEST.
CLIENT ON THE FLASK APP FOR YOU.
AS A DEVELOPER, YOU JUST STATE, OH, YEAH, JUST
IMPORT THE CURRENT APP, GET THE REDSES CLIENT
AND START USING IT.
THE SAME THING IF YOU CONFIGURED POSTGRESQL.
AND THEN IT HAS THE FLASK RESTFUL API OBJECT SO
YOU CAN START ADDING NEW ROUTES TO YOUR
SERVICE.
THE OTHER THING THAT SMART SERVICE DOES IS IT
BUILDS THIS COMMON LOGIN CONFIGURATION.
SO ONCE AGAIN, EVERYTHING IS PRETTY
STANDARDIZED.
WE PUT EVERYTHING IN ONE LOCATION.
WE CAN FIGURE OUR LOG FORMATS ALL AT ONCE, AND
AS A DEVELOPER YOU DON'T HAVE TO THINK HOW DO I
ACCESS THE LOGGER.
THE RIGHT OUTPUT FORMAT OR THE ACCESS LOG OR
THE AIR LOG OR IF I'M USING BUGSNAG TO NOTIFY
AN COMPETITION HAS HAPPENED.
YOU JUST KIND OF IMPORT THOSE THINGS AND JUST
USE THEM.
AND THIS IS KIND OF BUILDINGS CONSISTENCY
ACROSS ALL OF OUR DIFFERENT SERVICES.
WE CAN AUTO GENERATE THESE SERVICE SKELETONS
SINCE ALL OF OUR PROJECTS LOOK THE SAME NOW AND
THE OTHER THING WE HAVE WITH SMART SERVICE IS
BEHAVE IN THE SAME WAYS WE CAN ACTUALLY JUST
RUN ONE COMMAND, GENERATE SERVICE, AND THAT
WILL BUILD A LOT OF THINGS FOR YOU.
SO IT HANDLES ALL THAT BOILERPLATE OF, YOU
KNOW, CONSTRUCTING A NEW SMART SERVICE OBJECT,
DOING KIND OF DEFAULT VALUES, IT GIVES YOU A
DIRECTORY, A GIT REPERTOIRE, A VIRTUAL
ENVIRONMENT AND ALL THOSE COMPOSITES INSTALLED
INTO THE VIRTUAL ENVIRONMENT.
SO YOU WRITE ONE COMMAND, AND THEN A MINUTE
LATER YOU HAVE THIS FULLY OPERATIONAL SERVICE
THAT YOU CAN TAKE AND YOU CAN DEPLOY IT RIGHT
AWAY.
AND SO IT'S KIND OF GETS ALL OF THAT OVERHEAD
OF, YOU KNOW, HOW DO I GET STARTED, HOW DO I
SET SOMETHING ELSE -- SOMETHING NEW UP.
AND IT KIND OF REDUCES THAT INTO A SINGLE
COMMAND AND NOW YOU CAN MOVE ON AND ACTUALLY
WRITE USEFUL TOWED CODE.
AND TO SMART SERVICE AND ALL THE THINGS WE PUT
INTO IT AS WELL AS SMART CLIENT ITSELF GO INTO
THIS IDEA OF REDUCING COGNITIVE OVERHEAD.
ABOUT OR THE AMOUNT OF TIMES YOU HAVE TO
CONTEXT SWITCH FROM, OKAY SO I NEED TO ACCESS A
THE AMOUNT OF THINGS THAT YOU HAVE TO THINK
DATABASE BUT WHERE IS THAT DATABASE OR HOW DO I
CONSTRUCT A NEW SEQUEL MODEL, AND THEN WHERE DO
I FIND THE DATABASE SESSION AND WHAT DO I DO
WHEN THE APP IS, YOU KNOW, DONE WITH THIS
REQUEST, DO I HAVE TO TEAR IT DOWN.
ALL THESE THINGS ARE KIND OF ANSWERED FOR YOU.
AND AS A DEVELOPER, YOU JUST SAY, HEY,
DATABASE, DO THIS THING THAT I WANT.
RIGHT?
AND THEN MOVE ON TO THE NEXT THING YOU WANT TO
DO.
SO THIS IS REALLY HELPFUL FOR MANAGING LOTS AND
LOTS OF SERVICES BECAUSE ALL OF THESE SERVICES
LOOK AND BEHAVE AND ACT THE SAME WAY.
IF YOU FIX A BUG HERE, AND THEN YOU NEED TO
CONTACT AND SWITCH AND MOVE TO ANOTHER PROJECT
AND IMPLEMENT A FEATURE, ALL THE LOGGING IS THE
SAME, ALL THE DATABASE HANDLING IS THE SAME.
YOU DON'T HAVE TO THINK ABOUT THOSE LITTLE
DETAILS.
YOU CAN FOCUS ON WRITING ACTUAL CODE.
SO THAT'S COINED OF WHAT WE DID TO MAKE
AND SO NOW WE HAVE A LOT OF SERVICES.
SO NEXT QUESTION IS WHAT HAPPENS.
BUILDING SERVICES REAL EASY.
RIGHT?
SO A LOT.
SO THE NEXT BIT OF THIS TALK IS ABOUT SOME OF
THE LESSONS THAT WE'VE LEARNED OR SOME OF THE
THINGS THAT WE'VE DECIDED TO KIND OF BAKE INTO
OUR PROVES
PROCESS TO MAKE LIVING IN A WORLD WITH LOTS OF
SERVICES REALLY EASY.
SO THE FIRST LESSON NOT SURPRISING IS YOU HAVE
TO AUTOMATE EVERYTHING.
FOR US, THAT MEANS SIT -- SETTING UP NEW
SERVERS WHEN WE BRING THEM ONLINE.
THAT MEANS, YOU KNOW, WE USE PUPPET TO KIND OF
GENERATE TEMPLATES FOR ALL OF OUR INIT SCRIPTS,
ALL OF OUR MONITORING.
EVERYTHING YOU DO HAS TO BE KIND OF REPEATABLE
AND DEPLOYABLE WITHOUT HAVING TO THINK ABOUT
IT.
SO YOU HAVE TO INVEST A LOT IN DEVOPS AND VEST
IN AUTOMATION TOOLS AND SCRIPTS, TO MAKE
RUNNING 60 SERVICES, MAKE RUNNING A HUNDRED
SERVICES REASONABLE.
THESE SERVICES AND THEY'RE ALL OPERATING AND
TALKING TO EACH OTHER, AND WE'VE GOT ALL THESE
THE NEXT THING WE LEARNED IS ONCE WE BUILT
NICE AND INTERESTING TOOLS, THAT IS YOU
ACTUALLY BECOME LANGUAGE AGNOSTIC.
SO MOST OF OUR STUFF IS PYTHON.
A LOT OF PYTHON SERVICES.
BUT ABOUT A YEAR AGO WE STARTED WRITING A LOT
OF GO CODE.
AND SO WHEN WE, YOU KNOW, FIGURED OUT THAT KIND
OF FIRST BIT OF HOW DO YOU BUILD AND DEPLOY GO,
AND WE HAD A GO SERVICE UP AND RUNNING, IT
BECAME REALLY EASY TO INTEGRATE THAT WITH THE
REST OF OUR CLUSTER.
WE GOT ALL OF THESE NICE FEATURES THAT ALREADY
EXISTED FROM OUR IDENTITY SERVER, KNOWING ABOUT
CUSTOMERS.
RIGHT?
AND SO A PIECE OF GO CODE DOESN'T NEED TO KNOW
WHAT FORMAT IS THAT DATA IN, OR YOU KNOW, WHAT
DATABASE DO I NEED OR WHAT ORM DO I NEED.
IT JUST NEEDS TO KNOW I'VE GOT THIS API THAT I
CAN CALL TO GET ALL THIS DATA BACK IN JSON.
AND SO WE'RE ABLE TO KIND OF QUICKLY SPIN UP
EITHER NEW PROJECTS, THIRD PARTY TOOLS,
USEFUL IN THE CONTEXT OF OUR CLUSTER.
SO WE SAY THAT HTTP IS OUR COMMON LANGUAGE.
ANYTHING THAT TALKS HTTP BECOMES IMMEDIATELY
THE NEXT BIT WAS MORE OF A PHILOSOPHICAL
DECISION FOR US EARLY ON.
BUT IT'S REALLY PAID OFF.
THERE ARE NO SHARED DATABASES BETWEEN OUR
SERVICES.
SO WE COULD HAVE IMAGINED A WORLD WHERE YOU
HAVE OUR DASHBOARD, OUR TRAFFIC GATEWAY, OUR
API ALL TALKING TO THE SAME POSTGRESQL DATABASE
FOR CUSTOMER DATA.
THE PROBLEM THAT HAPPENS WHEN YOU HAVE THIS
KIND OF ARCHITECTURE IS THAT YOU HAVE THIS
SHARED DEPENDENCY BETWEEN NOT ONLY THE TYPE OF
DATABASE THAT YOU'RE ACTUALLY RUNNING, BUT ALSO
THE SCHEMA THAT THAT DATABASE HAS.
SO IF WE ADD A NEW COLUMN, MAKE A SCHEMA
UPDATE.
THEN WE HAVE TO DEPLOY CODE TO ALL THREE OF
THESE OTHER LOCATIONS.  THE REAL PROBLEM WITH
THAT IS THAT IT'S NO LONGER AN INDEPENDENT
SYSTEM.
YOU'RE TAKING WHAT USED TO BE THREE INDEPENDENT
SERVICES AND ACTUALLY TYING THEM TOGETHER VERY
AND SO WHENEVER YOU HAVE THIS KIND OF PATTERN
WHERE IF YOU MAKE THIS ONE CHANGE AND YOU HAVE
TIGHTLY.
TO DEPLOY EVERYTHING ELSE IN THE WORLD YOU KNOW
YOU'RE DOING SOMETHING WRONG.
SO FOR US, WE SAID NONE OF THIS.
WE'RE NOT GOING TO DO THAT.
EVERY SERVICE OWNS ITS OWNS ITS OWN DATASTORE.
FOR IDENTITY, RIGHT NOW WE RUN FLASK,
POSTGRESQL, WE USED TO RUN CACHE FOR CACHING,
WE CHANGED THAT TO REDIS.
BUT THE POINT IS FROM EVERYONE ELSE'S
PERSPECTIVE IT'S JUST AN API, RIGHT?
YOU DON'T HAVE TO KNOW WHAT TECHNOLOGIES ARE
INVOLVED IN THAT API UNLESS YOU'RE ACTUALLY
DEVELOPING THAT SERVICE, AND THAT REALLY KEEPS
THE CONTEXT SMALL, AND SO IF YOU NEED TO KNOW
OH, YEAH THIS IS HOW SEQUEL INTERACTS WITH
POSTGRESQL IN THE CONTEXT OF IDENTITY, THEN YOU
CAN FOCUS ON THAT ONE THING.
BUT IF YOU DON'T ACTUALLY CARE ABOUT THAT.
IF YOU'RE DEVELOPING SOMETHING FOR THE WEBSITE
OR ADDING A NEW FEATURE TO OUR PUBLIC API,
THOSE THINGS ARE KIND OF IRRELEVANT TO YOU IN
YOUR DAY-TO-DAY.
SMALL AND MAKES IT REALLY EASY TO CHANGE THINGS
INDEPENDENT FROM EVERYONE ELSE AROUND YOU.
AND SO IT KEEPS THAT KIND OF MENTAL OVERHEAD
SPEAKING OF CHANGING THINGS, THE BIGGEST EFFECT
FROM GOING TO THIS MICRO SERVICE ARCHITECTURE
FOR US WAS THAT ONCE WE INVESTED IN ALL OF THIS
INFRASTRUCTURE AND AUTOMATION IT MADE DEPLOYING
CODE REALLY EASY.
AND THIS IS SOMETHING WE REINFORCED OVER AND
OVER.
SOMETHING WE WANTED FROM THE VERY BEGINNING WAS
THE IDEA OF A ONE CLICK DEPLOY.
SO WE BUILT THIS NOT SURPRISINGLY A SERVICE
CALLED PROMETHEUS TO HELP US DO DEPLOYS.
THIS IS OUR OPERATIONAL AND SERVICE DASHBOARD.
SO RIGHT IN THE MIDDLE OF THE PAGE YOU SEE A
LIST OF BRANCHES THAT EXIST FOR THIS SERVICE
AND THEN A BUNCH OF DEPLOY BUTTONS TO THE
RIGHT.
SO YOU CAN DEPLOY TO OUR TESTING ENVIRONMENT
ANY BRANCH THAT YOU WANT AT ANY TIME.
AND KIND OF AT THE TOP OF THE SCREEN THERE'S,
YOU KNOW, WHEN WAS THE LAST BUILD, WHAT WAS THE
BUILD STATUS OF IT.
SO WE RUN JENKINS TO DO UNA TESTING AND PILOT
AND FOR EACH OF THOSE BRANCHES YOU CAN SEE
WHETHER OR NOT THOSE BUILDS SUCCEEDED OR
AND PEP CHECKS.
FAILED.
BUT THE IDEA HERE IS THAT WE WANT TO MAKE IT SO
SIMPLE TO GET ANY SERVICE DEPLOYED TO OUR
TESTING ENVIRONMENT AND PRODUCTION THAT ON THE
FIRST DAY YOU CAN COME, CHECK IN CODE, AND
DEPLOY TO PRODUCTION AS AN ENGINEER.
AND SINCE ALL OF OUR SERVICES BEHAVE
INDEPENDENTLY, EACH ONE IS INDEPENDENTLY
DEPLOYABLE, AND WE'VE KIND OF MADE THIS RULE
THAT ONCE YOU'VE CODE REVIEWED YOUR CHANGES AND
MERGED THEM INTO MASTER YOU CAN IMMEDIATELY GO
AND DEPLOY IT ON YOUR OWN.
WE FOUND THAT PEOPLE DO THAT.
AND PEOPLE REALLY LIKE DEPLOYING.
AND SO RIGHT NOW WE'RE DOING OVER 50 DEPLOYS A
DAY EVEN THOUGH WE HAVE SUCH A TINY TEAM.
SO THE NEXT QUESTION IS LIKE WHEN YOU'RE
DEPLOYING ALL THIS CODE SO QUICKLY, HOW DO YOU
NOT BREAK THINGS ALL THE TIME.
SO FOR US, GOING BACK TO THE PRODUCTS THAT WE
BUILD, WE ACTUALLY USE OUR OWN TESTING AND
AUGUST MONITORING TOOLS TO MONITOR OUR OWN
THIS IS SUCH A LIFESAVER FOR US.
WE'RE ABLE TO BUILD SERVICE TESTING IN OUR
INTERNAL SERVICES.
TESTING ENVIRONMENT.
SO AFTER YOU DEPLOY, IT AUTOMATICALLY TRIGGERS
THIS AUTOMATED TEST WHICH GOES OUT, VERIFIES
ALL THE SERVICE APIS ARE UP AND RUNNING ASK
RETURNING THE CORRECT DATA AND THEN LETS US
KNOW VIA SLACK OR EMAIL THAT SOMETHING BROKEN.
THE NICE THING ABOUT THE TOOL IS THAT YOU CAN
WRITE TEST, CREATE VARIABLES FOR THE HOST NAMES
AND USE THAT IN YOUR ENVIRONMENT SO YOU CAN DO
API DEVELOPMENT AND POINT THAT TEST AT YOUR
LOCAL HOST.
YOU CAN TAKE THAT SAME TEST AND RUN IT AGAINST
OUR TESTS ENVIRONMENT AND TRIGGER THAT
AUTOMATICALLY AFTER EVERY DEPLOY, AND THEN YOU
CAN TAKE THAT SAME TEST AND RUN IT ON A
SCHEDULE IN YOUR PRODUCTION ENVIRONMENT TO KNOW
THAT IT'S UP AND RUNNING AND THE PERFORMANCE
OVER TIME IS STABLE.
AND SO THE IDEA HERE IS THAT ALL OF THESE
THINGS TOGETHER, SMART SERVICE, SMART CLIENT,
OUR OWN TESTING TOOLS, KIND OF MAKE THIS GRAPH
POSSIBLE.
DEPLOY, BEING ABLE TO FIX A BUG IN LESS TIME
THAN IT TAKES TO RESPOND TO THE SUPPORT EMAIL,
AND AS AN ENGINEER, COMING IN, BEING ABLE TO
GETTING THINGS INTO PRODUCTION CONSTANTLY DAY
AFTER DAY AFTER DAY IS INCREDIBLY EMPOWERING
AND IT'S KIND OF -- IT'S SOMETHING THAT, YOU
KNOW, WE KNEW WAS POSSIBLE WHEN WE STARTED THE
COMPANY.
BUT SEEING IT IN PRACTICE OVER THE LAST
TWO AND-A-HALF YEARS, IT'S SOMETHING THAT
WE'RE, ONE, VERY PROUD OF, BUT STATEMENT, IT'S
SOMETHING THAT, YOU KNOW, CHANGES HOW YOU THINK
ABOUT CODE, HOW BIG A FEATURE YOU SCOPE AND HOW
OFTEN THAT YOU MAKE CHANGES TO YOUR SITE AND
YOU CAN DO THAT WITH CONFIDENCE IF YOU INVEST
IN ALL THE RIGHT PIECES OF INFRASTRUCTURE.
SO THAT'S ALL THE TALK THAT I HAD PLANNED.
THANK YOU.
[ APPLAUSE ]
>> AND I THINK I LEFT ENOUGH TIME FOR A FEW
QUESTIONS.
14:01:17>> I THOUGHT THERE WAS A MICROPHONE FOR
QUESTIONS AND PERFECT.
OKAY.
>>  I HAVE A QUESTION ABOUT HOW YOU USE
[INAUDIBLE], KEEPING THEM CONSISTENT WHEN YOU
GO RIGHT AHEAD, PLEASE.
HAVE SORT OF DE FACTO FOREIGN KEYS BETWEEN
THOSE SERVICES.
>> SO WE TRY ACTUALLY NOT TO HAVE A DE FACTO
FOREIGN KEYS BETWEEN THE SERVICES.
WE TRY AND HAVE THE DATA THEY'RE STORING TO
KEEP ALL THAT RELATED INFORMATION TOGETHER.
AND SO YOU KNOW, A LOT OF THINGS KIND OF ASSUME
THERE'S A PARTICULAR STRUCTURE AND A PARTICULAR
KEY, BUT WE TRY TO KEEP THOSE LOOSELY COUPLED
BETWEEN SERVICES THAT I HAVE A CUSTOMER ID HERE
AND THAT MAY OR MAY NOT EXIST BUT I'LL CHECK
THAT AT RUNTIME WHEN I NEED TO.
BUT MOST OF THE DATA CONSISTENCY WHERE YOU NEED
HARD LINKAGE BETWEEN OBJECTS, WE TRY TO KEEP
THAT WITHIN ONE SERVICE.
>> HI.
DO YOU HAVE ANY TOOLS THAT HELP YOU DEBUG
RUNTIME ERRORS RELATED TO DATA FLOW BETWEEN
MULTIPLE SERVICES AND HOW DIFFICULT IS THAT?
>>  SO YEAH.
SO ONE OF THE THINGS THAT I SHOWED EARLIER IS
OUR TRAFFIC INSPECTOR.
BASICALLY ADD HEADERS THAT GET PASSED FROM
SERVICE TO SERVICE, AND SO IN OUR INTERFACE YOU
AND WE CAN TURN THAT ON FOR OURSELVES AND ADD
CAN DO A LITTLE SEARCH QUERY AND SAY DOES THIS
HEADER VALUE EXIST, AND SO YOU CAN TAG
BASICALLY A REQUEST FLOW AS IT GOES FROM
SERVICE TO SERVICE.
>>  COULD YOU TALK A LITTLE BIT ABOUT HIGH
AVAILABILITY?
LIKE WILL MICRO-SERVICES BEHIND LOAD BALANCERS
AND LIKE THAT.
>> YEAH.
I DIDN'T TOUCH ON THAT IDEA VERY MUCH IN THE
TALK.
BUT SINCE WE HAVE THESE SMALL, INDEPENDENT
SERVICES AND EACH ONE IS REPLICATED ACROSS
AVAILABILITY ZONES AND DIFFERENT DATA CENTERS
AND WE HAVE THAT HE IS LOCAL LOAD BALANCERS ON
EACH SERVICE, YOU KNOW, IF A REQUEST TO ONE OF
THOSE SERVICES FAIL, THERE'S ALWAYS ANOTHER ONE
UP RUNNING SOMEWHERE ELSE THAT YOU CAN TRY THAT
REQUEST TO.
AND THAT'S KIND OF WHAT WE BUILT IS TO TRY
AUTOMATIC REQUESTS WHEN WE KNOW IT'S SAFE TO DO
SO.
>>  DURING YOUR TALK, YOU MENTIONED THAT HTTP
IS YOUR COMMON LANGUAGE BETWEEN MICRO-SERVICES.
>> THANK YOU.
I WAS WONDERING IF YOU HAD ANY IDEA OF WHAT IS
OVERHEAD OF USING MULTIPLE MICRO-SERVICES DUE
TO THE TRANSACTIONS AND [INAUDIBLE] TO GET TO
THAT ANSWERS THE QUESTION.
>>  YEAH.
SO THERE IS SOME NATURAL OVERHEAD FOR USING
HTTP.
AND FOR US, I THINK THE THING THAT WE WANT TO
OPTIMIZE FOR IS EASE OF USE AND KIND OF
DEVELOPER PRODUCTIVITY.
AND SO THERE IS SOME OPTIMIZATION THAT WE COULD
USE.
WE COULD REPLACE THAT LAYER WITH A BINARY
PROTOCOL SOMETHING LIKE THAT.
AT THE END OF THE DAY WE FOUND WE MOVED SO
QUICKLY AND THINGS CHANGE SO OFTEN THAT KIND OF
BAKING IN THOSE THINGS RIGHT NOW DIDN'T MAKE A
LOT OF SENSE.
ALSO WITH ENOUGH CACHING AND ENOUGH
ASYNCHRONOUS WORK, YOU DON'T HAVE TO WORRY SO
MUCH ABOUT PERFORMANCE.
BUT WE REALLY STRIVE FOR CORRECTNESS FIRST.
ON EACH OTHER, AND YOU'RE GOING TO UPGRADE ONE
AND YOU'RE GOING TO -- I'M TALKING I GUESS
>>  HOW DO YOU DEAL WITH WHEN SERVICES DEPEND
ABOUT API VERSIONS.
SO WE'RE GOING TO HAVE ONE SERVICE, YOU'RE
GOING TO UPGRADE IT AND HAVE NEW FEATURES
BECAUSE ANOTHER SERVICE WANTS TO USE THOSE NEW
FEATURES.
HOW DO YOU DEAL WITH THE DEPENDENCY MANAGEMENT
PROGRAM YOU HAVE THERE.
>> COOL, THIS IS THE LAST QUESTION I'VE BEEN
TOLD FOR TIME.
BUT TO ANSWER YOUR QUESTION, WE TRY TO MAKE ALL
OF OUR API AS BACKWARDS COMPATIBLE AS WE MAKE
CHANGES.
SO WHAT WE FOUND USUALLY IS THAT ONCE YOU'VE
BUILT -- WHEN THE API CHANGES THE MOST IS
DURING THE FIRST DEVELOPMENT.
AND SO WE ITERATE LOCALLY AND IN OUR TEST
ENVIRONMENT, AND WE'RE NOT AFRAID TO BREAK
THINGS IN OUR TEST ENVIRONMENT.
BUT ONCE WE'VE DEPLOYED SOMETHING AND HAVE IT
UP AND RUNNING WE TRY TO MAKE ANY CHANGES TO
THE API BACKWARDS COMPATIBLE WITH ALL THE OLD
CLIENTS AND SOMETIMES THAT MIGHT INVOLVE
SO YOU MIGHT HAVE ONE THAT RUNS IN HAD TWO
MODES AND THEN DEPLOY ALL THE OLD SERVICES THAT
STAGING RELEASES.
USE THE OLD MODE AND MIGRATE THEM OVER AND THEN
DEPTH PREDICT AND REMOVE THAT OLD API BUT WE
TRY NOT TO DO THAT VERY OFTEN.
>> THANKS A LOT.
>> SO ANY MORE QUESTIONS, COME FIND ME OUTSIDE
THE ROOM OR COME BY THE RUNSCOPE BOOTH.
WE HAVE TONS OF PEOPLE HERE TALKING ABOUT API
AND API TESTING.
THANK YOU.
>>  THANK YOU.
[ APPLAUSE ]
