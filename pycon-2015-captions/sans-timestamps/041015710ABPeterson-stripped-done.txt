PETERSON.
THE (SLIGHTLY) LESS SORRY STATE OF SSL.
>>  THANK YOU VERY MUCH, EVERYBODY.
AND GOOD AFTERNOON.
AS HE SAID, I'M BENJAMIN PETERSON.
I WOULD LIKE TO TELL YOU ABOUT SSL AND
PYTHON.
BUT FIRST, LET ME LOOK AT THE PROGRAM HERE.
OKAY.
SO WHAT AM I UP AGAINST?
RAYMOND.
BEYOND PIP AID.
THE BEST PRACTICE FOR BEAUTIFUL INTELLIGIBLE
CODE.
OKAY.
NOTHING IS GOING TO BE BEAUTIFUL IN THIS
TALK.
SO YOU SHOULD GO TO THAT.
SO INSIDE THE HAT, PYTHON AT WALT DISNEY
ANIMATION STUDIOS.
THAT ONE YOU SHOULD DEFINITELY GO TO BECAUSE
IT'S NOT BEING RECORDED DUE TO ALL THE COOL
GRAPHICS WHICH ARE BEING SHOWN.
SO THAT'S IN 517D.
THAT'S DOWNSTAIRS.
I WAS WATCHING IN THE SPEAKER'S LOUNGE.  IT
LOOKED REALLY GOOD.
AND LET'S SEE.
HTTP 2.
WELL, I GUESS THAT USES SSL, SO MAYBE YOU CAN
JUST WATCH THAT LATER.
ALL RIGHT.
SO AS YOU CAN SEE IN THE PROGRAM, THE TALK IS
LISTED AS A DIVE INTO TLS.
AND THE TITLE HERE IS A BIT DIFFERENT.
AND THE REASON FOR THAT IS THAT I, WHEN THE
TALKS WERE ACCEPTED, I NOTICED THAT THERE WAS
A TALK WHICH OVERLAPPED A LOT WITH MY
ORIGINAL PROPOSAL, SPECIFICALLY DESCRIBED IN
THE ACTUAL TLS PROTOCOL.
AND ADDITIONALLY, IN THE TIME SENSE PROPOSALS
WERE DUE IN SEPTEMBER, A LOT OF THINGS HAVE
HAPPENED IN THE PYTHON SSL MODULE WHICH I
WOULD LIKE TO TELL YOU ABOUT.
SO I'M GOING TO BE TALKING ABOUT IMPROVEMENTS
MADE TO THE PYTHON STANDARD LIBRARY SSL
MODULE OVER THE LAST YEAR.
AND REMEMBER, PAUL'S TALK IS DOWNSTAIRS.
ALL RIGHT.
SO AS I SAID, I'M BENJAMIN PETERSON.
I HAVE BEEN A CORE DEVELOPER OF CPYTHON FOR
ABOUT 7 YEARS NOW.
AND I'VE WORKED ON A LOT OF DIFFERENT PARTS
OF CORE PYTHON LANGUAGE AND THE STANDARD
LIBRARY.
AND I'VE ALSO BEEN A RELEASE MANAGER.
AND THE OTHER THING WHICH YOU MAY KNOW ME
FROM IS WRITING THE SIX PYTHON 2 AND 3
COMPATIBILITY LIBRARY, WHICH I HOPE HAS
HELPED YOU IN DOC PYTHON 3.
OKAY.
SO THAT'S ENOUGH BORING THINGS ABOUT ME.
LET'S TALK ABOUT SOMETHING MUCH MORE
INTERESTING.
SO THIS IS HYNEK SCHLAWACK.
AS YOU CAN SEE, HE'S A VERY COOL GUY BECAUSE
HE HAS THIS PICTURE ON HIS WEBSITE OF HIM
STARING OUT OF BLACKNESS.
HE'S SITTING IN THE FRONT ROW IF YOU WANT TO
MEET HIM.
AND SO LAST YEAR, HYNEK GAVE A TALK AT PYCON
MONTREAL AND ALSO A FEW OTHER PLACES CALLED
THE SORRY STATE OF SSL.
AND AS YOU CAN SEE, MY TALK TITLE HAS BEEN
DERIVED FROM HIS.
AND AS YOU MAY SURMISE FROM THE TALK TITLE,
HE WAS BASICALLY POINTING OUT ALL THE
TERRIBLE THINGS IN THE PYTHON COMMUNITY WHICH
SURROUNDING SUPPORT OF SSL.
SO LATER IN THE TALK, HE ALSO HAD THIS SLIDE,
WHICH, OUCH, IT KIND OF HURTS.
IT BURNS.  AND SO MY HOPE IS TO EXPLAIN TO
YOU -- REMIND YOU WHY HYNEK SAYS WE WERE AT
THE FOREFRONT OF TERRIBLE AND THEN CONVINCE
YOU THAT WE'RE SLIGHTLY AHEAD OF THE
FOREFRONT OF TERRIBLE.
OKAY.
SO AGAIN, WHY ARE WE SO SORRY ABOUT THE STATE
OF SSL IN PYTHON?
SO LET ME BEGIN BY REMINDING YOU ABOUT THE
STANDARD LIBRARY SSL MODULE, WHICH IS THE
MAIN TOPIC OF THIS TALK.
SO IT WAS ADDED IN PYTHON 2.6, WHICH I
REMEMBER, BUT, AS FAR AS TECHNOLOGY IS
CONCERNED, IS BASICALLY ANCIENT HISTORY.
AND ITS BASIC OPERATION IS THAT IT'S A
WRAPOVER OVER SSL.
SO THERE'S NO CODE IN PYTHON WHICH ACTUALLY
KNOWS HOW TO SPEAK THE TLS OR SSL PROTOCOLS
OVER THE WIRE.
THAT'S ALL HANDLED BY OPEN SSL.
AND THE SSL MODULE JUST USES THE C OPEN SSL
APIS, SO THAT'S GOOD BOTH BECAUSE WE DON'T
HAVE TO MAINTAIN A TLS IMPLEMENTATION IN THE
STANDARD LIBRARY AND BAD BECAUSE EVERY TIME
THERE'S AN OPEN SSL CVE, THEN ALL PYTHON
STUFF IS SCREWED OVER.
AND THE API OF THE SSL MODULE IS BASICALLY A
FAKE SOCKET API, AT LEAST THE TRADITIONAL
API.
AND SO WHAT THAT MEANS IS THAT YOU WOULD MAKE
A RAW TCP SOCKET, AND THEN YOU WOULD HAND IT
TO THE SSL MODULE AND SAY WRAP THIS SOCKET
WITH TLS, AND OPEN SSL WOULD SPEAK TLS OR SSL
OVER THE HTTP SOCKET WHICH YOU CREATED AND
INTERACT WITH THE APIS, WHICH ARE LIKE THE
RAW SOCKET APIS WHICH YOU WOULD SAY WRITE 25
BYTES OR READ SEVERAL BYTES.
AND SO THIS MADE IT SOMEWHAT EASY TO JUST ADD
TLS TO A RAW SOCKET PROTOCOL WHEN THE API
WORKS.
THE ABSTRACTION BREAKS DOWN SOMETIMES.
AND THEN THE OTHER IMPORTANT THING ABOUT THE
SSL MODULE IS THAT IT IS WHAT PROVIDES HTTPS
SUPPORT IN THE REST OF THE STANDARD LIBRARY.
SO IN PARTICULAR, HTTPLIB BECAUSE HTTP AND
HTTPS PROTOCOLS ARE SO IMPORTANT IN MODERN
COMPUTING, BUT ALSO, IF YOU WANT TO DO XML,
RPC OVER SSL, THE STANDARD LIBRARY WILL USE
THE SSL MODULE FOR THAT.
SO IT'S -- IN A WAY, IT'S THE CANONICAL
SOURCE OF SSL SUPPORT FOR PYTHON.
AND THE OTHER THING WHICH NEEDS TO BE NOTED
IS THAT THE SSL MODULE SAW IMPROVEMENTS IN
PYTHON 3, WHICH -- AND 2.7 WAS BASICALLY LEFT
BEHIND.
SO WE'RE GOING TO SEE HOW THAT CREATED A BIT
OF TENSION.
SO MORE OR LESS, WHAT HAPPENED IS PYTHON 2.7
WAS RELEASED IN 2010.
AND THIS IS GOING TO BE THE END OF THE 2.7
SERIES, THE LAST MAJOR RELEASE.
ALL NEW FEATURES ARE NOW DEVELOPED ON PYTHON
3.
BUT THAT ALSO MEANS THAT THE SSL MODULE IN
2.7 WAS FROZEN IN 2010 AND, UNFORTUNATELY, A
LOT OF THE MODERN APIS WHICH YOU NEED TO DO
MODERN, SECURE CRYPTOGRAPHY AND TLS, ARE
ABSENT IN THE 2.7 VERSION OF SSL EVEN THOUGH
THEY WERE PRESENT IN PYTHON 3.
AND SO THEY WERE NOT ACCESSIBLE TO THE LARGE
NUMBER OF PYTHON USERS WHO ARE STILL USING
PYTHON 2.7, AND THEY ARE MORE OR LESS BEING
LEFT IN THE DUST TO FEND FOR THEMSELVES IN
TERMS OF SSL SUPPORT.
SO SPECIFICALLY, SOME IMPORTANT THINGS WHICH
WERE MISSING WAS SUPPORT FOR THE NEWER
PROTOCOLS IN TLS.
TLS 1.1, AND TLS 1.2.
AND THAT'S BAD NOT ONLY BECAUSE TLS 1.1 AND
1.2 ARE NEWER VERSIONS OF THE PROTOCOL WITH
SOME SECURITY IMPROVEMENTS, BUT ALSO BECAUSE
TLS 1.1 AND 1.2 ARE INCLUDED FOR MODERN
CIPHER SUITES.
SO THE KINDS OF CIPHERS WHICH WE WANT TO BE
USING TODAY ARE JUST NOT AVAILABLE IN TLS
1.0.
AND SO IF YOU DON'T ACTUALLY HAVE THE ABILITY
TO SUPPORT TLS 1.1 OR 1.2, THEN YOU'RE KIND
OF STUCK WITH THESE OLDER OFTEN BROKEN
CIPHERS.
IN PARTICULAR, YOU DON'T HAVE THE IMPORTANT
CIPHERS WHICH HAVE IMPORTANT PROPERTIES LIKE
PERFECT FORWARD SECURITY.
THERE IS ALSO JUST MISSING FEATURES FROM THE
SSL MODULE WHICH ARE NEEDED IF MODERN
NETWORKING APPLICATIONS LIKE NEXT PROTOCOL
NEGOTIATION, WHICH IS A TLS EXTENSION USED TO
NEGOTIATE THE NEXT APPLICATION LAYER
PROTOCOL.
WHAT THIS MEANS IS IT'S USED TO NEGOTIATE
HTTP 2.
AND SINCE HTTP 2 HAS BEEN FINALLY
STANDARDIZED, NOW THIS HAS BECOME A MUCH MORE
IMPORTANT ISSUE.
AND ANOTHER SIMILAR THING WAS SIMILAR NAME
INDICATION, WHICH IS A WAY TO HOST SSL OR TLS
SERVICES AS VIRTUAL HOSTS.
THIS IS NEEDED TO DO THAT.
AND THEN THE FINAL THING WAS THAT THERE WAS
NO BUILT-IN WAY TO ACCESS THE SYSTEM'S STORE
OF CERTIFICATES, AND YOU HAD TO BUILD YOUR
OWN CODE FOR THAT, WHICH ON UNIX SYSTEMS YOU
JUST USUALLY HAVE TO SEARCH IN THE RIGHT
LOCATIONS TO FIND THE CERTIFICATE STORE.
BUT ON WINDOWS, THERE'S CUSTOM WIN32 API CODE
WHICH YOU HAVE TO WRITE TO ACCESS THE SYSTEM
STORE.
AND THE FINAL THING WAS THAT IN 2.7, THERE
WERE JUST BAD DEFAULTS, WHICH WE KNOW ARE
VERY DANGEROUS IN SECURITY SENSE OF CODE AND
API DESIGN IN GENERAL, OF COURSE.
SO AS I SAID, LIKE ALL THE PROTOCOLS WERE
ALLOWED BY DEFAULT, SO COMPLETELY INSECURE
PROTOCOLS LIKE SSL 3 OR SOMETHING, YOU KNOW,
WOULD JUST BE USED BY DEFAULT UNLESS YOU TURN
IT OFF.
AND THE CIPHER STRING WAS THE ONE WHICH WAS
USED BY OPEN SSL BY DEFAULT, AND THAT
INCLUDED A LOT OF INSECURE CIPHERS.
THIS IS LIKE THE SORT OF WAY THAT THE TLS
PORT CIPHERS WOULD GET ADDED, AND THAT'S HOW
THAT SORT OF THING WOULD HAPPEN.
AND THEN THERE WAS NO CERTIFICATE TRUST
VERIFICATION BY DEFAULT.
IT WOULD JUST ACCEPT -- CLIENTS WOULD JUST
ACCEPT ANY CERT WHICH WAS HANDED OVER.
AND THERE WAS NO HOST NAME VALIDATION BY
DEFAULT.
SO THE SUM TOTAL OF ALL THIS IS THIS VERY
INNOCENT LINE.
JUST USING STANDARD LIBRARY NETWORKING CODE
IN PORT URLLIB OPENED THE VERSION OF THE
PYTHON WEBSITE WAS COMPLETELY INSECURE.
IT WAS AS BAD AS USING IT OVER HTTP BECAUSE
THERE'S NO CERTIFICATE VALIDATION OR HOST
NAME VALIDATION.
AND IN FACT, IT'S QUITE A BIT MORE INSIDIOUS
BECAUSE PEOPLE THINK THAT THEY'RE GETTING
SECURITY BY PUTTING AN S THERE.
BUT THE STANDARD LIBRARY WAS NOT GUARANTEED
IN THAT AT ALL.
SO I WOULD LIKE TO REPORT ON THE PROGRESS
OVER THE LAST YEAR.
AND THIS COMES IN THE FORM OF TWO PIPS.
THE FIRST ONE IS 466, NETWORK SECURITY
ENHANCEMENTS FOR PYTHON 2.7.X.
AS THE NAME SUGGESTS, THIS INVOLVES ADDING A
WHOLE LOT MORE SECURITY FEATURES TO THE SSL
MODULE IN PYTHON 2.
SO THIS -- WHAT YOU CAN THINK OF IS THAT THE
3.4 SSL MODULE IS JUST BACKPORTED TO 2.7.
AND THAT'S ACTUALLY ESSENTIALLY HOW THE
BACKPORT -- THIS PIP WAS IMPLEMENTED WAS
BACKPORTING AND PORTING EVERYTHING BACK TO
2.7.
SO THIS WAS RATHER EXCEPTIONAL, BECAUSE WE
USUALLY WE HAVE A VERY -- IN CORE CPYTHON, WE
HAVE A VERY SCRIPT BACKWARDS COMPATIBILITY
POLICY, WHICH SAYS THAT WE SHOULD NOT ADD NEW
FEATURES TO BUG FIX VERSIONS OF RELEASES.
BUT IT WAS FELT THAT WE WERE GETTING TO THE
POINT THAT WE WERE LEAVING PYTHON 2.7 USERS
WITH THIS TOTALLY INSECURE SSL MODULE, WHICH
WASN'T APPROPRIATE IN THE MODERN WORLD THAT
WE LIVE IN.
SO THE THINGS THAT BACKPORT INCLUDED ARE THE
SSL CONTEXT CLASS WHICH I'M GOING TO TALK
ABOUT BRIEFLY AT THE END OF THE TALK AND ALSO
THE ABILITY TO SUPPORT NEWER VERSIONS OF TLS
WITH THE ASSOCIATED GOODS CIPHERS AND SIMILAR
NAME INDICATION.
AND THEN THERE WERE A FEW OTHER TINY THINGS
WHICH WERE BACKPORTED FROM PYTHON 3 TO OTHER
MODULES.
NAMELY PBKDF 2.
WHICH IS WHAT YOU SHOULD USE WHEN YOU GET A
PASSWORD AND YOU PUT IT IN YOUR DATABASE.
YOU SHOULDN'T YOU SHOULD USE ONE OF THESE KEY
DERIVATION ALGORITHM AND THEN THERE'S A
CONSTANT TIME COMPARING ALGORITHM FOR
COMPARING THE HASHES WHICH TO PREVENT TIMING
ATTACKS.
AND A FEW OTHER THINGS.
AND THEN THE SECOND PIP, WHICH CAME OUT WAS
476.
THE NAME IS PRETTY SELF-EXPLANATORY.
ENABLING CERTIFICATE VERIFICATION BY DEFAULT
STANDARD LIBRARY HTTP CLIENTS.
SO WHAT THIS MEANT WAS THAT HTTPLIB AND ITS
CONSUMERS WOULD VERIFY CERTIFICATES TO TRUST
VERIFICATION BY USING THE SYSTEM CERTIFICATE
STORE BY DEFAULT AND DO HOST NAME
VERIFICATION.
SO IT SHOULD BE ROUGHLY ON PAR WITH WHAT YOUR
BROWSER DOES, ALTHOUGH YOUR BROWSER HAS A LOT
OF OTHER FEATURES.
BUT THIS IS SOME -- PROBABLY WE'RE ACTUALLY
PROVIDING ACTUAL SECURITY BY DEFAULT NOW.
AND SO THIS WAS RELEASED IN PYTHON 2.7.9 AND
3.4.1, WHICH CAME OUT -- 2.7.9 CAME OUT IN
DECEMBER, AND 3.4.1 CAME OUT IN FEBRUARY I
THINK.
SO THIS IS SOMEWHAT NEW.
BUT IF YOU WERE ABLE TO UPGRADE YOUR PYTHON,
YOU'LL BE ABLE TO TAKE ADVANTAGE OF THIS
SECURITY IMPROVEMENTS.
AND ADDITIONALLY, YOU ARE NOW -- YOU'RE ABLE
TO CONFIGURE THE TLS CONFIGURATION OF
STANDARD LIBRARY PROTOCOLS.
IF YOU DON'T WANT TO USE THE DEFAULT
BYPASSING THE CONTEXT ARGUMENT TO, FOR
EXAMPLE, HTTPLIB OR RPC LIB.
SO LET ME BRIEFLY ELUCIDATE A FEW OF THE
THINGS WHICH WERE BACKPORTED TO 2.7.
SO ONE OF THE MAIN THINGS WAS THIS CLASS
CALLED SSL CONTEXT, WHICH IS IN THE SSL
MODULE, WHICH BASICALLY SERVES AS THE
CONFIGURATION FOR AN SSL CONNECTION.
ALL OF THE ARGUMENTS WHICH YOU NEED TO MAKE
AN SSL CONNECTION.
AND THIS REPLACES THE ORIGINAL API IN THE SSL
MODULE CALLED WRAP SOCKET WHICH HAS LIKE 12
ARGUMENTS AND STILL NEEDED MORE.
AND SO NOW THEY'RE ALL WRAPPED UP IN THIS
CLASS CALLED SSL CONTEXT.
AND SO AMONG THE CONFIGURATION THINGS ARE THE
CERTIFICATES WHICH YOU WANT TO TRUST, WHETHER
HOST NAME VERIFICATION IS ENABLED, THE CIPHER
STRINGS WHICH YOU'RE WILLING TO NEGOTIATE,
AND THE PROTOCOLS WHICH YOU'RE WILLING TO
SPEAK.
SO THAT'S SSL 3.0 OR TLS ONE OR TLS 1.2.
AND THERE'S A WHOLE LOT OF OPEN SSL FLAGS
WHICH YOU CAN ADD OR REMOVE AT YOUR LEISURE
TO CONFIGURE FUN OPEN SSL BEHAVIOR.
SO THIS IS THE THING WHICH I SAID THAT MANY
NETWORKING APIS NOW ACCEPT.
THE SSL CONTEXT.
SO YOU CAN PASS AN SSL CONTEXT TO HTTPLIB AND
IT WILL USE THAT CONFIGURATION TO MAKE HTTPS
CONNECTIONS.
SO YOU CAN INSTANTIATE YOUR OWN SSL CONTEXT.
YOU JUST GET A BLANK ONE AND THEN DO WHATEVER
YOU NEED TO DO TO CONFIGURE IT.
BUT YOU SHOULDN'T DO THAT.
YOU SHOULD USE THIS FUNCTION CALLED CREATE
DEFAULT CONTEXT.
AND WHAT CREATE DEFAULT CONTEXT DOES IS IT
MAKES YOU AN SSL CONTEXT WITH GOOD DEFAULTS.
SO THIS IS THE ONE WHICH IS USED THROUGHOUT
THE STANDARD LIBRARY, AND SO IF YOU NEED TO
TWEAK SOMETHING, YOU CAN CREATE A DEFAULT
CONTEXT AND THEN JUST TWEAK WHATEVER YOU
NEED, AND THEN ALL THE OTHER DEFAULTS SHOULD
BE GOOD.
SO IN PARTICULAR, WE HAVE A GOOD CIPHER
STRING WITH GOOD PRIORITIZATION USING SOME OF
THE NEWER, HIGH QUALITY CIPHERS WHICH IS
ACTUALLY SUGGESTED BY HYNEK.
AND WE ALSO LOAD THE SYSTEM CERTS TO DO TRUST
VALIDATION.
AND THE BEST THING IS THAT NOW WE'LL BE ABLE
TO UPDATE THIS FUNCTION AS TLS BEST PRACTICES
EVOLVE.
AND SO -- AND MAKE SURE THAT EVERYTHING STAYS
SECURE.
FOR EXAMPLE, WE JUST RECENTLY REMOVED THE
CIPHER RC4 FROM THE DEFAULT PROTOCOL STRING
BECAUSE THERE'S AN RFC WHICH SAYS THAT YOU
SHOULD NOT USE IT BECAUSE IT'S BROKEN.
THERE ARE SOME PRETTY COOL BIAS ATTACKS.
AND SO AS I SAID, [INAUDIBLE] CONTEXT IS THE
ONE WHICH IS USED BY THE STANDARD LIBRARY
NETWORKING.
AND THEN SO AS I ALLUDED TO BEFORE, WE NOW
HAVE SUPPORT FOR SEVERAL MORE TLS EXTENSIONS
TO THE PROTOCOL, WHICH ARE IMPORTANT FOR
MODERN NETWORKING.
SPECIFICALLY, SERVER NAME INDICATION WHICH
ALLOWS FOR VIRTUAL HOSTING TO WORK WITH SSL.
AND ALSO, NEXT PROTOCOL NEGOTIATION, AN
APPLICATION LAYER PROTOCOL NEGOTIATION, WHICH
WERE -- BOTH WERE SUGGESTED BY GOOGLE IN
ORDER TO ALLOW THE NEGOTIATION OF SPEEDY AND
NOW HTTP 2, BUT IN THEORY YOU COULD USE IT TO
NEGOTIATE WHATEVER THE NEXT -- ANY PROTOCOL
THAT YOU WANT AND THERE'S CUSTOM HOOKS IN THE
SSL MODULE WHICH LET YOU SAY I WOULD LIKE TO
SPEAK PROTOCOL GOBBLY GOOK INSTEAD OF HTTP 2.
AND INSTEAD TO SUPPORT IT YOU SHOULD BE ABLE
TO SWITCH SEAMLESSLY TO THAT.
THE LAST MORE ADVANCED FEATURE WHICH I WOULD
LIKE TO TALK ABOUT WHICH IS NOT ACTUALLY IN
2.7 BECAUSE IT'S EVEN NEWER THAN 3.4 IS
MEMORY BIO SUPPORT.
SO AS I SAID AT THE BEGINNING OF THE TALK,
ONE OF THE SSL MODULE PROVIDES A SOCKET LIKE
API WHICH JUST SORT OF PRE-TENDS TO BE A RAW
SOCKET AND THEN SPEAKS SSL OVER THE
UNDERLYING RAW SOCKET.
BUT SOMETIMES IT'S USEFUL TO BE ABLE TO
SEPARATE THE ACTUAL IO FROM SPEAKING THE SSL
PROTOCOL.
SO THIS IS WHAT MEMORY BIOA LOW ALLOWS YOU TO
DO.
YOU WRITE A BUNCH OF BYTES TO A BUFFER AND
THEN YOU SAY -- OPEN SSL, TURN THIS INTO A
SSL PROTOCOL FRAME OR SOMETHING.
AND THEN SSL GIVES THAT BACK TO YOU, AND IT
DOESN'T SEND IT ON NETWORK OR ANYTHING, AND
THEN YOU CAN SEND THAT HOWEVER YOU WOULD LIKE
TO.
SO THIS IS MOSTLY USEFUL FOR HIGHER LEVEL
FRAME WORKS LIKE H SYNC IO AND TWISTED HAS
BEEN DOING SOMETHING LIKE THIS USING PI SSL
WHICH IS HAD SUPPORT FOR THIS LONGER.
AND IT'S ONLY IN PYTHON 3.5.
OKAY.
I HOPE YOU THINK THAT WE'RE NOT AT THE
FOREFRONT OF TERRIBLE ANYMORE. THE ONLY THING
ABOUT THIS IS THAT THERE'S USUALLY SOMEONE
WHO IS WORSE THAN YOU.
REALLY.
AND I WOULD ALSO LIKE TO PUT IN A PLUG FOR
REQUESTS WHICH ALSO HAS BEEN DOING STUFF LIKE
THIS FOR MUCH LONGER THAN IT'S BEEN DONE
PROPERLY IN THE STANDARD LIBRARY, AND IS JUST
GENERALLY VERY NICE API FOR MAKING HTTP
REQUESTS.
SO USE REQUESTS AND EVERYTHING WILL BE ALL
RIGHT.
FINALLY, I WOULD LIKE TO THANK A LOT OF
PEOPLE WHO MADE THESE THINGS POSSIBLE.
AND VASTLY IMPROVED THE SECURITY OF PYTHON.
PARTICULARLY, ALEX GAYNOR AND DAVID REID DID
A LOT OF THE BACKPORTING WORK WHICH IS A
MASSIVE TASK.
THOUSANDS OF LINES OF C CODE.
AND NICK COGHLAN AND DONALD STUFFT WROTE A
LOT OF PIPS AND OTHER PEOPLE HELPED WITH
REVIEWING CODE.
AND THERE'S A LOT OF PEOPLE WHO AREN'T NAMED
HERE.
BUT I WOULD LIKE TO PERSONALLY THANK THEM.
AND WITH THAT, HIT ME WITH QUESTIONS.
AND THANK YOU FOR COMING AND NOT GOING TO
PAUL'S TALK.
[ APPLAUSE ]
>> SO WE'VE GOT A FEW MINUTES FOR QUESTIONS.
IF YOU'VE GOT ONE, PLEASE STEP FORWARD AND
COME TO THE MICROPHONE.
HI, BENJAMIN.
THANK YOU.
I'M FROM THE TOUGH PROJECT.
SO MY QUESTION IS HOW OFTEN WOULD YOU UPDATE
THE STDLIB AS YOU FIND SAY NEW CIPHERS THAT
SHOULDN'T BE USED YET?
DOES THAT MEAN YOU WOULD HAVE TO RELEASE A
NEW VERSION OF PYTHON?
>>  YES.
SO I MEAN, AS SOON AS IT SEEMS LIKE THERE'S
CRYPTOGRAPHIC CONSENSUS IN THE SECURITY
COMMUNITY THAT WE SHOULD NOT BE DOING SOME
PARTICULAR THING, USUALLY ESPECIALLY IN THE
CASE OF SAVINGS IT'S NOT VERY HEART TO CHANGE
THE CIPHER STRING.
IN SOME CASES THERE'S ISSUES OF
COMPATIBILITY.
RC4 HAS BEEN KNOWN TO BE WEAK FOR A VERY LONG
TIME BUT IT'S LIKE THE ONLY SORT OF SECURE
PROTOCOL WHICH WINDOWS XP COULD SPEAK -- OR
INTERNET EXPLORER EIGHT ON WINDOWS XP.
I MEAN, IT'S STILL ON, FOR EXAMPLE, GOOGLE
AND OTHER POPULAR SITES BECAUSE THEY FEEL
THAT THEY NEED TO SUPPORT WINDOWS 8.
BUT IT'S -- YEAH, IT'S NOT TOO HARD TO UPDATE
MOST THINGS.
AND THEN THEY WILL JUST COME IN THE NEXT BUG
FIX RELEASE IF WE THINK IT'S WARRANTED.
>>  YOU MENTIONED OFFHANDEDLY THAT THERE'S A
SPECIAL KEY DERIVATION FUNCTION THAT WE'RE
SUPPOSED TO USE FOR HASHING PASSWORDS IN
PLACE OF USING SOMETHING OUT OF A HASH LIB.
SO COULD YOU TALK A LITTLE BIT MORE ABOUT
THAT AND WHAT THAT IS AND WHY THAT'S A GOOD
IDEA AND.
>> YEAH.
SURE.
SO IT'S ACTUALLY IN HASH LIB NOW.
AND IT HAS A -- IT DOES NOT HAVE A VERY GOOD
NAME.
PBKDF 2.
YES.
AND HYNEK IS NODDING.
SO JUST TAKE THE OBSCUREST ONE AND PASS
PASSWORDS TO IT, RIGHT?
YEAH, SO HASHING OBVIOUSLY IS A GOOD START.
BUT WHAT THESE KEY DERIVATION FUNCTIONS DO IS
THEY TRY TO ENSURE THAT DERIVING THE PASSWORD
TAKES SUBSTANTIAL RESOURCES.
SO IF YOU'RE JUST HASHING ONE PASSWORD IT'S
OKAY IF IT TAKES TEN MILLISECONDS OR
SOMETHING BECAUSE YOU'RE ONLY DOING ONE.
BUT IF YOU'RE TRYING TO BREAK PASSWORDS, AND
YOU'RE TRYING TO CREATE THESE RAINBOW, GIANT
TABLES OF PASSWORDS, THEN EVEN A FUNCTION
WHICH TAKES A FEW MILLISECONDS CAN REALLY
SLOW DOWN HASHING BILLIONS AND BILLIONS OF
STRINGS.
AND SO THERE'S OTHER COMPETING FUNCTIONS LIKE
S CRYPT, BUT THEY'RE ALL PRETTY GOOD.
AND SO THAT'S CONSIDERED TO BE MODERN
STANDARD IN PASSWORD HASHING IF THAT MAKES
SENSE.
>>  THANK YOU.
>>  NO MORE INQUIRIES?
ALL RIGHT.
THANK YOU AGAIN.
[ APPLAUSE ]
>>  HELLO, EVERYONE.
SO LUNCH IS BEING SERVED IN THE EXPO HALL,
210, THE SAME PLACE WHERE BREAKFAST WAS
SERVED IN THE MORNING.
THANK YOU VERY MUCH.
AND HAVE A NICE DAY.
[ LUNCH BREAK ]
