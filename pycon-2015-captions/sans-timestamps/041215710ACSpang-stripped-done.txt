OUR NEXT SPEAKER IS CHRISTINE
SPANG.
LET'S GIVE HER A WARM WELCOME.
[ Applause ]
>> HEY, EVERYBODY.
GOOD AFTERNOON.
HEY!
[SCATTERED APPLAUSE]
>> WE'RE GONNA BE TALKING ABOUT
WEBSOCKETS TODAY.
SO WEBSOCKETS IS COOL BECAUSE
THEY ENABLE US TO BUILD WEB
APPLICATIONS THAT ARE BOTH
REAL-TIME AND THAT SCALE REALLY
WELL.
SO IN THIS TALK, I'M GONNA GIVE
YOU SOME HISTORICAL CONTEXT FOR
WHY WE NEEDED WEBSOCKETS IN THE
FIRST PLACE.
THEN I'M GONNA EXPLAIN TO YOU
HOW THE PROTOCOL ACTUALLY WORKS
AND I'LL TAKE A LOOK AT A TCP
DUMP OF WEBSOCKETS IN ACTION.
THINGS YOU NEED TO KEEP IN MIND
WHEN ONE OF RUNNING WEBSOCKETS
APPLICATIONS IN PRODUCTION.
ALL RIGHT, A LITTLE BIT ABOUT
ME.
MY NAME IS CHRISTINE SPANG.
I'VE BEEN PROGRAMMING SINCE I
WAS IN HIGH SCHOOL.
AFTER THAT I WENT TO M.I.T.
AND THEN I SPENT THREE YEARS
WORKING AT A COMPANY CALLED
K-SPLICE.
TODAY I'M ONE OF THE COFOUNDERS
AT A COMPANY CALLED NYLAS, A
STARTUP IN SAN FRANCISCO.
WE'RE BUILDING A PLATFORM THAT
MAKES IT EASY FOR YOU TO BUILD
APPLICATIONS THAT USE DATA FROM
EMAIL, CONTACTS, AND CALENDARS.
ALL RIGHT, ENOUGH WITH THE
INTROS.
LET'S GET TO THE TALK.
FIRST WE'RE GONNA TALK ABOUT
WHAT WEBSOCKETS ARE.
THEN I'LL GIVE YOU A PYTHON
EXAMPLE, AND AN EXAMPLE THAT'S A
BIT MORE REAL WORLD.
THEN WE'LL TALK ABOUT
PERFORMANCE AND THEIR USE IN
PRODUCTION.
ALL RIGHT, LET'S DIVE IN.
SO WHAT ARE WEBSOCKETS?
SO ANSWER THIS QUESTION, I'M
FIRST GONNA GIVE YOU SOME OF THE
HISTORY OF PROTOCOLS POWERING
WEB APPLICATIONS, THE
SHORTCOMINGS THEY HAD, AND HOW
WEB DEVELOPERS ATTEMPTED TO
ADDRESS THOSE SHORTCOMINGS.
ALONG THE WAY, I'LL SHOW YOU HOW
WEBSOCKETS TOOK A CONCEPT AND
ADAPTED IT FOR THE WEB TO ENABLE
NEW KINDS OF WEB APPLICATIONS TO
BE BUILT.
SO HERE'S A DIAGRAM THAT SHOWS
HOW HTTP WORKS.
HOW MANY HERE HAVE USED HTTP,
UNDERSTAND HOW IT WORKS?
OKAY, GOOD.
THAT'S GOOD BACKGROUND FOR THIS
TALK.
SO TO QUICKLY OVERVIEW, OR
REVIEW RATHER, YOU HAVE WEB
SERVERS WHICH HOST THE STATIC
HTML PAGES AND AID KEYED THAT
MAKES UP THE WEB APPLICATION,
AND THEN YOU HAVE BROWSERS WHICH
ARE CLIENTS THAT TALK TO THE WEB
SERVER USING HTTP TO RETRIEVE
CONTENT TO SHOW USERS VIA THE
WEB BROWSER.
HERE'S AN EXAMPLE OF WHAT A
TYPICAL GET REQUEST IN HTTP
LOOKS LIKE.
YOU CAN SEE THAT THE -- THE
BASIC REQUEST IS THE VERB, GET,
AND THE ARGUMENT, IN THIS CASE
SLASH, AND THEN WE HAVE A WHOLE
BUNCH OF OTHER INFORMATION IN
THIS REQUEST THAT ARE HEADERS
THAT GO ALONG WITH THE REQUEST.
AND YOU CAN SEE FROM JUST THE
EXCERPT UP HERE THAT MOST OF AN
HTTP REQUEST IS ACTUALLY THE
HEADERS AND NOT THE ACTUAL
ACTION THAT WE'RE TRYING TO DO.
THIS IS IMPORTANT FOR LATER.
SO TO CONTINUE WITH THE
BACKGROUND, THE WEB WAS
ORIGINALLY CREATED BY TIM
BERNERS-LEE TO SHARE STATIC
ACADEMIC DOCUMENTS, AND SO THIS
BASIC MODEL WHERE A CLIENT
REQUESTS A PAGE, OPENS A
CONNECTION TO DO THAT, AND GETS
A PAGE BACK, WORKED REALLY WELL
TO SHARE ACADEMIC DOCUMENTS.
BUT AS TIME WENT ON, PEOPLE
WANTED TO CREATE ACTUAL SOFTWARE
PROGRAMS WHERE MOST OF THE WORK
WAS DONE ON THE SERVER AND THE
BROWSER JUST ACTS AS A THIN
CLIENT, RETRIEVING NEW DATA AND
RENDERING IT TO THE USER.
SO THERE ARE A NUMBER OF REASONS
TO WANT TO DO THIS, SUCH AS NOT
WANTING TO SEND NEW UPDATES TO
THE USERS'S COMPUTERS.
YOU CAN CREATE INTERACTIVE
APPLICATIONS.
THE MAIN WRENCH IS THAT EVERY
TIME SOME INTERACTION HAPPENS,
SAY, A USER CLICKS ON A LINK OR
A BUTTON OR THE APP WANTS TO
REFRESH THE PAGE TO UPDATE THE
INFORMATION BEING DISPLAYED, IT
HAS TO INITIATE AN ENTIRELY NEW
HTTP CONNECTION TO THE SERVER,
SEND IT THE REQUEST, AND RECEIVE
A RESPONSE.
AND AS I SHOWED ON THE PREVIOUS
SLIDE, IT TURNS OUT THAT A
LOT -- THERE'S A LOT OF DATA
BEING SENT IN EVERY HTTP
REQUEST.
THE AVERAGE HTTP HEADER REQUEST
IS ACTUALLY ABOUT 800 BYTES.
SO THIS SLIDE PREVIOUSLY SHOWS A
REALLY BASIC REQUEST, BUT MORE
COMPLEX REQUESTS CONTAIN EVEN
MORE HEADERS SUCH AS COOKIES
WHICH ARE ACTUALLY SENT ON EVERY
SINGLE HTTP REQUEST.
SO WHEN WE CREATE WEB APPS USING
PLAIN OLD HTTP, BUT ONCE YOU
START TO TRYING TO DO THINGS
THAT ARE MUCH MORE INTERACTIVE,
YOU START TO RUN INTO THE
PROBLEM THAT THIS MODEL IS VERY
SLOW.
WE COULD REFRESH THE PAGE EVERY
TIME WE WANTED TO USERS TO
INTERACT WITH THE SITE.
BUT IT TAKES A LONG TIME.
EVEN IN THE BEST CASE SCENARIO,
WE'RE LIMITED BY THE SPEED OF
LIGHT.
SO BETWEEN BOSTON AND
SAN FRANCISCO, IN THE BEST CASE,
LIGHT TAKES ABOUT 40
MILLISECONDS TO GO BACK AND
FORTH, AND IN A MORE AVERAGE
CASE, YOU'RE LOOKING AT MORE
LIKE 80 MILLISECONDS, PLUS MORE
TIME TO TRANSFER ANY DATA WHICH
INCLUDES THOSE HTTP HEADERS,
WHICH ARE REALLY BIG, AND ALSO
TIME TO BOOTSTRAP THE TCP
CONNECTION.
SO IF YOU'RE GONNA TRANSFER A
LOT OF DATA USING TCP, YOU HAVE
TO BOOTSTRAP THE CONNECTION OVER
A COUPLE OF BACK-AND-FORTHS TO
INCREASE THE WINDOW SIZE.
SO DEVELOPERS TRIED TO WORK
AROUND THESE PROBLEMS IN A
NUMBER OF DIFFERENT WAYS.
ONE OF THE FIRST WAYS WAS THIS
METHOD THAT ENDED UP BEING
CALLED AJAX, ASYNCHRONOUS
JAVASCRIPT.
YOU WIRE THAT PIECE OF
JAVASCRIPT UP TO A BUTTON THAT
YOU WANT TO TALK TO THE SERVER,
AND IT CAN GET THE RESPONSE AND
THEN POTENTIALLY UPDATE A SUBSET
OF THE CURRENT PAGE WITH NEW
DATA.
SO THIS ALLOWS US TO UPDATE
PAGES WITHOUT COMPLETELY
REFRESHING THEM, BUT IT STILL
HAS TO CREATE ANOTHER HTTP
CONNECTION, INCLUDING OPENING A
NEW TCP CONNECTION TO THE
SERVER, EVERY TIME IT WANTS TO
SEND DATA BACK AND FORTH.
CLIENTS CAN USE AJAX TO PULL A
WEB SERVER TO UPDATE PAGES AS
WELL.
SO THIS WAS AN IMPROVEMENT ON
THE SIMPLE MODEL WHERE YOU JUST
SEND AND GET REQUESTS AND GET
THE RESPONSE BACK, RELOADING THE
WHOLE PAGE, BUT IT DIDN'T
FUNDAMENTALLY CHANGE THE MODEL
OF HOW WEB APPLICATIONS
OPERATED.
ONE PROBLEM WAS THAT IF
COMPUTATION WAS HAPPENING ON THE
SERVER AND THE CLIENT WANTED TO
KEEP IT UPDATED, IT HAD TO PULL
OR KEEP CHECKING IN AND CREATE A
NEW CONNECTION EVERY TIME.
SO ANOTHER LIMITATION THAT WEB
APPS HAD COMPARED TO, SAY, A
DESKTOP APPLICATION WAS THAT UP
UNTIL THIS POINT IN TIME, THE
COMMUNICATION BETWEEN THE CLIENT
AND SERVER WAS FUNDAMENTALLY
ONE-WAY.
SO WEB DEVELOPERS ARE REALLY
SMART PEOPLE, AND THEY CAME UP
WITH A WAY TO WORK AROUND THIS
AS WELL.
THE THING THEY CAME UP WITH NEXT
WAS A MODEL CALLED COMET, OR
SOMETIMES LONG-PULLING.
THIS INVOLVED KEEPING A
LONG-LIVED HTTP CONNECTION OPEN
UNTIL A TIMEOUT EXPIRES OR THE
SERVER HAS SOME DATA TO RETURN
TO THE CLIENT.
THE CLIENT THEN OPENS ANOTHER
HTTP CONNECTION TO THE SERVER
AND CONTINUES TO WAIT FOR DATA.
SO THIS WORKED PRETTY WELL
ACTUALLY.
BUT THERE WAS ONE CASE THAT WAS
LEFT WHERE IT STILL DEGRADED,
AND THAT'S IF THE APPLICATION
NEEDED TO PASS DATA OR MESSAGES
BACK AND FORTH FROM THE CLIENT
TO THE SERVER AT A REALLY HIGH
INTERVAL.
SO THIS IS AN ACTUAL CODE
FROM -- QUOTE FROM ONE OF THE
WEBSOCKETS RFCS, AND IT SAYS,
"HISTORICALLY, CREATING WEB
APPLICATIONS THAT NEEDED
BIDIRECTIONAL COMMUNICATION
BETWEEN A CLIENT AND SERVER,
E.G., GAMING AND INSTANT
MESSAGING APPLICATIONS, HAS
REQUIRED AN ABUSE OF HTTP TO
POLL THE SERVER FOR UPDATES
WHILE SENDING UPSTREAM
NOTIFICATIONS AS DISTINCT HTTP
CALLS."
SO IT'S RIGHT THERE IN THE RFC,
WHY WE NEEDED TO COME UP WITH
SOMETHING THAT WAS DIFFERENT.
OH, OOPS.
THAT'S NOT RIGHT.
IN ORDER TO BE ABLE TO IMPLEMENT
PROPER REAL-TIME APPLICATIONS,
APPS THAT WERE SENDING SMALL
MESSAGES BACK AND FORTH BETWEEN
CLIENT AND SERVER OFTEN, WE
REALLY NEEDED A PROTOCOL THAT
ALLOWED-TWO WAY COMMUNICATION
WITH LOW LATENCY, AND THAT'S
WHERE WEBSOCKETS CAME IN.
SO NOW YOU HAVE SOME HISTORICAL
CONTEXT.
LET'S TALK ABOUT HOW THE
WEBSOCKETS PROTOCOL ACTUALLY
WORKS NOW SO WE CAN BETTER
UNDERSTAND HOW IT EVOLVED AND
HOW IT ALLOWS DIFFERENT KINDS OF
APPS TO EXIST ON THE WEB.
IN ORDER TO DO THIS, WE HAVE TO
TAKE A LOOK AT ANOTHER PIECE OF
COMPUTING HISTORY.
OR WHAT THE WORD "SOCKET"
ACTUALLY MEANS IN A COMPUTING
CONTEXT ANYWAY.
IN THE 1970s, WHEN UNIX WAS
DEVELOPED, PART OF THE OPERATING
SYSTEM API THAT BRIAN
KERNIGHAN -- CONTAINED AN API
CALLED A SOCKET.
I HAVE NO IDEA WHY THEY CALLED
IT THIS.
AND I ASKED THE INTERNET, AND NO
ONE KNEW EITHER.
SO WHO KNOWS.
SO UNIX DOMAIN SOCKETS WERE USED
FOR LOCAL INTERPROCESS
COMMUNICATION, OR IPC, ON A
SINGLE SERVER.
YOU WOULD MAKE A CALL TO THE
SOCKET CALL, AND THEN YOU GET A
FILE DESCRIPTOR, YOU COULD USE
TO COMMUNICATE BETWEEN
PROCESSES.
THE SOCKET WAS A BIDIRECTIONAL
LINK BETWEEN TWO DIFFERENT
PROGRAMS WHICH IT COULD USE TO
SEND MESSAGES BACK AND FORTH.
IF YOU USED THE SOCKET SYSCALL
IN LINUX, YOU CAN ALSO USE IT TO
CREATE A SOCKET THAT GOES ACROSS
THE NETWORK.
SO YOUR PROGRAM ON A LOCAL
COMPUTER CAN OPEN UP A SOCKET TO
A GAME SERVER, AND THE GAME
SERVER CAN SEND THE PROGRAM
UPDATES OR VICE VERSA.
SO THE LINUX SOCKET API IS
REALLY SUPER SIMPLE.
IT CONSISTS OF THREE SYSCALLS:
SOCKET, WHICH CREATES THE SOCKET
DESCRIPTOR; AND THEN THERE'S
SEND AND RECEIVE, WHICH WERE
USED TO PASS MESSAGES BACK AND
FORTH.
I BRING ALL THIS UP BECAUSE IT
TURNS OUT THAT YOU CAN THINK OF
WEBSOCKETS AS BASICALLY UNIX
SOCKETS FOR WEB APPLICATIONS.
THE WEBSOCKETS PROTOCOL AND API
WERE INTRODUCED AS A PART OF THE
HTML 5 SPECIFICATION, BUT THEY
WERE EVENTUALLY SPLIT OUT IN
ORDER TO KEEP HTML 5 SIMPLER.
BEFORE WEBSOCKETS, THERE WERE
SOME WAYS TO OPEN UP SOCKETS IN
WEB APPLICATIONS, BUT THERE WAS
NO STANDARD API FOR IT.
YOU HAD TO USE A NONSTANDARD
BROWSER EXTENSION LIKE FLASH IN
ORDER TO DO IT.
THE WEB SOCKET SPEC MADE THE
IDEA OF USING WEBSOCKETS
STANDARD AND ALSO DEALT WITH
PROBLEMS UNIQUE TO WEB
APPLICATIONS TRYING TO USE
SOCKETS LIKE DEALING WITH
FIREWALLS AND PROXIES.
SO THE THINGS LAID OUT IN THE
WEBSOCKETS ARE -- WITH HOW THE
WEBSOCKETS API WORKS AND THE
PROTOCOL WORKS WERE SPECIFICALLY
DESIGNED TO MAKE IT EASY TO USE
SOCKETS USING EXISTING WEB
INFRASTRUCTURE.
SO FOR EXAMPLE, IT'S A PROBLEM
TO USE SOCKETS ON DIFFERENT
PORTS THAN PORT 80 OR PORT 443
BECAUSE PROXIES AND FIREWALLS
WILL ACTUALLY DROP TRAFFIC OR
BLOCK TRAFFIC TO THESE PORTS.
SO WEBSOCKETS WERE SPECIFICALLY
DESIGNED TO BE
BACKWARDS-COMPATIBLE WITH THIS
INFRASTRUCTURE.
SO WEBSOCKETS MAKE REAL-TIME
APPS POSSIBLE ON THE WEB, BUT
WHAT'S A REAL-TIME APP?
BASICALLY THAT MEANS ANYTHING
LIVE UPDATING AT HIGH FREQUENCY.
FOR EXAMPLE, GAMES, STOCK
TICKERS, CHAT PROGRAMS.
THE CHAT PROGRAM SLACK, FOR
EXAMPLE, USES WEBSOCKETS TO
CONNECT FROM THE WEB BROWSER
CLIENT TO THE SERVER.
SO NOW I WANT TO TAKE A LOOK AT
A SUPER SIMPLE WEBSOCKETS
EXAMPLE USING PYTHON.
ALL RIGHT.
THERE WE GO.
UH... NOT THIS ONE.
WE WANT THIS ONE.
OKAY.
HOPEFULLY YOU GUYS CAN SEE THAT
OKAY.
SO... SO I'VE CREATED A LITTLE
EXAMPLE HERE USING THE
WEBSOCKETS LIBRARY, WHICH IS A
PYTHON 3 ONLY LIBRARY THAT IS
BUILT USING ASYNCIO.
SO LET'S TAKE A REALLY QUICK
LOOK AT THIS CODE.
YOU CAN SEE THAT IT CONSISTS OF
A SINGLE FUNCTION.
AND BASICALLY USES THIS
WEBSOCKETS LIBRARY TO SERVE THAT
SINGLE FUNCTION ON LOCAL HOSTS
ON THIS PORT 8765.
AND THEN IT JUST RUNS IN A LOOP
FOREVER AND SERVES THIS FUNCTION
TO EVERY CONNECTION THAT
CONNECTS TO THIS PORT.
>> [ Inaudible ]
>> SURE.
I THINK I'M GONNA, LIKE, DO IT
HERE, OR, LIKE, MAKE A NEW
TERMINAL.
UM... IT'S REALLY ANNOYING TO
BRING THINGS UP IN VIM, BECAUSE
THE COLOR SCHEME IS TERRIBLE ON
A PROJECTOR.
OKAY.
I DON'T WANT, LIKE, SPEND TOO
MUCH TIME FIDDLING AROUND WITH
THIS.
SORRY.
I CAN DO, LIKE, THIS.
HERE, OR, OOPS.
MAKE IT BIGGER.
[ Applause ]
SUCCESS!
YOU DON'T GET SYNTAX
HIGHLIGHTING NOW, THOUGH.
BUT THERE'S NOT A LOT OF CODE
HERE, SO YOU DON'T REALLY NEED
THE HIGHLIGHTING.
BASICALLY THIS USES THE "YIELD
FROM" EXPRESSION FROM PYTHON 3.
TO MAKE THIS ASYNCHRONOUS.
AND THIS IS THE CLIENT, RIGHT?
SO THE CLIENT -- I WAS LOOKING
AT THE SERVER BEFORE, BUT THE
CLIENT WILL CONNECT TO THE
SERVER RIGHT HERE, SO WEBSOCKETS
URLs LOOK LIKE WEBSOCKETS,
COLON, SLASH, SLASH.
THEN YOU'LL DO WEBSOCKET.SEND TO
SEND A MESSAGE.
AND THEN IN THE SERVER, YOU CAN
ACTUALLY SEE THAT IT DOES
WEBSOCKET.RECEIVE TO RECEIVE A
MESSAGE.
SO THIS IS EXACTLY THE SAME API
AS WE SAW ON THE LINUX SOCKET
API.
IT'S CREATE A WEB SOCKET.
SEND AND RECEIVE.
SUPER SIMPLE.
AND ACTUALLY WANT TO SHOW YOU
GUYS THIS RUNNING.
SO I CAN FIRE UP A SERVER.
OH, OOPS.
VIRTUAL M... OKAY.
SO NOW THE SERVER'S RUNNING.
AND THEN I WANT TO MAKE THIS
BIGGER.
SO THEN WE CAN FIRE UP THE
CLIENT AND SAY, HI, MY NAME IS
SPANG.
AND IT SAYS HELLO.
AND THEN WE CAN GO BACK TO THE
SERVER AND SEE IT ALSO SAYS
HELLO.
SO IF THIS WERE A BETTER DEMO, I
WOULD DO LOTS OF THESE IN
PARALLEL, AND YOU COULD SEE THAT
IT WOULD JUST SEND THIS AT THE
SAME TIME.
BUT THIS IS A SUPER SIMPLE
EXAMPLE.
AND I WANT TO KEEP IT SUPER
SIMPLE BECAUSE I ACTUALLY WANT
US TO TAKE A LOOK AT WHAT ACTUAL
TRAFFIC IS GOING OVER THE WIRE.
SO YOU CAN USE A PROGRAM CALLED
TCP DUMP TO CAPTURE INTERNET
TRAFFIC BETWEEN TWO DIFFERENT
SERVERS OR BETWEEN THE SAME
SERVER, BETWEEN YOUR LAPTOP AND
YOUR LAPTOP.
AND I WANT US TO DO THAT RIGHT
NOW.
SO I'M NOT GONNA RUN, LIKE, THE
SUPER LIVE TCP CAPTURE, BUT I'M
JUST GONNA SHOW YOU HOW TO DO
IT.
SO GENERALLY, TO CAPTURE
WEBSOCKETS TRAFFIC, YOU'D RUN
TCP DUMP, AND IT HAS A LOT OF
OBSCURE ARGUMENTS THAT YOU
SHOULD READ THE MAN PAGE TO
FIGURE OUT WHAT THEY MEAN.
YOU WANT TO CAPTURE TCP TRAFFIC
AND HTTP TRAFFIC ON THIS
SPECIFIC PORT.
AND THIS SAYS TO LIKE OUTPUT IT
TO THIS DUMP FILE.
SO ACTUALLY HAVE THIS DUMP FILE,
WEB SOCKET SIMPLE DUMP, WHICH IS
A TCP DUMP CAPTURE FILE.
AND THEN THERE'S THIS TOOL FOR
LOOKING AT WEB TRAFFIC THAT IS
CALLED WIRESHARK THAT WE CAN USE
TO TAKE A LOOK AT THIS.
SO IF I PULL UP THIS DUMP FILE
IN WIRESHARK, SO I WANT TO CLEAR
THE FILTER HERE FIRST.
SO THIS IS A DUMP OF DOING THE
SAME INTERACTION THAT WE SAW
BEFORE, AND THAT WAS, LIKE,
CONNECTING A SIMPLE CLIENT, AND
SEEING THE SERVER RESPOND TO IT.
SO YOU CAN SEE THAT IT
BOOTSTRAPS A TCP CONNECTION,
SENDS AN -- ALL RIGHT, WE GOT A
TCP CONNECTION.
AND THEN IT SENDS AN HTTP
REQUEST.
SO THIS IS A REALLY IMPORTANT
PART OF WEBSOCKETS.
IT HAS TO DO WITH THIS WHOLE
BACKWARDS-COMPATIBILITY THING
THAT I SAID EARLIER.
BOOTSTRAPPED OVER HTTP.
SO WHEN YOU HAVE A WEBSOCKETS
APPLICATION, YOU SEND AN HTTP
REQUEST TO START IT, BECAUSE
EVERYTHING UNDERSTANDS WHAT HTTP
IS AND NOT EVERYTHING
UNDERSTANDS WHAT WEBSOCKETS ARE.
SO... YEAH, HERE WE GO.
SO I WANT TO APPLY A FILTER ON
THIS SO WE GET RID OF ALL THE
TCP BOOTSTRAPPING PACKETS.
YEAH.
OOPS.
HTTP OR WEBSOCKETS.
THERE WE GO.
OKAY, COOL.
SO THIS IS THE INTERESTING STUFF
HERE.
SO YOU SEE IT STARTS WITH A GET,
SLASH, BOOTSTRAPPING OVER HTTP.
THEN YOU CAN SEE THE NEXT PART
IS A SPECIAL HTTP STATUS CODE
CALLED THE 101 SWITCHING
PROTOCOLS.
SO 101 SWITCHING PROTOCOLS IS
HOW THE SERVER TELLS THE CLIENT
THAT WE'RE GONNA SWITCH OVER TO
USING WEBSOCKETS INSTEAD OF
BASIC HTTP.
SO AFTER THAT, WE DIVE INTO THE
WEBSOCKETS FRAMES.
SO WEBSOCKETS WERE DESIGNED TO
BE SUPER MINIMAL, IN THAT THE
OVERHEAD PER FRAME IS REALLY
SMALL.
SO YOU CAN ACTUALLY USE
WIRESHARK TO TAKE A LOOK AT THE
ACTUAL DATA THAT'S BEING SENT,
AND IF YOU SEE HERE, IT'S WEB
SOCKETS, AND IT WILL SHOW YOU
THE ACTUAL DATA THAT'S IN THIS
PACKET.
SO THE FIRST THINGS UP AT THE
TOP ARE THE PADDING.
THIS IS ONE BIT CALLED FIN,
WHICH DESIGNATES WHETHER OR NOT
THIS IS LIKE THE LAST PACKET.
SO IF YOU'RE SENDING A BUNCH OF
DATA, YOU'RE GONNA HAVE TO HAVE
MULTIPLE FRAMES.
SO THIS HAPPENS TO BE A SMALL
PACKET, SO IT SAYS... YES, ONE,
THIS IS THE END.
THEN THERE'S A FEW RESERVED
BYTES.
THEN THERE'S THIS THING CALLED A
MASK.
AND THE MASK IS ALSO PART OF WHY
WEBSOCKETS ARE COMPATIBLE WITH
EXISTING INTERNET
INFRASTRUCTURE.
SO THE MASK AND THE MASKING KEY
ARE USED BY CLIENTS SENDING DATA
TO THE SERVER TO OBFUSCATE THE
PAYLOAD WHICH MAKES IT LESS
LIKELY THAT VARIOUS SERVERS IN
THE MIDDLE LIKE BETWEEN VARIOUS
DIFFERENT PACKET HOPS WILL MESS
WITH THE PAYLOAD AND JUST BREAK
EVERYTHING.
SO THEN WE ALSO HAVE A PAYLOAD
LENGTH SO WE KNOW HOW MANY
PACKETS TO EXPECT.
AND THEN WE ACTUALLY JUST HAVE
THE PACKET OR THE PAYLOAD.
AND YOU CAN SEE -- I DON'T KNOW
IF THIS IS DECODED.
OH, YEAH.
SO YOU HAVE THE PAYLOAD HERE,
AND THEN YOU HAVE THE PAYLOAD
WITH THE MASK APPLIED.
SO YOU CAN SEE IT WAS JUST
SENDING MY NAME, SPANG.
SO THAT'S THE BASICS OF HOW THE
PROTOCOL WORKS.
SO IT'S SUPER SIMPLE.
AND LET'S GO BACK TO THE SLIDES.
HERE'S A LITTLE DIAGRAM OF THIS
WEB SOCKET PROTOCOL
BOOTSTRAPPING PROCESS THAT WE
WERE TALKING ABOUT.
SO AGAIN, YOU START THE PROCESS
USING BASIC HTTP.
YOU ISSUE A GET REQUEST.
THEN THE SERVER -- WITH
CONNECTION UPGRADE.
THEN THE SERVER ALSO RESPONDS
WITH THIS SPECIAL CODE CALLED
HTTP 101 SWITCHING PROTOCOLS.
AND THEN THE CONVERSATION CAN
CONTINUE FROM THERE, SENDING
MESSAGES BACK AND FORTH.
EITHER THE CLIENT OR THE SERVER
CAN SEND A MESSAGE EITHER WAY AT
THAT POINT BECAUSE WE'RE USING
WEBSOCKETS AND NOT HTTP.
AND THAT CONNECTION WILL BE
CLOSED AS SOON AS EITHER THE
SERVER OR THE CLIENT CLOSES IT
BECAUSE IT'S BIDIRECTIONAL.
WE ALREADY TALKED ABOUT THIS,
SWITCHING PROTOCOLS.
THAT'S HOW IT STARTS UP.
OKAY, SO NOW I WANT TO SHOW YOU
GUYS AN EXAMPLE THAT'S A BIT
MORE REAL WORLD.
BACK IN THE DAY WHEN -- I THINK
IT WAS, LIKE, 2006 OR 2007 OR
SOMETHING LIKE THAT, WHEN
WEBSOCKETS WERE SUPER NEW,
MOZILLA CREATED THIS GAME CALLED
BROWSER QUEST IN ORDER TO
DEMONSTRATE HOW WEBSOCKETS WERE
INTERESTING AND USEFUL.
SO GAMES ARE A REALLY GREAT
APPLICATION FOR WEBSOCKETS
BECAUSE, YOU KNOW, IF YOUR
CHARACTER'S MOVING AROUND, YOU
MIGHT WANT TO SEND, LIKE, LITTLE
UPDATES ABOUT WHERE THE
CHARACTER'S MOVING TO OR IF
THERE'S, LIKE, A BATTLE GOING
ON, YOU WANT TO SEND THOSE
BATTLE COMMANDS AND UPDATE ALL
THE OTHER CHARACTERS THAT ARE
LOGGED INTO THE SAME SERVER.
AND IT'S IMPORTANT TO BE ABLE TO
SCALE THESE THINGS TO LARGE
SIZES.
SO THE AMOUNT OF DATA THAT
YOU'RE SENDING OVER THE WIRE CAN
BE REALLY IMPORTANT.
SO I -- THE BROWSER QUEST GAME
WAS A BIT ROTTED, SO I HAD TO
FORK IT TO MAKE THIS WORK, SO --
>> [ Inaudible ]
>> I DID, BUT THEY TOLD ME THAT
THEY'RE NOT MAINTAINING IT
ANYMORE AND THEY WOULDN'T TAKE
IT.
SO YOU'LL HAVE TO USE MY FORK IF
YOU WANT IT TO WORK.
>> [ Inaudible ]
[ Laughter ]
>> I'M SURE THAT WILL BE A MORE
COMPELLING CASE.
ALL RIGHT, COOL.
SO I HAVE A VM THAT I SET UP
THAT'S RUNNING THIS GAME.
UNFORTUNATELY, IT'S ALSO -- THE
GAME'S ALSO RAN IN NODE.JS.
BLAME MOZILLA.
SO HERE'S THE GAME SERVER
RUNNING IN MY VM.
AND THEN I'M GONNA CLOSE THESE
ONES THAT I'M NOT USING ANYMORE.
I DON'T NEED THAT ONE.
I DON'T NEED WIRESHARK ANYMORE
EITHER.
MAKE IT GO AWAY.
OKAY.
SO THIS IS THE GAME.
AND THEN ACTUALLY WE NEED A WEB
BROWSER, WHICH IS OUR CLIENT.
SO I THINK I HAVE IT RUNNING ON
THIS LOCAL IP ADDRESS HERE.
OH, NO.
DAMN IT!
OKAY.
I WANT IT TO START FROM THE
BEGINNING.
AND I ALSO WANT TO USE THE
CHROME DEV TOOLS.
ALL RIGHT, CHROME DEV TOOLS ARE
AWESOME, BY THE WAY.
OKAY.
SO WE CONNECT, AND THEN IT ASKS
FOR YOUR NAME.
SO I'M GONNA SAY SPANG.
AND THEN WE CAN JUST HIT PLAY.
SO THAT WAS IT.
IT WAS CONNECTING TO THE
WEBSOCKETS SERVER.
AND USUALLY WHEN YOU'RE RUNNING
A WEBSOCKETS APPLICATION, YOU
RUN IT BEHIND A PROXY LIKE
ENGINE X OR APACHE OR WHATEVER.
OKAY.
SO THEN WHAT I WANT TO LOOK IS
THE NETWORK TAB HERE.
AND THE INTERESTING PART OF THE
CHROME DEV TOOLS, SO THEY HAVE
NATIVE SUPPORT FOR DEBUGGING
WEBSOCKETS, AND ALL YOU HAVE TO
DO IS SCROLL THROUGH THIS REALLY
LONG LIST OF RESOURCES LOADING
AND FIND THE ONE THAT'S
WEBSOCKETS.
SO GIVE ME ONE SECOND.
WHERE IS THE FILTER, BY THE WAY?
ON THE LEFT?
WHICH BUTTON?
OH, THE SEARCH?
THE FUNNEL.
OKAY.
THANK YOU.
101.
NO.
OH, HERE WE GO.
NICE.
AWESOME.
THANKS FOR THAT TIP, GUYS.
OKAY.
SO THEN OVER HERE ON THE RIGHT,
YOU HAVE THE GENERAL INFORMATION
ABOUT THE WEBSOCKETS CONNECTION.
AND THEN YOU CAN LOOK AT THE
INDIVIDUAL -- BLAH -- THE
INDIVIDUAL FRAMES.
SO -- OH, THIS IS -- HERE WE GO.
THERE YOU GO.
SO YOU CAN SEE THAT WHENEVER I
CLICK SOMEWHERE, IT IS SENDING
SOME DATA BACK TO THE SERVER,
AND THEN IF WE GO BACK TO OUR
TERMINAL, I CAN ALSO SEE THAT
IT'S LIKE SPANG IS MOVING TO
39-209.
SO IT'S SENDING THESE LISTS OF
NUMBERS BACK AND FORTH.
SO WE'RE RUNNING OUT OF TIME, SO
I'M GONNA TRY TO WRAP THIS UP.
BUT THE REALLY INTERESTING THING
HERE IS THAT THIS COULD SCALE TO
A TON OF CONNECTIONS BECAUSE
WE'RE ONLY SENDING TINY LITTLE
BITS OF DATA.
OKAY.
ALL RIGHT.
I GOT TO WRAP THIS UP.
SO I'M GONNA GO THROUGH, LIKE,
TWO SLIDES MORE.
SO -- PERFORMANCE.
JUST TO REMIND YOU, WEBSOCKETS
HAVE OVERHEAD OF LIKE 2 TO 14
BYTES COMPARED TO HTTP WHICH IS
800 BYTES PER CONNECTION.
YOU PROBABLY ONLY NEED TO USE
WEBSOCKETS IF YOU NEED TO SCALE
YOUR APPLICATION TO A LOT OF
CONNECTIONS BECAUSE OTHERWISE IT
DOESN'T REALLY MATTER.
SO ABOUT 80% OF BROWSERS TODAY
HAVE SUPPORT FOR WEBSOCKETS.
AND 20% DON'T.
SO YOU SHOULD USE A POLYFILL
LIBRARY, USUALLY SOCKET.IO, IN
ORDER TO NOT MAKE YOUR
APPLICATION NOT WORK FOR THOSE
APPS.
OKAY.
ALL RIGHT.
SO THAT'S ALL I HAVE FOR YOU
FOLKS TODAY.
THIS WENT A LITTLE BIT QUICKLY.
SO I ALSO HAVE SOME LINKS HERE
IF YOU WANT TO LEARN MORE.
AND I DIDN'T REALLY GET A CHANCE
TO GO INTO SPECIFICS ABOUT WHAT
YOU SHOULD USE WITH PYTHON.
THERE IS A LIBRARY CALLED FLASK
SOCKET.IO WHICH I THINK IS A
GOOD CHOICE FOR BUILDING APPS
THAT NEED A POLYFILL.
THANK YOU.
[ Applause ]
>> IF YOU HAVE QUESTIONS, I'LL
BE OUTSIDE, BECAUSE WE DON'T
HAVE ANY MORE TIME RIGHT NOW.
  10
  11
  12
  13
  14
  15
  16
  17
  18
  19
  20
  21
  22
  23
  24
  25
