WELCOME BACK.
SO WE NOW HAVE DON TRACY.
[NO AUDIO]
[APPLAUSE]
>> HI, EVERYONE.
WELCOME TO THE TALK.
IT'S CALLED --
EASY DEPLOYMENT OF PIP.
MY NAME IS DAN TRACY.
YOU CAN FIND ME ON GITHUB, TWITTER.
USUAL GO DJT5019.
A BUNCH OF INITIALS AND NUMBERS.
I WORK AT AWEBER COMMUNICATIONS.
BASED OUT OF PENNSYLVANIA.
YOU CAN ACTUALLY SEE OUR COMPANY LOGO AROUND THE
LANYARDS YOU'RE ALL WEARING.
HERE I DO A LOT OF DEVOPS STUFF.
I LIKE MESSING WITH CHEF.
AND WHEN I STARTED WORKING, I REALIZED WE HAD A LOT
OF WAYS TO TAKE OUR CODE, AND PUSH IT OUT IN FRONT
OF CUSTOMERS.
SOME OF THEM WERE GOOD, SOME OF THEM WEREN'T.
BUT I'LL GET INTO THAT A LITTLE MORE LATER.
SO, YOU KNOW, WHAT'S THIS TALK ABOUT?
I'LL BE UP FRONT AND HONEST WITH YOU.
I HAVE A LOT OF OPINIONS ABOUT DEPLOYMENTS AND I'M
PRETTY VOCAL ABOUT TELLING THEM TO PEOPLE.
ONE OF THE THINGS I BELIEVE IN -- THE SLIDES ARE
OVER THERE.
IT SHOULD BE AS EASY AS PUSHING A BUTTON.
TURN KEY, YOUR CODE GOES LIVE AND YOU WATCH YOUR
MONEY RAIN FROM THE HEAVENS.
[LAUGHTER]
CONVERSELY, REVERTING SHOULD ALSO BE AS EASY AS
PUSHING A BUTTON.
SOMETIMES DEPLOYMENTS GO SOUTH.
IT'S NOT THE END OF THE WORLD.
WE ALL MAKE MISTAKES.
BEING ABLE TO REVERT, MAKES FOR A REALLY NICE
PROCESS.
WHEN YOU PUSH CODE DOWN, AND YOU ARE UNABLE TO
REVERT THOSE CHANGES, YOU'RE JUST ENTERING A WORLD
OF PAIN AND IT'S ABSOLUTELY AWFUL.
SO PRETTY MUCH BAD PUSHES SHOULDN'T BE THE END OF
THE WORLD.
BAD DEPLOYMENT PROCESSES IMPEDE DEVELOPMENT SPEED
AND INNOVATION.
BAD DEPLOYMENT PROCESSES, I BELIEVE --
[NO AUDIO]
PUSH CODE OUT EASILY, SO THE PUSHES BECOME LARGER
AND LARGER.
THE LARGER AND LARGER A PUSH BECOMES, THE MORE RISK
IS ASSOCIATED WITH PUSHING OUT YOUR CODE WHICH
INCREASE --
[NO AUDIO]
SO --
COME UP WITH A GOOD DEVELOPMENT, OR A GOOD
DEPLOYMENT PROCESS.
ON THE OTHER HAND, A GOOD DEVELOPMENT DEPLOYMENTS
ALLOWS FOR EASY DEPLOYS.
MEANS EASIER AND MORE OFTEN WHICH REDUCES THE CODE
YOU'RE DEPLOYING, LOWERS THE RISK, AND PERPETUATES,
BUT IN AN ACTUAL POSITIVE WAY.
ON THE SAME NOTE, EASY ROLLBACKS ALSO TIE INTO THIS
FEEDBACK LOOP AS WELL.
EVERYBODY MAKES MISTAKES.
IF YOU'RE ABLE TO ROLL THOSE MISTAKES BACK EASILY,
THEY'RE NO LONGER SHOW STOPPING.
SO PEOPLE ARE ACTUALLY MORE WILLING TO MAKE THOSE
MISTAKES, KNOWING THAT THEIR CODE PUSH GO SOUTH,
IT'S NOT EXACTLY THE END OF THE WORLD.
WITH TRIAL COMES ERROR AND WITH ERROR COMES GROWTH.
I BELIEVE THAT CODE ISN'T ACTUALLY USEFUL UNTIL
IT'S BEING USED.
YOU CAN HAVE THE GREATEST FUNCTIONALITY SITTING IN
SOURCE CODE KEY AND UNTIL IT'S SITTING IN FRONT OF
SOMEONE BEING USED, YOU'RE NOT GETTING A RETURN ON
YOUR INVESTMENT.
UNUSED CODE CAN BE NOISE BUT PRACTICALLY USELESS.
BUT LET'S CONSIDER A HYPOTHETICAL SITUATION.
LET'S SAY YOU HAVE A NEW FEATURE THAT'S READY FOR
PRODUCTION.
OR, YOU HAVE A BUG FIX THAT WAS NEEDED IN
PRODUCTION, TEN MINUTES AGO.
SOMETHING'S BREAKING AND ALL OF -- THAT'S LEFT TO
DO IS DEPLOY THE CODES YOU HAVE, SO YOU JUST WANT
TO SHIP IT.
I MEAN, WHAT'S THE WORSE THAT COULD HAPPEN?
AND ANYONE KNOWS THE CONTEXT OF THAT SQUIRREL, I'VE
SEEN IT EVERY, BUT I DON'T ACTUALLY KNOW WHAT IT'S
FOR.
YOU GO TO PUSH OUT YOUR CODE, THINKING, THIS IS
GOING TO BE GREAT.
GOING TO FIX A PROBLEM, LOOK LIKE A HERO AND NEXT
THING YOUR KNOW YOUR SHIP CAPSIZES, YOU LOOK LIKE A
FOOL.
YOU COULD POTENTIALLY BE RUNNING DIFFERENT VERSIONS
OF YOUR PRODUCT IN PRODUCTION.
DIFFERENT VERSIONS OF CODE MEANS ONE VERSION OF THE
CODE COULD BE WORKING, THE OTHER COULD NOT.
CUSTOMERS COULD BE HAVING A VERY BAD EXPERIENCE.
YOU DON'T HAVE A GOOD ROLLBACK PLAN, YOU'RE STUCK,
PANICKING UNTIL YOU TRY TO FIGURE SOMETHING OUT,
WHICH COULD BE MINUTES, HOURS, MAYBE IN WORSE CASE,
A DAY OR SO.
OR, IF YOU PUSH OUT CODE, CALLS AN OUTAGE.
MAYBE YOU DON'T HAVE GOOD ENOUGH INTROSPECTION TO
KNOW IF THE DEPLOYMENTS ACTUALLY SUCCEEDED.
AND THAT'S AN ABSOLUTE NIGHTMARE.
SO ASK YOURSELF, DO YOU HAVE MORE THAN ONE WAY TO
DEPLOY CODE ACROSS YOUR NAMES AND -- TEAMS AND
ORGANIZATIONS?
IF SO, THAT'S NOT SO BAD.
THAT GIVES TEAMS AUTONOMY, BUT IF THEY HAVE MORE
THAN ONE WAY TO DEPLOY CODE AMONGST THE TEAM,
THAT'S A RED FLAG.
PERHAPS, THERE'S LEGACY DEPLOYMENT STUFF THERE THAT
THEY NEVER UPDATED OR CONVALESCE INTO CURRENT
DEPLOYMENT, PIPELINE, OR, YOU KNOW, MAYBE SOMEBODY
THOUGHT THEY WERE CLEVER.
WHO KNOWS.
HAVING MULTIPLE DEPLOYMENTS AMONG TEAMS MEANS
HAVING DIFFERENT KNOWLEDGE AND PROCESSES FOR PEOPLE
COMING ON, WHICH MAKES MOVING FROM TEAM TO TEAM
MORE DIFFICULT.
MAKE IT UNIVERSAL, IT CAN BE VERY WELL DOCUMENTED
AND IT'S EASY TO GRAB THAT KNOWLEDGE.
IF YOU HAVE MORE THAN ONE WAY TO DEPLOY --
[NO AUDIO]
I'VE ACTUALLY SEEN THAT HAPPEN ONCE.
WE HAD A PACKAGE FOR THE MAIN SOURCE CODE AND
PYTHON PACKAGES FOR THE CORRESPONDING LIBRARIES,
ALL OVER THE FILE SYSTEM PUSHING OUT A CHANGE FOR
THAT WAS AGONIZING.
SO TO GO INTO A LITTLE MORE ABOUT OUR OLD
DEPLOYMENT SETUP, I TOUCHED ON THIS BEFORE.
WE DID USE DEB END PACKAGING.
IT WORKED FOR A WHILE, UNFORTUNATELY THE PROCESS
ITSELF WAS NEVER MAINTAINED.
SO THE TOOLS BAKE CRAFTY.
A LOT WERE ABANDONED AND BECAUSE OF THAT, PEOPLE
STARTED WANTING OR DESIRING A NEW WAY TO DEPLOY
THEIR CODE.
ONE OF THE WAYS THEY CAME UP WITH WAS MY -- I
ASSUME THAT THE THOUGHT WAS, WE'RE GOING TO MAKE
THIS REALLY EASY.
WHAT WE'RE GOING TO DO IS JUST TAKE A SNAPSHOT OF
OUR SOURCE TREE, TEAR IT UP AND THROW IT YOU OVER
THE FENCE.
WHAT COULD GO WRONG?
THAT WAS A FAILURE AND WE HAD TO KILL THAT AS SOON
AS POSSIBLE.
THAT WAS JUST BAD.
BUT FROM THAT, WE KIND OF DISCOVERED THAT WE CAN
TAKE THOSE TAR BALLS AND UPLOAD THEM.
VERSION THEM.
YOU KNOWN, BE SANE ABOUT IT.
SO WE BEGAN TO DO THAT.
AND THE THOUGHT WAS, IF WE HAVE THOSE PACKAGES
UPLOADED ON OUR INTERNAL REPOSITORY, WE CAN MODIFY
OUR CHEF SOURCE CODE TO INSTALL THEM.
WE CAN USE CHEF FOR OUR DEPLOYMENTS.
THAT WORKED OUT FOR A LITTLE WHILE BUT WHAT WE
FOUND WE RUN CHEF EVERY HALF HOUR OR SO, SO WE'RE
DEPLOYING EVERY HALF HOUR OR SO, SO WHETHER YOU
WANT TO OR NOT, THAT WAS NOT THAT GREAT.
WE HAD LESS CONTROL WHEN OUR CODE WENT OUT AND WHAT
ACTUALLY WENT OUT.
THE FOURTH ONE IS THE ONE I'M GOING TO BE TALKING
ABOUT TODAY.
WE USE PUSH BASED PIP INSTALLATIONS.
TOOK THOSE SAME PYTHON PACKAGES ON OUR
REPOSITORIES, OUR INTERNAL PYPI AND HAVE SOME
FABRIC GLUE AND STUFF, PUSH STUFF OUT TO CERTAIN
TARGETS.
IT WASN'T SO BAD, BUT MISSING A LOT OF MACHINERY
REQUIRED.
THE POINT I'M TRYING TO MAKE HERE IS, WE HAD FOUR
DIFFERENT WAYS TO DEPLOY SOURCE CODE.
THEY WERE ALL SLIGHTLY DIFFERENT, SO IT WAS MORE
LIKE EIGHT OR NINE.
WHAT WE NEEDED TO DO WAS JUST CHOOSE A SINGLE WAY
TO DEPLOY OUR CODE AND ITERATE ON IT.
JUST KEEP ONE WAY -- ONE STANDARD WAY TO DEPLOY
YOUR CODE AND THINGS WILL BE A LOT LESS PAINFUL.
SPEND TIME SUNSETTING OTHER WAYS TO DEPLOY.
[NO AUDIO]
DECIDE TO USE IT EVERYWHERE.
LIKE I SAID, WE WERE RUNNING MACHINERY, ITERATED
AROUND IT, AND MADE FOR A PRETTY NICE PROCESS.
SO -- SOME OF THE PIECES THAT WERE REQUIRED WERE
PYTHON, OBVIOUSLY, AND A SET OF POOLS TO BUILD AND
--
WHEN WE VERSION OUR PACKAGES, WE TRY TO COMPLY WITH
F 440, THE STANDARD PYTHON VERSIONING THEME.
I THINK IT WAS RATIFIED LAST YEAR OR THE YEAR
BEFORE.
I CAN'T RECALL OFF THE TOP OF MY HEAD.
ONE OF MY COWORKERS SET UP THE -- WHICH MANAGES THE
VERSIONS WHICH MANAGES GIT TAGS.
INTERNAL GITHUB AND WE USE THAT FOR SCM MANAGEMENT.
PIP ITSELF IS USED TO INSTALL THE PYTHON PACKAGES,
BELIEVE IT OR NOT.
JENKINS USED FOR CONTINUOUS INTEGRATION AND
BUILDING THOSE PACKAGES.
CHEVY IS USED FOR INITIAL DEPLOYMENT AND SERVICE
DISCOVERY.
SO WE FIND OUT WHICH NODES GET BASED ON WHICH CHEF
SERVICES.
AND FABRIC WAS THE MAGIC SAUCE GLUING ALL THIS
TOGETHER.
SO LET'S GET INTO HOW ALL THIS WORKS.
JUST AS A KIND OF OVERHEAD OF OUR STRUCTURE.
WE DO USE GITHUB INTERNALLY FOR INDIVIDUAL PROJECT
REPOSITORIES.
ON JENKINS, WE HAVE PROJECT-SPECIFIC JOBS.
THAT IS A JOB FOR PRODUCT X WHICH BUILDINGS TESTS,
RUNS FABRIC -- RUNS FLAKY 8, PIP 8, BUILDS STOCKS
AND PUSHES STOCK OUT TO OUR PYPI.
SO THE PROCESS LOOKS LIKE THIS.
DEV COMMIT, THEY MAKE CHANGES TO THE SOURCE TREE
AND THEY WANT TO MAKE A DEPLOY, OR WHATEVER THEY
WANT TO DO.
WHEN THEY MERGED TO MASTER, GITHUB NOTIFIES JENKINS
THROUGH A WEB HOOK KICKS OFF A BUILD OF THE
PROJECT-SPECIFIC JOB.
THE PROJECT-SPECIFIC JOB BUILDS THE PACKAGE,
UPLOADS TO INTERNAL PYPI SERVER.
WE HAVE ONE -- AND I FORGET WHAT IT'S CALLED.
IT WORKS OUT PRETTY NEAT.
WE MIRROR PACKAGES WE NEED THERE, JUST IN CASE, YOU
KNOW, PYPI, THE PYTHON.ORG GOES DOWN OR SOMETHING
HAPPENS, WE HAVE COPIES OF OUR CODE INTERNALLY.
SO AFTER THE PACKAGE IS BUILT AND PUSHED OUT, WE
NOTIFY A GENERIC DEPLOYMENT JOB, TELL IT'S GENERIC
BECAUSE HE'S WEARING SWEET SHADES.
THE PROJECT DEPLOYS -- THE PROJECT USES THE JENKINS
PARAMETERIZED JOB TRIGGER WHICH IS A PLUGIN
PROVIDED BY JENKINS, YOU CAN NOTIFY ANOTHER JOB TO
BUILD BASED ON THE ACTIONS YOUR JOB IS TAKEN.
YOU CAN PROVIDE ANY NUMBER OF PARAMETERS TO SAID
JOB.
THE PARAMETERS THAT WE PROVIDE ARE THE ENVIRONMENT,
THE CHEF ROLL, THE NAME OF THE PACKAGE, AND AN
OPTIONAL VERSION FOR PINNING.
I'LL GO BACK AND MENTION THAT LATER WHEN I TALK
ABOUT ROLLBACKINGS.
THE GENERIC DEPLOYMENT JOB, QUERY A CHEF SERVER.
THIS IS WHERE FABRIC ENTERS THE SCENES.
THE NEXT SLIDES ARE ALL WITHIN THE CONTEXT OF
FABRIC.
GIVEN THE CHEF ROLL, WE QUERY CHEF USING THE ROLL
NAME AND THE ENVIRONMENT.
FOR EACH NOTE RETURN IN THE CHEF SEARCH, WE DO THE
FOLLOWING:
[NO AUDIO]
AND THE PACKAGE NAME, EVERYBODY'S HAPPY, NICE AND
EASY.
AFTER THE PACKAGE IS INSTALLED, WE RESTART THE API
THROUGH -- TO LOAD THE NEW CODE.
AFTER THE API HAS BEEN STARTED OR WORKERS BEEN
BOUNCED, WE TEST OUT THE NEW CODE LIKE FOR THE API
WE, MAKE SURE RETURN IS 200 AND OKAY.
AND IT SHOULD BE OPERATIONAL FOR THE DURATION OF,
YOU KNOW, UNTIL IT WILL BE DEPLOYED NEXT.
AFTER THE CODE'S BEEN BOUNCED AND TEST SUCCEED,
CONTROL FLOW ACTUALLY RUNS BACK TO THE
PROJECT-SPECIFIC JOB.
THIS IS DONE FOR A VERY SPECIFIC REASON.
TAKE, FOR EXAMPLE, THE TEST OF THE NEW API FAILS IN
THE LAST JOB.
IF WE DIDN'T RETURN CONTROL FLOW BACK TO THE
ORIGINAL DEPLOYMENT JOB WE COULD NOT FAIL THAT JOB,
WHICH WOULDN'T RAISE ENOUGH ALERTS.
THIS CHANNEL IS IN A PYTHON.
IT DOESN'T PASS UNLESS SPECIFICALLY SILENCED.
WE WANT TO KNOW WHEN OUR DEPLOYMENTS FAIL, SO WE
CAN FIGURE OUT WHAT WENT WRONG.
AFTER CONTROL FLOW RETURNS BACK TO THE
PROJECT-SPECIFIC JOB, WE JUST DO A BUNCH OF PUSH
NOTIFICATIONS, SO PEOPLE ACTUALLY KNOW WHAT
HAPPENED.
DEPLOYMENT LIVE.
MAYBE e-MAIL PEOPLE OF THE BUILD BROKE, YOU KNOW,
THE BLAME e-MAIL, EVERYONE LOVES THAT ONE.
AFTER THAT, PRETTY MUCH RINSE AND REPEAT AND THAT'S
ALL THERE IS TO THAT.
THAT PROCESS IS FAIRLY SIMPLE.
THE KEY TAKEAWAYS FROM THIS DEPLOYMENT PROCESS ARE,
ONE, YOU CAN CHOOSE ONE DEPLOYMENT --
[NO AUDIO]
USING THIS MECHANISM CAN BE DEPLOYED IN PARALLEL.
THAT IS, YOU CAN USE FABRIC'S PARALLEL TO PUSH IT
ALL OUT AT ONCE.
WHICH ISN'T NECESSARILY A BAD THING.
HOWEVER IF YOU'RE BOUNCING THE SURFACES THEY SHOULD
BE CONSEQUENCLY.
AND YOU JUST SUPPLIED AND OUTAGE AND NOBODY WANTS
THAT.
IT MAKES FOR EASY ROLLBACKS.
I MENTIONED A BIT EARLIER, IN JENKINS, WE SET IT UP
SO IT ACCEPTS A VERSION.
YOU CAN BUILD THE GENERIC DEPLOYMENT JOB, PROVIDE
ALL THE INFORMATION YOU WANT, AND IF YOU SPECIFY A
VERSION, THAT VERSION WILL BE INSTALLED TO THE
CORRESPONDING ENVIRONMENT THAT YOU PROVIDE.
SO IF SOMETHING GOES WRONG, THE LATEST BUILD FAILS,
YOU JUST CLICK ON THE JENKINS JOB, PROVIDE YOUR
VERSIONS, PUSH THE BUTTON, AND PRODUCTION IS SAVED.
IT'S PRETTY NEAT.
AND ONE OF THE COOLEST THINGS ABOUT THIS IS, OTHER
CODE BASES CAN ACTUALLY USE THIS SIMILAR DEPLOYMENT
SETUP.
THE ONLY THINGS TIEING THIS TO PYTHON IS PIP AND
OUR PYPI SERVER.
WE NOTICED THIS AFTER UPROLLING UPDATES TO NODEJS.
WE USE INTERNAL MPM SERVER FOR MANAGING THE SOURCE
CODE.
THIS ACTUALLY WORKED OUT VERY NICELY.
HOWEVER, WITH ALL GOOD THINGS, IT'S NOT ALL
SKITTLES AND BEER.
THERE ARE SOME PROBLEMS HERE.
FIRST AND FOREMOST, FIXING AND UPDATING OLD
DEPLOYMENT PROCESSES IS VERY PAINFUL.
IT'S ALWAYS LIKE THAT.
PEOPLE LIKE TO TACK ON LEGACY STUFF TO THAT WHEN
THEY DON'T WANT TO TOUCH IT.
THERE'S NOTHING YOU CAN DO BUT SLUG THROUGH IT.
THIS CANNOT BE A ONE-PERSON THING TO GO BACK AND
UPDATE.
IT REQUIRES TEAM WORK, COORDINATION AND EVERYBODY
NEEDS TO BUY INTO THIS PROCESS.
IF YOU DON'T HAVE THAT BUY IN, YOU'LL NEVER
ACTUALLY GET THIS THING OUT AND ABOUT.
ONE OF THE THINGS THAT WE DISLIKE ABOUT THIS
PROCESS IS STRONGLY COUPLED WITH CHEF FOR SERVICES
DISCOVERY.
WE USE CHEF FOR INITIAL -- FOR OUR NODE
PROVISIONING AND IT DOES DO THE INITIAL DEPLOYMENT
OF OUR PACKAGES THAT IS, WHEN YOU BRING UP A NEW
VM, IT WILL DO A PIP INSTALL OF YOUR PACKAGE, AND
IT'S OUT OF THE EQUATION.
HOWEVER, WE ALSO USE FOR SERVICES DISCOVERY, WHICH
IT CAN WORK PRETTY WELL IN SOME CASES, BUT WE'VE
BEEN LESS THAN IMPRESSED WITH SOME OF THE
EDUCATIONS.
MOSTLY SOLAR.
JENKINS ITSELF IS NOT THE GREATEST CONTINUOUS
DEPLOYMENT SERVER.
IT'S GREAT FOR CONTINUOUS INTEGRATION.
RUNS TEST VERY WELL, TRIGGER OTHER JOBS, ALL VERY
NICE.
ACTUALLY HAVING IT MANAGE OUR DEPLOYMENTS HAS
GOTTEN KIND OF PAINFUL.
AND THE TRIGGER PARAMETERIZED BUILD PLUGIN THAT I
MENTIONED IS NOT WITHOUT IT'S FLAWS.
YOU CANNOT PASS ENVIRONMENT VARIABLES PROCEDURAL
AND INTRODUCES NEW HASH CONTEXT.
IT'S GOT A LOT OF WEIRD EDU CASES THAT YOU KIND OF
HAVE TO WORKAROUND.
AT THAT POINT, YOUR CONTINUOUS DEPLOYMENT SERVER IS
KIND OF FIGHTING AGAINST YOU AND IF THAT HAPPENS,
YOU'RE KIND OF FIGHTING A LOSING BATTLE.
AND WITH MOST NEW PROJECTS, OUR INITIAL VERSION OF
THE DEPLOYMENT WAS PRETTY GNARLY.
WE USED FABRIC IN A PRETTY WEIRD WAY.
WHAT WE DID IS, WE HAVE A SEPARATE REPOSITORY WITH
OUR FABRIC FILE AND A VERSION OF THAT SEPARATELY,
MAINTAINS ITS REQUIREMENTS AND ALL THE THINGS THAT
THAT LEAVES -- ALL THE THINGS THAT FABRIC FILE
NEEDS TO OPERATE.
HOWEVER, FABRIC ITSELF DOESN'T REALLY LIKE THE IDEA
OF HAVING -- HOW DO I SAY THIS?
WE PACKAGED UP THE FABRIC FILE INTO ITS OWN LITTLE
S DISK, UPLOAD INTO INTERM PYPI, HOWEVER THE
VERSION WE WERE USING, DIDN'T REALLY LIKE U PIP
INSTALLING FABRIC FILES.
WE GET AROUND USING A SEPARATE GITHUB REPOSITORY.
SO THOSE ARE SOME SHORTCOMINGS.
IT'S NOT ALL DOOM AND GLOOM.
WE DO WANT TO MOVE ON FROM HERE.
SOME OF THE NEXT STEPS WE WANT TO TAKE ARE, WE WANT
TO HOP ABOARD THE DOCKER HYPE TRAIN.
EVERYBODY SEEMS TO BE DOING IT.
IS IT SEEMS LIKE IT'S REALLY NEAT AND SOLVE ALL THE
PROBLEMS WE HAVE AND DIDN'T REALLY KNOW WE HAD.
WE -- LOOK AT ROLLS LIKE RUNDECK INSTEAD OF JENKINS
AS A CONTINUOUS DELIVERY SERVER.
IF ANYBODY USING THIS, I'D LIKE TO TALK TO YOU.
WE'VE BEEN KNOCKING IT AROUND, BUT HAVEN'T REALLY
SETTLED ON IT.
BUT FROM WHAT I'VE READ, IT'S A SERVICE THAT SITS
OUT HERE AND RUNS ARBITRARY BASH.
KIND OF LIKE JENKINS, BUT NOT REPOSITORY CENTRIC.
SOME OF THE THINGS TO INTRODUCE TRADITIONALLY ARE
TREND-BASED MONITORING.
LIKE SKYLINE, WHICH, I BELIEVE, IS USED BY, I CAN'T
REMEMBER THE NAME OF THE COMPANY OFF THE TOP OF MY
HEAD.
OR, YOU KNOW...
[NO AUDIO]
BUT THEY DON'T EXPOSE TRENDS EASILY.
THAT IS, IF YOU PUSH OUT A CHANGE, YOU KNOW, YOU
PUSH OUT A DEPLOYMENT, AND SOMETHING BEGINS TO
DEVIATE, IT'S KIND OF DIFFICULT TO PINPOINT THAT
WITH A VERY NARROW SCOPE OF YOUR METRICS.
SOMETHING LIKE TREND-BASED MONITORING, YOU CAN HAVE
HISTORICAL DATA TO COMPARE AGAINST AND RAISE ALERTS
WHEN THINGS SEEM ANOMALOUS, WHICH IS VERY USEFUL.
INSTEAD OF USING CHEF AS A SERVICE DISCOVERY
MECHANISM, WE WANT TO USE SOMETHING, WELL, WE WERE
LOOKING AT SOMETHING LIKE, CONSOLE, SED, OR THE
VARIABLE, ZOOT KEEPER, WHICH ARE MORE WELL SUITED
TO THE TASK AT HAND.
ADDITIONALLY, THE DEPLOYMENT PROCESS THAT I KIND OF
DESCRIBED HERE IS VERY SIMPLISTIC.
IT'S -- THERE'S NOT A LOT OF MOVING PARTS WHICH IS
KIND OF ONE OF ITS BENEFITS, BUT DOESN'T REALLY
FACILITATE COMPLEX DEPLOYMENTS THAT OTHERS MAY
NEED.
WE KIND OF WANT TO LOOK AT MORE SOPHISTICATED
DEPLOYMENTS INCLUDING PARTIAL ROLLOUTS.
FOR EXAMPLE, IF YOU'RE ON -- IF YOU USE AMAZON,
MAYBE DEPLOY ONE AVAILABILITY ZONE, SEE HOW THAT
GOES BEFORE SPRINGING THE CODE EVERYWHERE.
ADDITIONALLY WE WANT TO LOOK AT DESIGNATING ONE SET
OF NODES OR VMS, AS CANARIES.
PUSH THE CODE OUT THERE, MAKE SURE IT DOESN'T
BREAK.
IF THE CANARIES DIE, THE REST OF THE CODE IS STILL
FUNCTIONAL.
THAT MEANS, ONLY A VERY SMALL SUBSET OF YOUR
COMMERCE IS IMPACTED BY THIS OUTAGE AND NOT
EVERYBODY UNDER THE SUN.
WHICH IS A BAD, BAD TIME.
SO KIND OF TO WRAP THIS UP, GOOD DEPLOYMENTS CAN
HELP INNOVATION.
BAD DEPLOYMENTS CAN HURT IT.
THAT'S THAT POSITIVE AND NEGATIVE FEEDBACKS LOOP I
DISCUSSED EARLIER.
DEPLOYMENT OF PYTHONS ARE NEVER DONE AND NEVER
TRULY FINISHED.
THEY SIMPLY EXIST AS STATES IN TIME.
THEY REQUIRE CONSTANT MAINTENANCE ON LOVE.
FOR THE MORE THEY REQUIRE MORE THAN ONE PERSON
MAINTAINING THEM.
THE MORE PEOPLE YOU HAVE INVOLVED WITH THIS, THE
BETTER.
YOU HAVE A WIDER SPECTRUM, AND A VIEW OF THE
PROBLEM AT HAND AND HOW TO SOLVE IT WHEN NOT --
REDUCE THE SIZE AND SCOPE OF YOUR DEPLOYS, AND
ITERATE ON WHAT WORKS.
[APPLAUSE]
>> ALL RIGHT.
SO THANKS, DON.
WE'RE GOING TO HAVE ONE-ON-ONE QUESTIONS, SO IF YOU
HAVE ANY QUESTIONS, COME HERE, AND WE'RE GOING TO
BE MOVING YOU TO AN OPEN SPACE AFTER.
SO ONCE AGAIN, THANK YOU, DAN.
>> THANK YOU VERY MUCH.
[APPLAUSE]
[MUSIC PLAYING]
01:59:57PM02:00:37PM02:00:37PM02:02:23PM02:09:06PM02:09:06PM02:12:56PM