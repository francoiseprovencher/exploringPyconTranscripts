GOING TO BE TALKING TO US ABOUT CARMEN SAN DIEGO,
I THINK.
>> WELCOME, GUMSHOES, TO ANOTHER EPISODE OF WHERE
IN iRAN IS SAN DIEGO, PYTHON SAN DIEGO.PY?
SPONSORED BY MY EMPLOYER, RACKSPACE.
I'M YOUR HOST AND ACME CRIME NET LIAISON.
THE CHEF APPRECIATES YOUR HELP AND DISCRETION IN
THIS MATTER BUT I'LL LET HER EXPLAIN THE
SITUATION HERSELF.
GUMSHOES, WE'VE RECEIVED A CREDIBLE THREAT TO THE
ACME CRIME NET CASE FILE SERVER.
I GOT THIS TEXT FROM MY MOTHER EARLIER TODAY.
MY MOTHER THINKS IF SHE THREATENS MY WORK, I'LL
TO HAVE CALL HER AND ASK HER TO STOP.
SHE'S PROBABLY RIGHT BUT I CAN'T LET THE
ULTIMATUM STAND.
THE NEXT TIME SHE MIGHT DEMAND THAT I MAKE
THANKSGIVING DINNER.
MY MOM IS A PYTHON PROGRAMMER BUT I DIDN'T SEE
ANY PROCESSES LOADING.
FIND THE ROGUE PROCESS, GUMSHOES.
I NEED TO START THE SERVER UP AGAIN AT SOME POINT
AND I CAN'T HAVE HER DELETING MY FILES.
CHIEF OUT.
>> THANKS, CHIEF.
[ Laughter ]
AND, I GUESS...
THERE'S THE MEMORY DUMP.
OKAY, SO NOW WE HAVE A TWO GIGABYTE BINARY FILE,
A DUMP OF WHAT'S WAS ON THE RAM IN THE SERVER.
IT SURE WOULD BE NICE IF THIS WAS SPLIT INTO
PROCESS REGIONS.
THEN WE CAN FIND THE PART THAT BELONGS TO THE
ROGUE PYTHON PROCESS AND DO SOMETHING WITH IT.
MAYBE WE CAN SPLIT IT OURSELVES, ALL PROCESSES
ARE MANAGED BY A BOSS, RIGHT, THE KERNEL, WHICH
MUST KNOW THEIR WHEREABOUTS AND WHAT THEY'VE BEEN
UP TO.
WE NEED TO FIND THE KERNEL AND INTERROGATE IT,
BUT HOW?
LUCKILY, THERE IS AN OUTSIDE CONTRACTOR WICK
EMPLOY TO HUNT THROUGH MEMORY DUMPS FOR US.
IT'S OPEN SOURCE, WRITTEN ENTIRELY IN PYTHON AND
IF WE GIVE IT AN ACCURATE DESCRIPTION OF WHAT THE
KERNEL LOOKS LIKE AND THE ADDRESS OF ITS KNOWN
ASSOCIATES VOLATILITY CAN FIND THE KERNEL AND ANY
PROCESSES THE KERNEL CAN MANAGE.
THE FIRST THING WE NEED TO DO IS BUILD A PROFILE
OF THE KERNEL.
KERNEL HEADERS DESCRIBE THE KERNEL.
THEY DEFINE THE DATA STRUCTURES IT USES, WHAT
ATTRIBUTES THEY HAVE AND HOW BIG THEY ARE.
THIS WILL TELL VOLATILITY WHAT THE CERTAINLY
ENGINEER -- KERNEL WILL LOOK LIKE IN -- THEY'RE
PROVIDED BY THE LINUX HEADER PACKAGES FOR OUR
PARTICULAR KERNEL VERSION.
FOR OS 10, THEY CAN BE DOWNLOADED FROM AN HE WILL
AND VOLATILITY HAS A LOT OF EXPERIENCE HUNTING
DOWN THE KERNELS.
SO WHAT ABOUT THE LOCATIONS OF THE KERNEL'S KNOWN
SOMEBODY AT?
WE'RE LOOKING FOR AN ADDRESS BOOK OF SORTS,
CALLED THE SYMBOL TABLE.
THAT HAS INFORMATION ABOUT IDENTIFIERS IN THE
KERNEL CODE.
INFORMATION LIKE AN IDENTIFIER IS AN ADDRESS
WHICH IS JUST A NUMBER REPRESENTING AN OFFSET
INTO MEMORY, WHERE THE IDENTIFIER CAN BE FOUND.
IN LINUX, THE KERNEL SYMBOL TABLE CAN BE FOUND AT
BOOT/SYSTEM.MAP.
IT CAN BE USED TO EXTRACT THE MAPPING, LIKE
HUMANELY, AND, AGAIN, VOLATILITY PROBABLY ALREADY
KNOWS ALL THE WINDOWS ADDRESS BOOKS.
OKAY.
SO NOW THAT WE'VE BUILT OUR PROFILE, WE CAN
INVOKE VOLATILITY.
WE DEAD-DROP OUR PROFILE INTO A PLUG I IN
DIRECTORY, TELL THE -- TELL VOLUME TAKE IT BOTH
THE LOCATION OF THE DEAD-DROP AND THE NAME OF THE
PROFILE AND THEN WE POINT IT AT THE MEMORY DUMP
AND TELL IT WHAT WE WANT TO SEARCH FOR.
LET'S START BY TELLING VOLATILITY TO FIND THE
KERNEL AND BRING IT IN FOR A FRIENDLY CHAT.
VOLATILITY FACILITATES THE INTERROGATION WITH AN
INTERACTIVE SHELL COMMAND VOLUME VOL SHELL.
THIS IS AN I-PYTHON SESSION WITH EXTRA CONTEXT.
AS YOU CAN SEE, VOLATILITY THINKS IT'S FOUND THE
KERNEL'S INIT TASK, THE PARENTS OF ALL OTHER
PROCESSES NWINDOWS, THIS WOULD BE THE SYSTEM
PROCESS, IN OS 10, THIS WOULD BE THE KERNEL TASK.
THE LINUX KERNEL KEEPS TRACK OF ALL THE PROCESSES
IT'S CURRENTLY MANAGING IN A LINKED LIST.
THE FIRST LIMITS OF WHICH IS THE INIT TASK.
SO THEY'VE FOUND THAT TASK, PROBABLY FOUND THE
KERNEL AND WE CAN GET TO AMOUNT OTHER PROCESSES.
SO LET'S USE THE I-PYTHON INTERFACE TO ASK SOME
BASIC QUESTIONS TO ESTABLISH THE SUSPECT'S
IDENTITY.
THE VOLATILITY SHELL OBJECT IS PRESENTED AS SELF
AND THE TASK CURRENTLY UNDER INTERROGATION
SUPPOSEDLY INIT IS AN ATTRIBUTE ON VOLATILITY
SHELL NAMED PROC.
WE CAN START OFF WITH SOMETHING EASY.
LET'S SAY, HEY, WHAT ARE YOU?
TEST STRUCT, IT ANSWERS, AND THAT WOULD BE GREAT
IF WE KNEW WHEN A TASK STRUCT WAS.
TO ANSWER THAT, WE SHOULD UNDERSTAND WHAT THE
KERNEL DOES WHEN A PROCESS STARTS UP.
WE KNOW THAT INIT IS SOME KIND OF LINUX PROCESS
AND WE KNOW THE KERNEL NEEDS SOME WAY TO KEEP
TRACK OF ALL PROCESSES, SO IT OBVIOUSLY NEEDS TO
STORE INFORMATION NEEDED TO MANAGE THE PROCESS,
AND THE IT ALLOCATES MEMORY FOR THE PROCESS WHEN
IT STARTS UP, WHICH MEANS IT NEEDS TO STORE WHAT
MEMORY BELONGS TO WHAT PROCESS.
THE PROCESS INFORMATION IS STORED IN A C DATA
STRUCTURE OR STRUCT.
YOU CAN THINK OF STRUCTS LIKE PYTHON NAMED UP HE
WILLS, THEY GROUP DATA TOGETHER.
IN LINUX, THIS STRUCT IS CALLED A TASK STRUCT.
THE CORRESPONDING INSTRUCTOR IN WINDOWS WOULD BE
E PROCESS AND IN OS 10 IT'S PROC, BUT THEY PRETTY
MUCH ALL CONTAIN THE SAME INFORMATION.
LIKE BASIC INFORMATION ABOUT THE PROCESS ITSELF,
LIKE THE I.Z., THE SHORT NAME AND THE START TIME.
THE EXAMPLE DISPLAYED HERE IS A LINUX TASK
STRUCT.
THEY ALSO USUALLY HAVE SOME WAY TO ACCESS THE
PARENT PROCESSES, SIBLING PROCESSES AND CHILD
PROCESSES, AND INFORMATION ABOUT THE OWNER OF THE
PROCESS.
SOME WAY TO LOOK UP THE PROCESSES OPEN FILES AND
SOCKETS, AND FINALLY, SOME WAY TO STORE
INFORMATION NEEDED TO MANAGE THE MEMORY OF THE
PROCESS.
IN LINUX, IT'S STORED IN ANOTHER STRUCTURE CALLED
THE MM STRUCT.
SO NOW WE KNOW WHAT THAT IS, LET'S RETURN TO THE
INTERROGATION AND ASK MORE SPECIFIC QUESTIONS,
LIKE WHAT'S YOUR PROCESS I.D.?
ONE.
THAT'S PRETTY COOL.
THE INIT TASK ALWAYS HAS AN I.D. OF ONE IN LINUX.
WHAT'S YOUR SHORT NAME?
INIT.
AWESOME, IDENTITIES VERIFIED, WE'VE CONFIRMED
THIS IS THE SUSPECT.
LET'S HAVE VOLATILITY A MUCH MORE EFFECTIVE
INTERROGATOR THAN US ASK WHAT PROCESSES IT
MANAGES.
THE ANSWER LOOKS LIKE THE RESULT OF THE LINUS PS
COMMANDS.
THERE IS A LIST OF THE PROCESS I.D.s AND SHORT
NAMES, NOTHING LOOKS SUPER SUSPICIOUS, THOUGH, SO
LET'S HAVE VOLATILITY ASK A DIFFERENT WAY.
THIS TIME THE ANSWER LOOKS A LOT LIKE THE RESULT
OF THE LINUX PS AUX COMMAND.
THIS GIVES US A COMPLETE COMMAND LINE ARGUMENTS
FOR EACH PROCESS, AS OPPOSED TO JUST A SHORT
NAME.
STILL NOTHING SUSPICIOUS, THOUGH.
WE SHOULD REALLY ASK MORE EXPLICITLY.
KERNEL, DO YOU KNOW ABOUT ANY PYTHON PROCESSES?
AND IT LOOKS LIKE NO.
SO THAT'S PRETTY UNFORTUNATE.
THE KERNEL WAS PERFECTLY COOPERATIVE AND
FORTHCOMING WITH US, THOUGH, WHICH MEANS THAT THE
ROGUE PROCESS WE ARE LOOKING FOR MUST HAVE GIVEN
THE KERNEL A FAKE NAME AND IT'S LYING TO THE
KERNEL.
LOOKS LIKE THIS WILL TAKE SOME MORE LEG WORK.
SO LET'S HAVE A CLOSER LOOK AT THE RESOURCE THE
KERNEL GIVES THE PROCESSES AND TRACK IT DOWN THAT
WAY.
MAYBE WE SHOULD LOOK AT THE OPEN FILES AND
SOCKETS?
SINCE THE KERNEL PROVIDES AND KEEPS TRACK OF THIS
ACCESS, IT'S AVAILABLE TO US IN THE MEMORY DUMP,
TOO.
SO THE KERNEL HAS GIVEN US A LIST OF EVERY OPEN
FILE ACCESSED BY EVERY PROCESS.
LOOKING AT THIS, WHAT WOULD WE CONSIDER
SUSPICIOUS?
ONE OBVIOUS THING WOULD BE TO SEE IF THERE WERE
ANY PROCESSES TRYING TO DELETE THE CASE FILES.
WHICH THERE DOESN'T SEEM TO BE.
BUT WE'D ONLY SEE THAT IF A PROCESS HAPPENED TO
BE DOING THAT AT THE TIME OF THE MEMORY DUMP.
PRIOR ACCESS THAT HAD FINISHED BY THE TIME THE
MEMORY WAS ACQUIRED WOULD NOT EVEN SHOW UP.
SIMILARLY WITH OPEN SOCKETS, WE CAN LOOK AT WHAT
PROCESSES ARE LISTENING TO WHAT SOCKETS BUT ALSO
THE CHIEF HAPPENS TO KNOW HER MOM'S I.P., NOTHING
WOULD JUMP OUT AT US.
AND UNLESS THE PROCESS WAS CONTACTING THE SERVER
AT THE EXACT MOMENT OF THE MEMORY DUMP, WE
WOULDN'T SEE IT, ANYWAY.
OKAY.
SO OPEN FILES AND SOCKETS ARE A DEAD END.
WE SHOULD HAVE A CLOSER LOOK AT THE MEMORY
RESOURCES THE KERNEL PROVIDES EACH PROCESS IT
MANAGES, SO LET'S CHECK OUT THE MM STRUCT.
WHICH SORT OF LOOKS LIKE THIS.
ON THE LEFT IS WHAT PROCESS MEMORY GENERALLY
LOOKS LIKE.
THE TOP IS THE END OF THE PROCESS MEMORY WHERE
THE HIGHEST ADDRESS IS AND THE BOTTOM IS THE
BEGINNING OF PROCESS MEMORY WHERE ZERO IS.
ON THE RIGHT IS PART OF THE ACTUAL STRUCT
DECLARINGATION.
THE MM INSTRUCT AN OH SAYS SEVERAL INTERESTING
REGIONS OF A PROCESS MEMORY.
THINK OF IT LIKE SAKES INS A LIBRARY, LIKE
MYSTERIES OR SCIENCE FICTION.
THERE'S THE ENVIRONMENT VARIABLE SECTION NEAR THE
TOP WHICH HAS THE ENVIRONMENT VARIABLES THE
PROCESS WAS STARTED WITH, THEN BELOW THAT, THERE
IS THE COMMAND LINE ARGUMENTS THE PROCESS WAS
STARTED WITH.
THEN THERE'S THE STACK WHICH IS LIKE A SCRATCH
PAD FOR PROCESSES, IT'S WHERE IT WRITES
INCRIMINATING EVIDENCE.
THIS IS WHERE PROGRAMS STORE CALL INFORMATION,
ARGUMENTS AND RETURN VALUES.
IT STARTS AT HIGHER ADDRESSES AND AS MORE THINGS
ARE ADDED TO THE STACK, GROWS DOWNWARD.
NEXT IS THE MEMORY MAP SECTION.
THIS IS WHERE NECESSARY FILES LIKE LIBRARIES MAKE
MMAP TO MEMORY.
FOR PYTHON PROGRAM, C-EXTENSIONS WOULD BE MAPPED
HERE.
ADDITIONAL FILE MAPPINGS GET ADDED TO THE SECTION
AT THE BOTTOM SO IT GOES DOWNWARDS LIKE THE STACK
AND LOOKING AT IT COULD ALSO GIVE INCRIMINATING
EVIDENCE, LIKE A BAD READING LIST.
THEN COMES THE HEAP, WHICH FOR HISTORICAL REASONS
IS REFERRED TO AS BRICK.
THIS IS WHERE DYNAMICALLY ALLOCATED OBJECTS GO.
IN PYTHON, THAT'S LIKE EVERY OBJECT, VERY MUCH
EVER, ALL OF IT -- ALL OF IT GOES ON THE HEAP SO
THAT'S REALLY WHERE WE WANT TO LOOK IF WE HAVE
FIND A ROGUE PROCESS.
IN THE NEXT SECTION, WE FIND THE DATA SEGMENT
WHICH IS THE NON-INSTRUCTION PARTS OF THE PROCESS
BINARY.
IT'S THE GLOBAL AND STATIC VARIABLES OF THE
BINARY, FOR THE PYTHON BINARY, THIS WILL MAKE
LIKE C-PYTHON BUILT-IN DOC STRINGS.
THE NEXT REGION IS THE EXECUTABLE MACHINE
INSTRUCTION PART OF THE PROCESS BINARY.
THIS IS THE PART OF THE PYTHON BINARY THAT
ACTUALLY RUNS PYTHON.
SO IF THOSE WERE LIKE LIBRARY SECTIONS, WHAT'S
THE UNIT OF THING THAT'S BEING CATEGORIZED?
WHAT'S THE MEMORY ANALOG TO A BOOK?
THAT WOULD BE A VIRTUAL MEMORY AREA, WHICH IS A
CONTIGUOUS AREA OF PROCESS MEMORY THAT HAS THE
SAME PERMISSIONS AND ALLOWED OPERATIONS AND THAT
IS MAPPED TO THE SAME FILE.
THERE MIGHT BE MULTIPLE VIRTUAL MEMORY MEMORIES
IN A SAME SECTION.
ALSO NOTE THAT A SINGLE VIRTUAL MEMORY AREA
COVERS THE ENVIRONMENT VARIABLE, THE COMMAND LINE
ARGUMENTS AND THE STACK.
IF YOU THINK ABOUT IT, ENVIRONMENT VARIABLES AND
THE COMMANDS LINE ARGUMENTS ARE LIKE THE FIRST
FUNCTION CALL TO THE PROCESS SO THAT SORT OF
MAKES SENSE.
SO IF THE KERNEL HAS TO KEEP LISTS OF WHICH
VIRTUAL AREAS BELONG TO WHICH PROCESS, THAT'S HOW
A LIBRARY KEEPS A RECORDS OF THE BOOKS THE
PATRONS CHECK OUT, RIGHT?
AND VOLATILITY CAN GET US ACCESS TO THIS BOOK
LIST WITHOUT NEEDING A COURT ORDER, USING THE
COMMAND PROR MAPS.
THIS IS PERFECTLY LEGAL AND ABOVEBOARD.
ON A LIVE LINUX SYSTEM, YOU CAN SEE THE SAME LIST
USING THE PROC FILE IN PROC/PITT/MAPS.
THIS SYSTEM PROVIDES USER SPACE A WAY TO GET
INFORMATION ABOUT PROCESSES WITHOUT HAVING TO
MAYBE SYSTEM CALLS TO THE KERNEL.
EACH HAS A START AND END ADDRESS, A PERMISSIONS
FLAG WHICH SPECIFIES WHICH OPERATIONS ARE ALLOWED
FOR THE VIRTUAL MEMORY AREA.
SEE HOW EACH OF THESE THREE AREAS HAVE DIFFERENT
SET OF PERMISSIONS, EVEN THOUGH THEY'RE MAPPED
THE EXACT SAME FILE?
SPEAKING OF, THE VIRTUAL MEMORY AREA HAS A NAME
WHICH MIGHT BE THE NAME OF THE FILE THAT'S MAPPED
OR MIGHT BE SOMETHING LIKE KEEP OR STACK.
THE FIRST NUMBER OF VIRTUAL MEMORY AREA IN THIS
LIST IS THE SEGMENTS PART OF THE FILE BECAUSE
IT'S EXECUTABLE AND NOT WRITABLE.
THE SECONDS AND THIRD MEMORY AREAS FORM THE
SEGMENTS, ONE BEING READ-ONLY AND THE OTHER BEING
READS-WRITE.
SO, GREAT, WE HAVE SOME VIRTUAL MEMORY AREAS
MANAGED BY THE KERNEL BUT HOW DOES THIS HELP US
FIND OUR ROGUE PROCESS?
WELL, WE JUST HAVE TO USE THE INFORMATION THE
KERNEL KEEPS ABOUT WHAT'S HAPPENED IN MEMORY TO
CATCH ONE OF THESE PROCESSES IN A LIE.
6 ENGINEERED, ALL THE PROCESSES MANAGED BY THE
KERNEL DENY THEY'RE PYTHON PROCESSES BUT DO ANY
OF THEM ACTUALLY HAVE THE THE PROCESS MAPPED AS A
PYTHON CODE?
IF SO, THAT SEEMS LIKE A CLEAR INTENT TO DECEIVE
AND WARRANTS SUSPICION.
SO, LET'S GO TALK TO THE KERNEL AGAIN AND WE'RE
GOING TO GO THROUGH ITS PAPERWORK FOR PROCESSES
WITH A FINE-TOOTHED COMB.
EACH AND EVERY PROCESS THAT THE KERNEL MANAGES,
WHICH IS STORED IN A LINKED LIST THAT WE CAN
CONVENIENTLY ACCESS USING THE ATTRIBUTE TASKS.
FOR EACH PROCESS, WE WANT TO IDENTIFY THE VIRTUAL
MEMORY AREA THAT CORRESPONDENCES WITH THE
EXECUTABLE PART OF THE PROCESS BINARY.
WE WANT TO FIND THE CODE SEGMENT.
SO WE GO THROUGH ALL OF THE VIRTUAL MEMORY AREAS
FOR THAT PROCESS, WHICH WE CAN OBTAIN USING THE
FUNCTION GET PROC MAPS.
AND WE FIND ONE WHOSE START AND END ADDRESSES
MATCH THE SEGMENT CODE START AND END ADDRESSES,
THAT'S THE CODE SEGMENT.
SOME PROCESSES, MAINLY THE KERNEL THREADS, SHARE
THE KERNEL'S ADDRESS SPACE SO DON'T HAVE CODE
SEGMENTS THEMSELVES.
WE WANT TO IGNORE THOSE.
FOR NON-KERNEL THREADS, THERE ARE NOT AND ONLY BE
VIRTUAL MEMORY AREA FOR THE CODE SEGMENTS, WHEN
WE FIND IT, WE WANT TO PRINT IT OUT -- PRINT OUT
THE VIRTUAL MEMORY AREA NAME ALONG WITH A PROCESS
I.D. AROUND THE SHORT NAME.
AND THEN WE CAN COMPARE WHAT EACH PROCESS CLAIMS
ITS NAME IS WITH WHAT EACH EXECUTABLE PROCESS THE
PROCESS HAS MAPPED.
AND THAT'S WEIRD, THERE ARE TWO PROCESSES
CLAIMING TO BE WHOOPSIE, THE UBUNTU ERROR
REPORTER.
ONE IS USER BIN WHOOPSIE, WHICH IS PRETTY
STANDARD AND THE OTHER IS USING USER BIN PYTHON,
AND WE ARE LOOKING FOR A PYTHON PROCESS.
I THINK WE HAVE A VIABLE SUSPECT, GUMSHOES.
NOW WE NEED TO BUILD OUR CASE.
WE KNOW THE PROCESS HAS BEEN LYING TO THE KERNEL
BUT THAT'S NOT A CRIME.
AFTER ALL, OTHER LEGITIMATE PROCESSES ALSO LIE
ABOUT THE NAME, THEY OVERWRITE THEIR OWN SHORT
TASK NAME AND COMMAND LINE ARGUMENTS.
FOR INSTANCE, POSTGRASS DOES THIS TO RUN THE
QUERY IN SHHD DOES THIS TO SHOW WHO'S LOGGED ON,
SO WE NEED TO LEARN MORE.
WHAT ELSE HAS THIS PROCESS BEEN DOING?
WE CAN OF COURSE ASK VOLATILITY TO INTERROGATE
THE KERNEL ABOUT THIS PROCESS SPECIFICALLY,
WHEREAS WE WERE ASKING ABOUT ALL PROCESSES
BEFORE.
FOR INSTANCE, WE CAN LOOK AT THE OPEN FILES THIS
PROCESS WAS USING.
LOOKS LIKE IT WAS PIPING SOMETHING TO DEV NULL AT
THE TIME OF MEMBERRY ACQUISITION, NOT SUSPICIOUS
BUT IT DOES INDICATE THAT IT WAS PROBABLY RUNNING
IN THE BACKGROUND.
WE CAN LOOK AT ANY OPEN SOCKETS THAT THIS
PARTICULAR PROCESS HAD ACCESS TO.
LOOKS LIKE NONE.
AT THE TIME OF THE MEMORY ACQUISITION.
AGAIN, THIS DOESN'T MEAN THAT THE PROCESS NEVER
MADE ANY NETWORK CONNECTIONS, JUST MEANS IT WON'T
DOING SO AT THE TIME OF THE MEMORY DUMP.
OKAY, SO LET'S HAVE A CLOSER LOOK AT THE PROCESS
BINARIES.
OH, LOOK, IT WAS USING THE PYTHON LIBRARY SET
PROC TITLE.
THIS IS A LIBRARY THAT PROVIDES AN API TO
OVERRIDE A PROCESS NAME AND COMMAND LINE
ARGUMENTS SO THAT'S HOW IT HID ITSELF.
WE STILL DON'T KNOW ANYTHING USEFUL ABOUT THE
PROCESS'S INTENTIONS, THOUGH, OR WHAT IT DID
BEFORE THE CHIEF ACQUIRED THE MEMORY DUMP SO
LET'S LOOK AT THE PROCESS'S BOOKS, NAMELY STACK
AND HYPE.
THERE MIGHT BE INCRIMINATING EVIDENCE IN THERE.
WE HAVE THE START AND END ADDRESSES HERE SO WE
CAN TAKE THE FILE THE CHIEF GAVE US, SEEK TO THE
START ADDRESS AND READ UNTIL THE ENDS ADDRESS,
RIGHT?
SO LET'S START WITH THE STACK.
THERE'S ONE PROBLEM.
THE ADDRESSES ARE REALLY, REALLY BIG.
THAT WOULD MEAN THE STACK IS ALMOST 141,000
GIGABYTES INTO THE MEMORY DUMP BUT THAT'S ONLY 2
GIGABYTES, SO WHAT GIVES?
ARE THE KERNEL'S RECORDS WRONG?
IS IT IN ON THE WHOLE THING AND IMPEDING OUR
INVESTIGATION?
NO, ACTUALLY, NO, IT ISN'T.
WE'RE JUST INTERPRETING THE ADDRESSES WRONG.
ALL THE ADDRESSES OF THE KERNEL LAST GIVEN US ARE
VIRTUAL ADDRESSES.
NOT PHYSICAL ADDRESSES OR OFFSETS INTO RAM.
A PROCESSES OWN MEMORY IS ONE LARGE CONTIGUOUS
BLOCK CALLED THE PROCESS ADDRESS SPACE OR PROCESS
MEMORY AND ONLY EVER DEALS WITH VIRTUAL ADDRESSES
IN ITS OWN ADDRESS SPACE.
THAT'S THE ADDRESS YOU'LL GET IN GDB OR IF YOU
REFER AN OBJECT IN PYTHON AND USUALLY REPRESENTED
IN HEXADECIMAL FORM.
IT'S NOT CONTIGUOUS IN PHYSICAL MEMORY, THOUGH,
IT'S SLICED UP BY THE OPERATING SYSTEM INTO TINY
CHUNKS CALLED PAGES BY ARE ABOUT FOUR KILOBYTES
EACH, COULD BE LARGER.
EACH PAGE MAYBE MAPPED TO A DIFFERENT PORTION OF
THE PHYSICAL SPACE OR RAM.
OR MIGHT NOT BE MAPPED AT ALL.
MOST OF OUR PROCESSES SPACE IS NOT USED.
YOU SAW THE STACK'S VIRTUAL ADDRESSES, LARGE
NUMBERS, WHICH MEANS THE PROCESS IS BIGGER THAN
RAM.
SO WHY WASTE PHYSICAL MEMORY ON SPACE.
EVEN THE PAGES THAT ARE USED MIGHT NOT BE
CURRENTLY MAPPED TO PHYSICAL MEMORY.
THEY MIGHT BE SWAPPED OUT TO DISK OR COMPRESSED
IF THE PROCESS DOESN'T NEED THEM IMMEDIATELY.
EACH PROCESS USES ONLY THE MEMORY THAT IT NEEDS
WHEN IT NEEDS IT, THAT'S WHAT ALLOWS MANY
PROCESSES, EACH HAVING A HUGE ADDRESS SPACE IS TO
SHARE A LIMITED AMOUNT OF PHYSICAL MEMORY.
THE REASON A PROCESS CAN PRETENDS THAT ITS MEMORY
IS ONE GIANT CONTIGUOUS BLOCK IS THAT WHENEVER IT
ACTS AS DATA AT A VIRTUAL ADDRESS, THE MMYOU WANT
UOR MEMBER -- MEMBER BRING MANAGE.
UNIT TRANSLATES THE ADDRESS INTO A PHYSICAL
ADDRESS AND IF THE ADDRESS HAS BEEN TRANSLATED
BEFORE, IT MIGHT BE CAMPED IN THE TLB OR
TRANSLATION LOOK-ASIDE BUFFER INSTEAD OF BEING
RETRANSLATED.
IF THE DATA HAS BEEN SWAPPED OUT, IT'S SWAPPED
BACK IN SO THE PROCESS CAN ACCESS IT AND ALL THIS
HAPPENS TRANSPARENTLY TO THE PROCESS.
WHO HAS NO IDEA ANY OF THIS IS GOING ON.
VOLATILITY CAN ALSO TRANSLATE A VIRTUAL ADDRESS
INTO A PHYSICAL ADDRESS.
WE COULD JUST ASK IT TO DO THE TRANSLATION TORE
US, TO GET US A STACK AND HEAP AND WE WILL DO
THAT BUT ACME IS THE KIND OF ORGANIZATION THAT
PROVIDES ACCOUNTABILITIES AND OVERSIGHT FOR
CONTRACTORS, SOMETHING, SOMETHING --
SOMETHING-SOMETHING FRUIT OF THE POISON TREE, WE
CAN'T LET VOLATILITY BLINDLY GET US THE EVIDENCE,
WE HAVE TO UNDERSTAND HOW TRANSLATION WORKS.
IN SOME CASES, IT MIGHT BE VERY SIMPLE.
FOR EXAMPLE, ON LINUX AND OS 10, THE CODE AND
DATA SEGMENTS OF THE KERNEL ADDRESS SPACE ARE
IDENTITY-MAPPED, WHICH MEANS THAT WHILE THOSE
REGIONS ARE STILL DIVIDE UP INTO PAGES, THOSE
PAGES AREN'T SCATTERED EVERYWHERE THROUGH
PHYSICAL MEMORY.
THEY'RE LAID OUT IN THE SAME ORDER AS IN PROCESS
MEMBER RIFF.
BUT THAT'S ONLY THE IDENTITY MAPPED REGIONS.
THE OTHER REGIONS ARE STILL SORT OF SCATTERED.
FOR THE IDENTITIES MAPPED REGIONS, THE VIRTUAL
ADDRESS IS THE PHYSICAL ADDRESS PLUS CONSTANT
OFF-SET, WHICH IS FOR 64 BIT SYSTEMS.
THE 32-BIT IS RECEIVE.
IS THE SPACE RANDOMIZATION IS SUPPORTED, ASLR, AS
IT IS IN NEWER VERSIONS, OTHER RANDOM CONSTANT
ALSO GETS ADDED.
THE RANDOM OFF IF SET HELPS MITIGATES BUFFER
OVERFLOW ATTACKS BY MAKING IT HARD FOR CRITICAL
ADDRESSES TO BE GUESSED.
SO THE VIRTUAL TO PHYSICAL ADDRESS TRANSLATION
FOR IDENTITY MAPPED SEGMENTS JUST MEANS
SUBTRACTING SOME CONSTANT.
BUT WHAT ABOUT THE PARTS OF KERNEL MEMORY THAT
ARE NOT IDENTITY MAPPED OR NON-KERNEL PROCESSES
WHICH ARE ALSO NOT IDENTITIES MAPPED.
WELL, BY ITSELF, A VIRTUAL ADDRESS IS JUST AN
OFFSET INTO THE PROCESS ADDRESS SPACE, BUT IT CAN
BE SPLIT INTO A SERIES OF FIVE NUMBERS LIKE THIS
THAT ARE USED IN ADDRESS TRANSLATION AND THIS
DIVISION AGAIN ONLY APPLIES TO 64-BIT SYSTEMS,
THEY'RE DIVIDED UP DIFFERENTLY AND IN FEWER
PIECES ON 32-BIT SYSTEMS BUT THE PROCESS IS THE
SAME.
HERE, ONLY 48 BITS ARE USED FOR TRANSLATION.
THE TOP 16 BITS SHOWN HERE IN BLACK ARE EITHER
ALL ONES OR ZEROS AND THEY'RE THROWN AWAY.
THESE NUMBERS, TOGETHER WITH SOME EXTRA
INFORMATION, KIND OF WORK LIKE REAL-WORLD MAILING
ADDRESSES.
IN MOST COUNTRIES, MAILING ADDRESS LOOKS LIKE
THIS, MODULO SOME FORMATTING.
THERE ARE MULTIPLE DESCRIPTION ATTENTION OF A
LOCATION, IN OTHER WORDS OF DECREASING
SPECIFICITY.
EACH DESCRIPTION IN THIS ADDRESS LETS US NARROW
DOWN THE SEARCH.
SO LET'S START WITH THE MOST SPECIFIC INFORMATION
IN THE VIRTUAL ADDRESS, THE LAST 12 BITS.
THIS IS LIKE THE APARTMENT NUMBER OF A VIRTUAL
ADDRESS.
AN APARTMENT NUMBER IDENTIFIES AN APARTMENT IN A
BUILDING, THE LAST 12 BITS OF THE VIRTUAL ADDRESS
IDENTIFY A BYTE IN A PAGE.
I'VE MARKED THAT BYTE WITH AN X.
THE RESULT OF THE TRANSLATION IS JUST THE
PHYSICAL ADDRESS OF THAT X WHICH IS THE PHYSICAL
ADDRESS OF THE PAGE PLUS THE 12-BIT OFFSET.
BUT JUST LIKE THERE ARE MANY BUILDINGS IN THE
WORLD, A PROCESS CAN HAVE MANY PAGES.
SO WE NEED TO NARROW IT DOWN.
THE NINE BITS IN GREEN IS LIKE THE STREET ADDRESS
WHICH IDENTIFIES WHICH BUILDING HAS THE
APARTMENT.
THE PROCESS HAS A TABLE CALLED A PAGE TABLE THAT
HAS A LIST OF PAGE ADDRESSES, THE GREEN BITS
IDENTIFY THE RIGHT PAGE IN THAT LIST, THE PAGE
THAT HAS THE DATA THAT WE'RE LOOKING FOR.
ACTUALLY, NO, THE PROCESS HAS MANY PAGE TABLES,
KIND OF LIKE HOW THERE ARE MANY STREETS IN THE
WORLD NAMED MAIN.
THE PROCESS DOES HAVE A TABLE OF TABLES, THOUGH,
CALLED A PAGE DIRECTORY.
IT LISTS PAGE TABLE ADDRESSES AND THE NINE BITS
IN PURPLE IDENTIFY WHICH OF THOSE PAGE TABLES HAS
THE PAGE WE'RE LOOKING FOR.
ACTUALLY, NO, THERE ARE MANY PAGE DIRECTORIES
ASSOCIATED WITH THE PROCESS AND YOU PROBABLY SEE
WHERE I'M GOING WITH THIS SO LET ME SPOIL THE
ENDING.
EACH PROCESS HAS A TABLE OF TABLES OF TABLES OF
TABLES OF PAGES.
A FIVE-LEVEL SPARSE TREE OF TABLES.
THE POINT S THEY NEED TO BE TRAVERSED USING THE
NUMBERS IN THE ADDRESS TO GET TO A SINGLE PAGE
WHICH WE CAN INDEX TO USING THE LAST 12 BITS.
THE INTERVENING TABLE FLAMES DON'T MATTER BUT WE
DO CARE ABOUT THE PER-PROCESS TOP LEVEL, WHILE
THE VOLUME TAKE IT REFERRING TO IT AS THE
DIRECTORY TABLE AND THE ADDRESS AS THE DTB OR
DIRECTORY TABLE BASE.
BECAUSE NO ONE CAN AGREE ON A THREE-LETTER
ACRONYM, THE LINUX KERNEL REFERS TO IT AS THE
PGD, PAGE TABLE DIRECTORY.
WHOSE ADDRESS IS STORED IN EACH PROCESSES MM
STRUCT.
WITHOUT ACCESS TO THE TOP LEVEL TABLE, THERE IS
NO ADDRESS TRANSLATION, AND SO THE KERNEL HAS
ONE, TOO, FOR THE PARTS OF MEMORY THAT ARE NOT
IDENTITY MAPPED.
THE KERNEL'S DTB CAN BE FOUND IN THE SYMBOL THAT
WE GAVE TO VOLATILITY, WHICH IT CAREFULLY
DOCUMENTS HERE AT THE ENDS WHEN IT BRINGS US
TASKS FOR INTERROGATION, FOR CHAIN OF EVIDENCE
REASONS WHICH IS WHAT WE HERE AT ACME LIKE TO
SEE.
SO NOW THAT WE UNDERSTAND ADDRESS TRANSLATION AND
WE SATISFIED OUR REGULATORY OVERSIGHT
REQUIREMENTS, LET'S ASK VOLATILITY TO GET US THE
STACK.
WE JUST NEED TO NOTE THE START ADDRESS AND TELL
VOLATILITY TO DUMP THE VIRTUAL MEMORY AREA THAT
STARTS WITH THAT ADDRESS.
IT WILL FIND AND READ EVERY PAGE ASSOCIATED WITH
THAT VIRTUAL MEMORY AREA AND DUMP THEM INTO ONE
SINGLE CONTIGUOUS BUY ENGINEER FILE.
WHICH WE CAN LOOK AT USING STRINGS, WHICH IS A
POSIX COMMAND FOR A SERIES OF FOUR OR MORE
CHARACTERS ENDING WITH A NEW LINE OR NULL.
BASICALLY HUMAN READABLE STRINGS, BUT THERE ARE A
LOT OF FALSE POSITIVES WHICH ENDS UP GIVING US A
BUNCH OF GARBAGE BUT ALSO RELEVANT DATA.
REMEMBER WE -- THAT IT WAS PART OF THE STACK
VIRTUAL MEMORY.
THE ARGUMENTS ARE OVERWRITTEN TO BE WHOOPSIE BUT
THE ACTUAL COMMANDS IS SHOWN IN THE VARIABLE LIST
AS AN UNDERSCORE.
IT LOOKS LIKE PYTHON RUN WITH NO HUB WHICH LETS A
PROCESS RUN IN THE BACKGROUNDS WITHOUT DOING WHEN
THE CONTROLLING TERMINAL IS CLOSED.
SO NOW WORK DO THE SAME THING WITH HEAP BUT
WOULDN'T IT BE NICE IF WE COULD REALLY GET INTO
THE PROCESS'S MINDS, UNDERSTAND THE OBJECTS THAT
IT WAS THROWING IN THERE?
IF SO, WE NEEDS TO LEARN TO SPEAK ITS LANGUAGE.
THE LANGUAGE OF PYTHON OBJECTS, AND THAT LANGUAGE
IS C, BECAUSE THIS IS CPYTHON, WHICH MEANS THAT
PYTHON OBJECTS IN THE HEAP ARE C-DATA STRUCTURES.
WE MENTION C-STRUCTS BEFORE, THAT THERAPY COMPLEX
DATA STRUCTURES COMPOSTED OF OTHERS, AND THEIR
MEMBERS ARE TYPES, UNLIKE THE TOUPOs.
THAT'S ALL TRUE.
BUT SINCE WE WANT TO INTERPRET PARTS OF THE HEAP
AS C-DATA STRUCKORS, WHAT'S MORE IMPORTANT IS
THAT IT'S A PACKING FORMULA FOR BYTES.
WE NEED TO KNOW WHAT ORDER THE BYTES APPEAR IN
AND HOW MANY OF THEM THERE ARE.
FOR EXAMPLE, THIS IS A STRUCT DECLARINGATION
BECAUSE OF THE TYPE DECLARATION, WE KNOW EXACTLY
WHAT IT SHOULD LOOK LIKE IN MEMORY, EIGHT BYTES
OF DATA BECAUSE IT HAS TWO 4-BYTE INTEGERS.
ANY EIGHT CONTIGUOUS BYTES OF MEMORY WOULD FIT
INTO THE STRUCT.
SO LET'S TAKE THE SNIPPETS OF MEMORY WHERE THE
OFFSETS ARE SHOWN IN BLUE.
IF WE WERE TO INTERPRET THE BEGINNING OF THIS
CHUNK OF MEMORY AT OFFSETS ZERO AS A POINT
STRUCTURE, WE WOULD END UP WITH ACTION -- AXIS
THREE AND Y IS TWO.
WHICH IS COOL.
HOWEVER THE PART THAT STARTS AT ONE ALSO FIT INTO
THE POINT STRUCTURE.
XA BEYOND ARE REALLY WEIRD SO, IS THIS A VALID
POINT?
TECHNICALLY, YES, BECAUSE THEY'RE INTEGERS.
BUT LET'S SAY THAT THE POINTS REPRESENTED BY THE
STRUCT MUST FALL INSIDE A CIRCLE OF RADIUS 10.
IN THAT CASE, THIS ISN'T A VALID POINT, EVEN
THOUGHT IT'S A VALID POINT STRUCTURE.
WE NEED SOME KIND OF VALIDATION CHECK TO MAKE
SURE THAT X AND Y ARE CORRECT, INDEPENDENTLY OF
WHETHER THE BYTES ARE CORRECT.
SO THAT IN MIND, LET'S LOOK AT HOW MANY BYTES ARE
IN A PYTHON STRING OBJECT.
THIS IS GENERIC APPROXIMATION OF THE PYTHON 2.7
PY STRING OBJECT.
I'M SORRY, CPYTHON DEVELOPERS SKIPPING OVER SOME
STUFF BECAUSE WE'RE RACING THE CLOCK HERE.
I WANT TO POINT OUT A COME OF THINGS.
FIRST THE STATE IS A NUMBER RATION OF ONE OR TWO.
WE NEEDS TO VALIDATE THAT.
SECOND, THE CHARACTER ARRAY IS OF SIZE ONE SO
THAT'S THE FIRST CHARACTER OF THE STRING, WHICH
IS NULL TERMINATED AND THE REST OF THE STRING
FOLLOWS IMMEDIATELY AFTER THE STRUCT.
THIS IS DOCUMENTED IN A COMMENT TO THE CPYTHON
SOURCE.
BUT VOLATILITY CAN'T ACCEPT A C-STRUCT LIKE THIS.
WE NEED TO TRANSLATE THE DESCRIPTION INTO
SOMETHING THAT VOLATILITY UNDERSTANDS, WHICH IT
CALLS THE V-TYPE.
WHICH IS BASICALLY THE SAME STRUCT DEFINITION BUT
AS A BUNCH OF PYTHON ARRAYS ANNOTATED WITH
INFORMATION ABOUT THE SIZE OF THE STRUCT AND THE
OFFSETS OF THE MEMBERS.
THE TOTAL SIZE OF THE STRUCT AS IT WAS DECLARED
IN C IS 37 BYTES.
WE KNOW THAT FROM ADDING UP THE SIZES OF ALL THE
MEMBERS.
FOR EXAMPLE, OBJECT REV COUNT WAS THE FIRST
MEMBER OF THE STRUCT DISKS WAS SPECIFIC SET ZERO,
OF TYPE LONG, WHICH IS BASICALLY A REALLY BIG
NUMBER.
REMEMBER HOW WE SAID THAT -- WHICH IS WHY THE
NEXT MEMBER OB TYPE STARTS AT 8 AND SO FORTH.
BUT ANY SEQUENCE OF 37 BYTES WILL FIT INTO THIS
STRUCT, WHETHER OR NOT THE VALUES MAKE SENSE SO,
WE NEED TO TELL VOLATILITY HOW TO VALIDATE
WHETHER THERE IS 37 BYTE CHUNK OF MEMORY IS
REALLY A PYTHON STRING.
SO WE READ THE STRING, WHICH IS 36 BYTES FROM THE
BEGINNING OF THIS OBJECT BECAUSE, REMEMBER, THE
FIRST CHARACTER OF THE THING WAS THE LAST BYTE OF
THE PY STRING OBJECT.
AND WE SEE IF IT'S A VALID PYTHON STRING.
THE TYPE POINTER HAS TO BE A VALID POINTER.
VOLATILITY KNOWS ALL ABOUT POINTER OBJECTS AND
PROVIDES A VALIDITY CHECK THAT ENSURES THAT IT
POINTS TO SOMETHING THAT'S INSIDE THE HEAP.
THE SIZE OF THE STRING ALSO NEEDS TO BE
NON-NEGATIVE AND WE CAN SKIP EMPTY STRINGS
BECAUSE WE DON'T CARE ABOUT THEM AND TO SPEED
THINGS UP, LET'S IGNORE REALLY LARGE STRINGS,
TOO.
THE STATE HAS TO BE ZERO, ONE OR TWO AS WE
MENTIONED BEFORE.
AND THE STRING HAS TO BE NULL-TERMINATED AS WE
MENTIONED BEFORE.
AND HASH EITHER HAS TO BE NEGATIVE 1, WHICH MEANS
IT HASN'T BEEN COMPUTED YET OR IT HAS TO BE THE
ACTUAL HASH OF THE STRING.
AND WE COMPLETELY IGNORE REV COUNTS BECAUSE WE
HAVE TO FIND GARBAGE-COLLECTED STRINGS.
AND THEN HERE'S SOME PSEUDO COUNT THAT TELLS
VOLATILITY TO BROUGHT-FORCE SEARCH THE WHOLE
HEAP, BY TESTING EVERY SEQUENCE OF 37 BYTES IN
THE HEAP FOR PY STRING OBJECT VALIDITY.
SO NOW WHEN WE RUN IT, IT WILL DISPLAY THE ACTUAL
PYTHON STRINGS FROM THE HEAP WHICH INCLUDES A TON
OF PYTHON DOC STRINGS.
BUT SOMETIMES YOU CAN FIND USEFUL INFORMATION,
MAYBE IN THE FORM OF A GARBAGE COLLECTED STRING.
IT LOOKS LIKE OUR PROCESS HAD PREVIOUSLY MADE AN
HTTP REQUEST, NET STATS SHOWED NO CURRENT
CONNECTIONS BUT WILL BELY THIS REQUEST IS STILL
IN THE HEAP SO WE CAN LOOK AT IT.
WE WOULD STILL SEE IT LIKE THIS EVEN IF IT WAS
MADE OVER HTTPS BECAUSE THIS IS THE RAW REQUEST
BEFORE IT'S END COPYRIGHTED OWNED WIRE.
NOTE THE BASIC AUTHORIZATION HEADER.
BASIC AUTHORIZATION ENCODES USER NAME AND
PASSWORDS SEPARATED BY A COLON, WHICH MEANS WE
CAN 64 DECODE IT AND GET THE USER NAME AND
PASSWORD.
I THINK THIS IS PRETTY INCRIMINATING AND A
MESSAGE TO THE CHIEF.
I KNOW WHAT YOU'RE PROBABLY THINKING, COULDN'T WE
HAVE GOTTEN THIS INFORMATION USING THE STRING'S
COMMAND?
YES, WE WOULD HAVE, BOTH THE DOC STRINGS AND THE
REQUEST, SO WHY DID WE BOTHER GOING TO ALL THIS
TROUBLE?
FINDING PYTHON STRINGS TELLS US SOMETHING ABOUT
THE STRING BOUNDARIES, IF THAT REQUEST WAS NOT
ONE STRING BUT MULTIPLE STRINGS, THAT MIGHT HAVE
BEEN MINUTES SOMETHING COMPLETELY DIFFERENT.
STRINGS ALSO ONLY RETURNS ASCII BUT WITH PYTHON
STRINGS WE MIGHT BE ABLE TO SEE BYTES REDS INTO
THE PROCESS FROM A FILE, LIKE AN IMAGE.
ALSO WITH PYTHON THINGS, MORE FILTER AROUND THE
LIFE CYCLE.
MAYBE WE COULD TO EXCLUDE PYTHON STRINGS.
AND IT USES VOLATILITY CHECKS TO FIND ALMOST
ANYTHING, KERNEL STRUCTURES, MODULES, NETWORK
PACKETS AND ON EVERY PLATS FORM, NOT JUST LINUX,
USUALLY MORE CLEVERLY THAN BROUGHT FORCE, TOO.
AND NOW WICK DO THE SAME ANYONE FOR OTHER PYTHON
STRUCTURES, BUT UNFORTUNATELY THAT'S ALL THE TIME
WE HAVE FOR TODAY AND I THINK THE CHIEF NEEDS TO
DEAL WITH HER MOM.
THAT'S RIGHT, DETECTIVE, I LOGGED INTO MY MOM'S
SERVER WITH HER EVERY CONNECTIONS SEEMS LIKE IT
WAS RETURNING COMMANDS THAT THE PYTHON PROCESS
WAS SUPPOSED TO RUN ON THE ACME SERVER.
I'M GOING TO BLOCK ALL INBOUND AND OUTBOUNDS
TRAFFIC TO THAT I.P.
NOW I'M GOING TO CALL MY MOM AND GLOAT ABOUT HOW
WE FOILED HER PLANS.
GOOD JOB, GUMSHOES.
UNTIL NEXT TIME...
[ Applause ]
FOR MORE INFORMATION, I RECOMMEND THE BOOK THE
"ART OF FORENSICS," WHICH MADE ME WANT TO DO THIS
TALK.
I DON'T DO ANY FORENSICS BUT A FUN LEARNING TOOL
TO LEARN ABOUT MEMORY.
ALSO, THREE FANTASTIC TALKS EARLIER AT PYCON THAT
GO INTO GREATER DETAIL ABOUT SOME SUBJECTS THAT I
BARELY TOUCHED UPON AND THEY'RE LISTED HERE, SO
PLEASE CHECK THEM OUT.
A FULL WORKING VERSION OF THE PYTHON STRING
SEARCHING CODES IS ON MY GITHUB ACCOUNT.
IT'S NOT BRUTE FORCE, MUCH MORE OPTIMIZED AND I
WILL BE HAPPY TO ANSWER ANY QUESTIONS ON TWITTER
OR OUTSIDE.
THANK YOU FOR COMING AND THANK YOU FOR YOUR TIME.
[ Applause ]
>> THANK YOU VERY MUCH.
THAT WAS REALLY GREAT.
