  666
  >> All right.  Good morning.  God, this is a great wake up to the lights.  So, welcome to the last round of lightning talks some people are -- Whoo, yes!
  I was hoping maybe few more people would be here since we didn't have that fun run.  It's Sunday.  I can understand that.  We'll just jump right in.  We're going to take a look at ergonomics.  Sorry.  Take look at your keyboard.
  >> All right.  Have you looked at your keyboard?
  How did you choose yoir keyboard?
  Do you choose it because it has cool blue or company that made it for the company that made it has a Z in it or the one that came with your computer E. in all ever these cases you're probably doing it wrong.
  The keyboard is analog to digital interface that you use the most, what makes your physical movements into code.  But of course, it's not created for this, it's created from mechanical typewriters therefore, it has straight rows with staggered keys.  That's not always the best thing to type at.  But there are basically two modes of typing.  The first school of typing is called home row touch typing.  The second school doesn't exist.  And home row touch typing means that you're supposed to hold your hands like this.  But how is this guy actually holding his hands.  Like attached to the center of his chest he's typing like this.  That's not how it actually looks.  It looks like this.  And this puts strain on your wrists and can lead to pain.  Therefore, if you are touch typist you should have a keyboard that looks kind of like this.  Some sort of ergonomic keyboard.  You may at some Python script see people who have keyboards like this.  They tepped to be quite fanatical about them.  They're probably awesome if you're a tougher typists if you're not ergonomic keyboards that are split in two parts are annoying.  So, if old school typing you actually want to have the classical straight keyboards.
  Buyers beware there is two major physical.  Iso and an see.  Not only using the layout you're not used to it's annoying because the enter key is in different places.  Ansi is missing a key by the left shift, you see here.  That happens to be the key in many language lay outs where larger and smaller and.
  Which means that you can't type HTML.  So, that's kind of annoying if you're a web developer.  Also due use the numerical keyboard.  The keyboard is designed by IBM for mainframes where you in the '60s typed in a lot of numbers.  That's what we were doing with computers then.  But today we don't use the numerical keyboard.  That is just in the way you have to have your arm further to the right.  This can lead to shoulder pain especially for people who have narrow shoulders like women or me.  So, it's just in the way.  If you go a store try to buy a keyboard without it's usually a mini keyboard with mini keys you don't want that.  Numerical.  The name of full-size keyboard that hasn't have a numerical key bad is a ten keyless keyboard you need to buy them online.  They are also expensive because they are more or less made by hand because you can get them with whatever layout you want, usually whatever colors of the keys you want and stuff like that.  You can have keys that are specially adapted keyboard lay outs for different color.  Also you have to think about what kind of keys because there's loads of actual physical keys, different mechanical design of how much noise they make and tactile and how long the keyboards.  It can give you serious pain, if you pretioned it hard and fast it would hit you twice in the fingers.  So, I can only recommend that you read and read and read on a wiki that is called deskthority.  Remember this.  It has crazy amounts of information on keyboards and switches.  The most popular switches amongst people who look at the keyboard are called cherry MX they have different colors and after much research bought a ten keyless keyboard that uses cherry MX brown with damperary rings.  This is for me I'm very happy with it.  You should all take a look at your keyboard and do some research on what you actually want and need.  That's all.  Thank you.
  >> Thank you.  I didn't see the apple keyboard there.  Should I change my keyboard.
  >> Probably.
  >> All right.  Next up we of a Marc talking about Python in denome iks, automation, analysis and visualization.
  >> So, hi, everyone.  I want to talk how we use genomic stud he's.  The first step is going fob to talk a bit how they actually work.  So first step that design and recruitment where we actually talk to patients, sign content forms, ask them if they want to be in the study.  There is that acquisition to start from the chromosome which is a physical, biological entity and digitalize into D.N.A. that we can read on the computer.  Then because technology we use for this is cheaper we only have access to some of the basics of the D.N.A. we have missing values.  We use computation to guess from?
  Surrounding and correlated positions that Dan -- D.N.A. at positions we don't have on the initial raw data.  This is same concept as in general statistics but genomics it's guessing the D.N.A. basis we don't have.  Then we actually want to do some analysis, most of the time it's to associate genetic markers with human traits or diseases so we use regression technique to do that all talk more about them later.  Finally, if we're lucky we find something useful we usually try to public it in "scientific journal".  I'm going to focus on imputation and analysis that what we use Python for.  I wanted to talk about genome wide pipeline which is cool we developed to do the input is the data with the missing values the question marks represent basis we don't have imputation.  Some letters are missing then we use a specialized program to guess the missing basis.  So, hopefully we get high confidence probabilities for those missing values as seen on the right where we have all the missing D.N.A. letters for these patients.  So, this might look simple but actually Gwip wraps these tools takes care of handling all the intermediate files that are generated, it's a very my number, very tedious to handle by hand very useful for that.  Also takes care of parallelisms it's very good going faster on high performance computing clusters using the DRNA, API this is all in Python.  Also after that you need to write your report for your boss, which is going to ask if you have high confidence in your D.N.A. calls and all that.  We used to do that by hand now been GWIP you can get automatic report generation this is really cool.  We use to do templates and then other report is going to get generated in a PDF form this is another automation we do with GWIP.  Then we go to analysis.  Analysis is really similar to what people do in statistics in different fields.  So this is an example with LDL cholesterol level.  The bad level.  One SNP, here as you can see as you add the G allele have higher cholesterol level this is the kind of association we're looking for.  We use classic statistical like linear regression or GLMs and all this we do the standard Python statistical analysis and stats models and life lines for survival analysis and stuff like that.  Also keep in mind that we do this for stuff like seven million markers, those are huge datasets a lot of tests we need to run.  So Gwip takes care of making this in parallel using the underlying tools.  Then final thing I wanted to talk about is visualization.  This is a plot.  The P values which are results of the statistical test, the X axis is the ordered variants so this good way of seeing quickly the results of the seven million tests.  This is only a restricted sub set this is real data that was published.  The mountain you see with the red dots at the top is actually a real actually association signal.  And this plot shows a lot more like the correlation between the different bases uses the color, if the markers were genotyped on the actual and genes are all shown here.  To finish I'd like to thank my advisor and the Gwip main author, all my fellow lab members.  If you're interested in seeing how it's written it's on GitHub.  Feel free to come and see this.  Thank you.
  [ Applause ]
  >> Thank you.  Awesome.  Next up, heard a little preview of this gaming music maybe?
  We have Daniel talking about writing an award winning adventure game in Python 3.
  >> Hi, I'm Daniel.  I'm a professional Python programmer but my hobby is programming computer games in Python.  Who here have heard of PyWeek.  Some people have.  The PyWeek website.  It's a games programming competition in which you're challenged to write a game from scratch with only published libraries, no personal code basis in exactly one week on a theme that is given to you at the moment a contest starts.  You have one week, you have to enter your game the day after that seven-day programming period.  And in October -- it's been sort of -- I don't know.  A lot of Pyweeks so far but they run twice a year.  In October the theme selected was one room.  And I won.  Yeah!
  [Applause]
  Sometimes like to joke that I am the world champion Python games programmer.  I wanted to show you my game which -- this is a little way into the game.  And it's set in one room obviously.  Does somebody want to call out somebody to try?
  Pick up the sock.  Something else?  Poke the bird.  Okay.
  [Applause]
  All of this action that is happening it's a complete adventure game.  It's an adventure stage play.  It's a lot more linear and scripted than some adventure games.  And partly done to constraints of trying to do it in one week.  But I start, I sat down on the Sunday of PyWeek, first day of PyWeek I started writing a script.  Very soon I realized I wanted the script to be executable and so I eventually evolved this into a DSL language for designing adventure game.  So, this is the start of the game.  This is include with some additional bindings but then the character -- square brackets is stage directions, anything that sort of starts with capital letters is something that somebody says.  There are bindings in Python for each of these stage directions and things.  Okay.  So, this is some of the other syntax, this is to allow you to -- allow and directives, allows you to do something sort of plays the default  thing, and deny makes it so you can try that thing but it will not let you do it.  There's more and more syntax to do the various things I needed to in the game.  And all of those stage directions, you can say goblet the main character moves to center stage, these are defined in Inkscape.  And the purple section is navigable floor area.  It looks a little bit 3D but it's being routed like 2D space of the window.  So, it's like slightly modified rooting out rhythm it looks like he's closing the floor.  But that allows to you then define whole plays without writing any Python -- any additional Python code.  Py game on Python 3 is available.  It's not been released.  And on Mac you have to compile with home brew which seems horrible but that's for the Mac people.  But then -- some lessons to take away.  I think the approach of writing a script and executing it was brilliant.  And as always doing that up front gives you the whole direction for the game.  So that's really good practice.  But then writing adventure game in a week is hard because there are so many object combinations.  Every time that you try using the sock with kettle, you really -- about why that doesn't work.  And that is a lot of effort.  But it's possible if you have more time to spend.  It's possible in a week.  And then Py game if you just keep your game to Py game that is really good way of doing it.  So, that's it.  That's the URL if you want to download it.
  [Applause]
  >> Thank you.  Awesome.  Next up we have Pierre Francois talking about managing your science lab in Python.
  >> Hello, everyone.  I'm Pierre Francois I'm a physics student from Mcgill university in Montreal.  I'm going to talk about how to use Python in the lab.  So, I work in low temperature physics, this is a picture.  You can see lots of doers and instruments and pipes everywhere.  As I say we use a lot of different measure devices.  And before scientists would have to take data from this thing, put that in the lab book then analyze that later but now we can communicate with the device and connect that to a computer to record that.  The problem there is a lot of different measure devices and lot of different softwares, they come with like little API's of software it's quite difficult to make them cross talk have like different instruments from different companies because the companies do not want to collaborate together to make a better life for a scientist.  So, one of the solutions is labview.  Here, I'm just kidding because that's what a labview code looks like.  And this is actual code.  There's no script -- that's the scripting version, that's for like moderate size project.  Moreover, you also have proprietary license and backward compatibility irk use.  If you have the newer version of laugh view you can open the earlier ones but if you have the earlier version you cannot open the newer ones.  Again, the upper part is code the other one is interface.  So that's why the solution is more likely to be Python.  What we did, we wrote the driver of the instrument with a Python and we used that to connect the instrument using Pyvisa, Pyserious or PCPIP which I got here.  We managed communication with the instrument using its own communication protocol so all the instrument have their communication protocol given or you can extract them by -- people will make the instrument.  And then we made little GUI in which we can connect all the different instruments and set up our experiments.
  I'll show you the GUI afterwards.  Using threads to take and plug data at the same time so it doesn't lag.  I used QT signals to talk between threads and exchange information.  And because the experiment is what changes because we want to be able to use that different person in the lab use the same instrument but we don't do the same thing with that.  So we said that the experiment in a file which is loaded in the executed, you can describe what procedure you want to do with your instrument.  I'm just going to show you all the interface look like.  So, here, you have the little instrument rack so you can choose instrument from lots of different drivers.  Here you can connect that to a lot of different parts, you can select different things you want to measure from your instrument.  Here in the main window we have the Q widget area we can add more plots we can add widgets.  The cool thing with that is we made it so that we can implement new things as we need it.  Not be like slaves from program which is given to us by a company.  And if we want new feature we can easily add it.  That is how data would look like then you can edit the color or these kind of things.  You can all make that really nicely using Python.  Advantage you have lot of modularity and reusability with the instrument drivers.  So, once the instrument driver is written you can improve them and you can share that with other people that are using the same instrument.  You can as I said experiment part is done in a script you can just change the script but still use all the GUI you don't have to redo it.  And you can improve the program by added like function that can make on the fly plotting.  And Python has a lot of help in people developing other stuff.  It's easy to take that and implement that into the thing to make an actual device work well to serve your purposes.  That's all.  Thank you for your attention.  If you want to see the project you can go download on the work page.  Thank you.
  >> Thank you very much.
  >> My employer, Spotify has been very public about use of Agile.  I think it works really well when done correctly I'm excited to hear Walter Reade talking about the scientific foundation of Agile.
  >> All right.  Some guy gave a five-minute talk on the scientific foundation of Agile you won't believe what happened next.  It's a very deep topic.  In fact you can't do it in five minutes the purpose to whet your appetite maybe, who knows, come back next year do a full section so make sure you vote.  So, that's me, really quickly.  Agile, so, who has heard of Agile raise your hand.  Raise your hand keep it up if you're doing Agile.  Keep your hands up if you feel like you understand all the tools and why they work the way they do.  Less hands, right?
  Lot of times a tool like Agile feels like a set of tools but actually has a deeper foundation.  And the four minutes I have left I want to convince you it's based on the scientific method and if we look at it that way we understand the tools better and we utilize the tools better.  So, a review of the scientific method this is middle school science we form a hypothesis, step one.  We do an experiment.  Check three, check our results.  Was it consistent with my hypothesis.  And step four, we take action. Publish a paper or redo.  This applies to management system.  Edward, the quality Guru who transformed manufacturing in Japan, he was really key to applying this to how we do kind of our systems.  Our processes.  And he called it plan, do, check, act.  Which is the same four steps as the scientific method.  But in ways that was less intimidated to management.  Nothing against management.  So, it's also known as PDCA, plan, do, check, act.  The scientific method and really simple yet deceitfully hard to do.
  
  A lot of companies or teams do PDPD which is plan, do, plan, do.  They never actually check.  What I did actually meet my hypothesis.  Lot of companies do, or teams do PDCA, which is plan, do, complicate, and...  I see a few teams who practice this, right?
  So, here is the key take away.  Your work will be better if you use scientific thinking and we often think about the longer cycles.  In three months I'm going to check my project and do a review.  But scientific thinking happens on a day-to-day basis like within hours and minutes.  So I'm going to give you a couple examples just to give you a glimpse.  So there was a presentation what programmers can learn from pilots by Andrew Godwin was fantastic.  They use checklists.  If I asked what the purpose of checklists were, people say, make sure everyone is doing the same thing consistently.  You know, I do checklists even if I'm only person that's going to do the checklist.  The checklist is actually the scientific method.  So, we plan our work checklist, we do it, we go down the checklist.  Then we -- did we get the desired output of the checklist?
  And if we did not, what should we do?
  Update the checklist.  Right?
  Those are the four steps.  So many people, this checklist is sub optimal I'm not going to use that.  No, only doing D, not that C and A.  Checklist is a scientific method.  If I follow these steps I expect a certain outcome.  If I do these things I'll have a successful server restart.  So when we use the scientific method it helps us improve our processes not just do our processes.  Okay.  So, checklist, super simple.  We don't need to over complicate them.  Kanban, love it, a  few hands.^ What is the primary purpose, anybody really quick?
  Primary purpose.  Flow.  Okay.  Yes, it definitely helps with flow.  There is primary purpose I'll explain generated from manufacturing but it's actually to limit work in progress.  Which then helps us do flow I'll explain that.  But if we don't understand that, how do we know if we're using the tool correctly.  We don't.  So, Kanban came out of manufacturing to limit the work in progress.  So, Wip is bad.  You have manufacturing, warehouse costs, you have damage to your materials, obsoletion, also increases lead time like a new project or product has to go through all the way through the inventory to get to the other side to start using that.  With human work, right, we don't have warehouses and what not but why is it bad more science.  If we work on a project 100% of the time how long does it take to finish a 40 hour project?
  40 hours, very good.  So, I finish my first project in week one, then week two I got another one.  Week three, week four, great.  What happens in real life when I work on four projects 25% of the time?
  How long does it take to complete a 40 hour project?
  Still 40 hours.  But, now I just stretched the lead time of each one of those projects to four weeks.  I've made three of those projects have a longer lead time.  So, the purpose of Kanban limits our work in progress to reduce the lead time if we understand that, we're using the scientific method if we use checklist to improve our processes of our repetitive tests use Kanban we'll become more effective at improving our processes and shorting the lead time.  What is not to like about that, right?
  Thank up.
  [Applause]
  >> Thank you very much.  Last lightning talk of the morning.  Manish talking about function programming ideas in Python.
  >> I work in blackspace on autoscale product, I'm here to talk about taking ideas from the functional programming world applying to Python and other languages.
  Sorry.  Sorry.  Yeah.
  [ laughter ]
  Okay.  Sorry about that.  The idea here is to think about the behavior of your application and what are the logic behind it and see if you can represent it as a bunch of pure functions.  And once you start doing that there are lot of advantages to pure functions and one of the most obvious ones are obviously no side effects you have lot easier testing.  You have lot more advanced testing which you can do with the pure functions but I'm not going into that detail now.  Here the idea to take -- in terms of Python, this idea is taken out of where you describe -- describe the real world in terms of types and you work only on types, you don't work on actual data.  In terms of Python what you do basically always clear -- always work on those glasses.  So, the other thing is don't clear dictionaries and move them around in your code.  Create classes there are nice tools to create classes one of them is -- author that have is sitting right here.  It helps you create library, very nice library, lets you create small classes, you create objects, you can move them around anywhere.  When you performing actions within Python, think about representing that one action as a separate function.  And isolated into that one function and move that function around everywhere.  Let that function be passed into other functions then performed.  When you start isolating the small pieces of actions in separate small functions you can see that it makes -- your code becomes lot cleaner it's easier to find out where there are side effects and you have a global state.
  Better way of doing that is once you have figured out that, okay, these are the small actions I want to perform, a bunch of functions even better way to actually use this library called effect.  My co-worker Chris Armstrong couldn't be here, it's awesome library and using that.  This library helps you represent actions as a bunch of Imutable data structure and work on just data structure and perform it at some point of time later.  Ideas are basically inspires from Pascal's.  The whole point of this talk is basically to have small imperative shell that performs -- sorry, small imperative shell that performs the actions.  The code of application is pure.  And one of the advantages of that is much better unit tests.  If you -- I cannot tell you how much actually it is but once you use effect, you realize that you don't need to create mock -- don't need to create mocks anywhere in your code.  The tests just become extremely functional and much more easier to write.  So, how do you know when you have to apply this kind of ideas?
  When you this -- if you take existing code base how do you know at what point of time you can start using small bits of pieces to use effect.  One of the ways which we figured out is when you have lot of -- have a code which does a lot of mocking, I'm sure you have lot of tests, have lot of mocks in it.  We all agree that mocking is good but it's not best because you can always have some silent test here and there which passes but actually it's buggy.  So, when you have a test which have lot of mocks think about using effect:  So, one of the examples we have is Rackspace autoscale convergence.  Convergence is a feature you tell autoscale product that I want X number of servers it will do whatever it can to bring that number of servers up.  What it does, creates a plan.  And executes that.  So creating directly executing it we first created a plan and we built tests around the plan.  Sorry, my time is up.  Thank you.
  [Applause]
  >> I want to thank the speakers and awesome AV folks for helping out, let's give another round of applause.
  [Applause]
  All right.  If this has inspired you, you should think about lightning talk next year.  
  
