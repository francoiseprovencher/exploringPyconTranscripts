-00:00:02  >> GOOD AFTERNOON, EVERYBODY.
00:34:09   WELCOME TO DAY TWO OF PYCON.
00:34:11   SO, ALLISON WILL NOW BE GIVING THE FIRST OF HER
00:34:14   TWO TALKS FOR THIS SESSION.
00:34:16   THIS ONE IS CALLED "BYTES IN THE MACHINE."
00:34:18   ALLISON WORKS AT DROPBOX.
00:34:20   I'LL LET HER TAKE IT AWAY.
00:34:22   PLEASE GIVE HER A WARM WELCOME.
00:34:25   [ Applause ]
00:34:27   >> THANKS VERY MUCH.
00:34:28   CAN YOU HEAR ME OKAY?
00:34:29   HOW DOES THIS SOUND?
00:34:32   CAN EVERYONE HEAR ME OKAY?
00:34:34   GREAT.
00:34:34   SO AS ESTHER SAID, I'M ALLISON KAPTUR, I WORK AT
00:34:38   DROPBOX.
00:34:39   I WAS PREVIOUSLY A PROFESSOR AT HACKER'S SCHOOL
00:34:44   AND THIS IS WHERE YOU CAN FIND ME ON THE INTERNET
00:34:46   AND THIS IS BASICALLY MY HANDLE ANYWHERE ON THE
00:34:49   INTERNET.
00:34:49   I'M GOING TO TALK ABOUT WRITING A PYTHON
00:34:51   INTERPRETER IN PYTHON, PARTICULARLY CPYTHON.
00:34:56   THIS IS BYTES RUN, AND DONE WITH NED BATCHELDER,
00:34:59   HE DID MOST OF THE PYTHON 2 SUPPORT, HE CAME IN
00:35:02   AND DID PYTHON 3 SUPPORT.
00:35:04   WORKING ON THIS WITH NED FOR ABOUT A YEAR, AND
00:35:06   IT'S BEEN A REALLY INTERESTING AND EDUCATIONAL
00:35:09   EXPERIENCE AND I WANT TO SHARE THAT WITH ALL OF
00:35:11   YOU TODAY.
00:35:11   SO BEFORE WE GET STARTED, THE WORD "INTERPRETER"
00:35:16   IS USED IN A VARIETY OF DIFFERENT WAYS WHEN
00:35:18   PEOPLE ARE TALKING ABOUT PYTHON.
00:35:19   SOMETIMES WHEN SOMEONE SAYS THE INTERPRETER THEY
00:35:22   MEAN, THE REPL, THE INTERACTIVE YOU GET,
00:35:28   SOMETIMES PEOPLE SAY THE PYTHON INTERPRETER TO
00:35:31   MEAN ALL OF PYTHON, THE WHOLE PROCESS OF
00:35:33   EXECUTING CODES.
00:35:33   TODAY WE'RE GOING TO TALK ABOUT IT IN A MORE
00:35:37   NARROW SENSE.
00:35:38   AN INTERPRETER FOR OUR PURPOSES IS THE LAST STEP
00:35:39   IN THE PROCESS OF RUNNING A PYTHON PROGRAM.
00:35:42   WHEN PYTHON EXECUTES YOUR CODE, YOU CAN THINK OF
00:35:46   THERE BEING 4 STAGES.
00:35:47   THERE'S LEXING AND PARSING, WHICH IS GOING FROM
00:35:50   SOURCE CODE INFILES TO AN AST THAT THE COMPILER
00:35:54   KNOWS WHAT TO DO WITH.
00:35:56   THEN THERE'S COMPILING, WHICH IS TAKING THE AST
00:35:59   AND TURNING IT INTO A CODE OBJECT THE INTERPRETER
00:36:01   KNOWS HOW TO HANDLE, AND THEN THERE'S
00:36:03   INTERPRETING, WHICH IS TAKING THE CODE HANDLE AND
00:36:06   DOING WHATEVER IT SAYS.
00:36:07   SO BYTE RUN IS A PYTHON INTERPRETER IN THIS
00:36:09   SENSE, TAKES COMPILE CODE OBJECTS AND MAKES THEM
00:36:13   RUN.
00:36:13   YOU MAY BE SURPRISED TO HEAR THAT COMPILING IS A
00:36:15   STEP IN PYTHON AT ALL, SINCE PYTHON IS FAMOUSLY
00:36:18   AN INTERPRETED LANGUAGE IN CONTRAST WITH THE
00:36:21   COMPILED LANGUAGE LIKE C OR REST.
00:36:24   IT TURNS OUT THAT THIS TERMINOLOGY IS NOT AS
00:36:26   PRECISE AS IT SEEMS.
00:36:28   AND IN FACT, MOST INTERPRETED LANGUAGES INCLUDING
00:36:31   PYTHON DO INVOLVE A COMPILATION STEP.
00:36:34   SO THE REASON WHY PYTHON IS CALLED INTERPRETED
00:36:36   INSTEAD -- EVEN THOUGH IT INVOLVES COMPILATION,
00:36:39   IS THAT THE COMPILATION DOESN'T DO A LOT OF WORK
00:36:40   IN PYTHON AND THE COMPILER KNOWS VERY LITTLE.
00:36:43   AND BY CONTRAST, THE INTERPRETER DOES A LOT MORE
00:36:45   WORK AND THE INTERPRETER IS RESPONSIBLE FOR A LOT
00:36:48   MORE.
00:36:48   AND THE PYTHON COMPILER HAS MUCH LESS INFORMATION
00:36:52   ABOUT THE PROGRAM THAT IT'S GOING TO EXECUTE THAN
00:36:55   A C-COMPILER DOES.
00:36:57   A PYTHON INTERPRETER IS A VIRTUAL MACHINE WHICH
00:37:00   JUST MEANS THAT IT'S SOFTWARE THAT EMULATES A
00:37:02   PHYSICAL COMPUTER.
00:37:03   AND THIS PARTICULAR VIRTUAL MACHINE IS A STACK
00:37:06   MACHINE, SO IT MANIPULATES SEVERAL STACKS TO
00:37:08   PERFORM ITS OPERATIONS.
00:37:09   THIS IS IN CONTRAST WITH A REGISTER MACHINE WITH
00:37:12   WHICH YOU COULD MANAGE A VIRTUAL REGISTER MACHINE
00:37:16   IS A DIFFERENT THING BUT THE IDEA WOULD BE YOU
00:37:18   WRITE TO AND READ FROM VARIOUS LOCATIONS IN
00:37:19   MEMORY, INSTEAD OF DOING THAT, WE'RE OPERATING ON
00:37:21   A STACK.
00:37:22   AND IN PARTICULAR, THE PYTHON INTERPRETER IS A
00:37:24   BYTECODE INTERPRETER, SO ITS INPUT IS IN THESE
00:37:29   INSTRUCTION SETS CALLED BYTECODE.
00:37:30   WHEN YOU WRITE PYTHON, THE LEXER, COMPILER
00:37:33   GENERATE THE BYTECODE, IN ADDITION TO SOME EXTRA
00:37:36   PARTS THAT THE INTERPRETER NEEDS TO RUN.
00:37:38   AND THE INTERPRETER THEN CONSUMES THOSE
00:37:41   INSTRUCTIONS.
00:37:41   BYTECODE IS OFTEN CALLED AN INTERMEDIATE
00:37:46   REPRESENTATION OF PYTHON CODE BECAUSE IT
00:37:50   EXPRESSES THE SOURCE CODES THAT YOU WROTE IN A
00:37:53   WAY THE INTERPRETER CAN UNDERSTAND.
00:37:54   THIS IS ANALOGOUS TO THE WAY ASSEMBLY LANGUAGE IS
00:37:58   BETWEEN C-CODE AND A PIECE OF HARDWARE.
00:38:00   AN INTERMEDIATE REPRESENTATION LIKE THIS ADDS A
00:38:02   LAYER OF COMPLEXITY TO YOUR EXECUTION MODEL, SO
00:38:05   THERE IS A COST TO IT IN THAT SENSE.
00:38:06   BUT THE ADVANTAGE IS THAT ALL THIS WORK, THE
00:38:08   LEXING, PARSING, COMBINING Y, ONLY HAS TO BE DONE
00:38:13   ONCE FOR EACH CODE OBJECT INSTEAD OF EVERY TIME
00:38:16   YOU NEED THE CODE OBJECT LATER.
00:38:17   SO OUR GOAL TODAY IS A BYTECODE INTERPRETER.
00:38:21   WHY WOULD YOU WRITES AN INTERPRETER?
00:38:25   CPYTHON IS PRETTY GOOD AND REWRITING IT
00:38:26   PARTICULARLY USING THE STRATEGY WE TOOK WHICH IS
00:38:29   TO REWRITE IT IN PYTHON WON'T MAKE IT BETTER OR
00:38:31   FASTER IN MOST WAYS.
00:38:32   SO FOR NED BATCHELDER, YOU MAY KNOW HIM AS THE
00:38:37   EDITOR OF COVERAGE TEST -- THIS IS A REALLY
00:38:41   TRIVIAL EXAMPLE OF A LINE OF CODE WHERE LINE
00:38:44   LEVEL COVERAGE CAN BE MISLEADING.
00:38:46   YOU MAY HAVE WRITTEN A TEST, THE TEST A BUT NOT B
00:38:50   SO YOU COULD HAVE A BUG IN YOUR PROGRAM HERE AND
00:38:51   LINE LEVEL COVERAGE WOULDN'T CATCH THAT.
00:38:53   SO THE ORIGINAL GOAL OF BYTE RUN WAS TO
00:38:56   INVESTIGATE WHETHER BYTECODE LEVEL COVERAGE WOULD
00:38:58   BE AN INTERESTING THING TO PURSUE.
00:39:00   AND ONE OF THE LESSONS FROM WORKING ON THIS
00:39:03   PROJECT IS THAT IT'S EXTREMELY FIDDLY AND WE HAVE
00:39:06   NOT ENDED UP PURSUING THAT.
00:39:07   I WAS IN THIS PROJECT MOSTLY AS AN INTELLECTUAL
00:39:10   EXERCISE, I THINK IT'S VERY FUN AND INTERESTING
00:39:12   >> SO THE NEXT QUESTION IS WHY WRITE A PYTHON
00:39:16   INTERPRETER IN PYTHON AND PARTICULARLY DOING IT
00:39:18   IN THIS RELATIVELY NAIVE WAY THAT WE WERE DOING
00:39:21   AS OPPOSED TO SOMETHING MORE SOPHISTICATED THAN
00:39:24   PYPY HAS TAKEN.
00:39:25   THE OBVIOUS DISADVANTAGE IS SPEED, THIS WON'T BE
00:39:28   A FUNCTIONAL INTERPRETER IN ANY INTERESTING WAY.
00:39:30   BUT SINCE THE GOAL IS TO UNDERSTAND THE REAL
00:39:34   CPYTHON INTERPRETER, WE DON'T CARE ABOUT SPEED OF
00:39:37   EXECUTION SO WE'RE RUNNING IN A HIGH LEVEL
00:39:39   LANGUAGE PYTHON THAT WE KNOW HOW TO READ AND
00:39:42   WRITE EFFECTIVELY SO WE ENDS UP WITH A PRODUCT
00:39:44   THAT IS EASILY UNDERSTANDABILITY.
00:39:45   THE OTHER SIGNIFICANT ADVANTAGE IS BECAUSE WE
00:39:47   IMPLEMENTED AN INTERPRETER IN PYTHON, WE DIDN'T
00:39:49   HAVE TO IMPLEMENT THE OBJECT SYSTEM.
00:39:51   WHERE YOU JUST SAY, OKAY, WHEN YOU GET TO AN
00:39:53   OBJECT, FALL BACK TO THE REAL OBJECT SYSTEM
00:39:55   ALREADY THERE IN PYTHON, SO THE INTERPRETER CAN
00:39:58   DO SORT OF JUST THE BYTECODE STAGE OF THINGS.
00:40:01   SO THIS IS AN EXAMPLE OF A TEST IN BYTE RUN.
00:40:06   THE IDEA HERE IS THAT WE RUN THE CODE UNDER THE
00:40:10   REAL PYTHON INTERPRETER AND THEN AGAIN UNDER
00:40:11   BYTERUN AND WE MAKE SURE THAT THE SAME THING
00:40:14   HAPPENS, SO WE CAPTURE STANDARD OUT, WE CAPTURE
00:40:16   EXCEPTION STATE, WE COMPARE WHAT GOT PRINTED AND
00:40:19   THE EXCEPTIONS AND SO ON.
00:40:20   COMPARE BYTE RUN TO A REFERENCE IMPLEMENTATION IS
00:40:22   A REALLY GREAT WAY TO DO QUICK DEBUGGING AND THIS
00:40:25   IS IN FACT THE SAME STRATEGY USED FOR MANY NEW
00:40:29   STRATEGIES, LIKE PISTON WHICH IS BEING USED IN
00:40:32   DROPBOX.
00:40:32   THIS ONE PASSES.
00:40:33   SO WE HAVE IMPLEMENTED FOUR LOOPS IN A WAY THAT
00:40:37   WORKS CORRECTLY.
00:40:37   IN FACT, AS OF ABOUT A YEAR AND A HALF AGO, MOST
00:40:40   THINGS WORKED CORRECTLY.
00:40:41   WE COULD DO LOOPS, WE COULD DO FUNCTION CALLS, WE
00:40:43   COULD DO EXCEPTION HANDLING, WE COULD DO CONTEXT
00:40:46   MANAGERS, DECORATORS, GENERATORS, SO ON.
00:40:48   WE HAD ONE PROBLEM THAT WAS STUMPING US.
00:40:50   IN PARTICULAR, WE GOT ERRORS ON NESTED
00:40:54   GENERATORS.
00:40:55   WE GOT A REALLY WEIRD ERROR, TOO.
00:40:58   WE WERE TRYING THIS CODES, WHICH SHOULD WORK AND
00:40:59   WE GET A TYPERROR THAT WE WERE TRYING TO MULTIPLY
00:41:02   TO NONE OBJECTS, WHICH IS OBVIOUSLY NOT GOING TO
00:41:05   SUCCEED AND ALSO NOT AT ALL CLEAR WHERE THAT'S
00:41:07   COMING FROM IN THIS CODES.
00:41:08   SO I'M GOING TO TALK A LITTLE BIT ABOUT THE
00:41:10   STRUCTURE OF BYTE RUN, WHICH MIRRORS THE
00:41:13   STRUCTURE OF THE REAL C-PYTHON INTERPRETER TO
00:41:16   UNCOVER THIS BUG AND IT'S AMAZING HOW WELL THIS
00:41:20   WORKED CONSIDERING HOW WRONG WE WERE ABOUT THE
00:41:22   STRUCTURE.
00:41:22   TO BE CLEAR, EVERYTHING I'M GOING TO DESCRIBE IS
00:41:24   THE CORRECT STRUCTURE AND THEN I'LL REVEAL WHAT
00:41:26   OUR MISUNDERSTANDING WAS TOWARDS THE END.
00:41:29   SO TO MAKE THIS CONCRETE, LET'S START WITH A VERY
00:41:32   MINIMAL INTERPRETER.
00:41:33   THIS INTERPRETER UNDERSTANDS USE THREE
00:41:35   INSTRUCTIONS.
00:41:36   HERE THEY ARE.
00:41:37   LOAD OF VALUE, ADD-TO VALUES AND PRINT THE
00:41:40   ANSWER.
00:41:40   ALL THE CODE IT CAN EXECUTE CONSISTS OF THESE
00:41:45   THREE INSTRUCTIONS IN DIFFERENT COMBINATIONS.
00:41:46   SINCE WE'RE NOT CONCERNED AT ALL TODAY ABOUT
00:41:53   LEXER OR PARSER OR COMPILER, WE DON'T CARE HOW
00:41:56   YOU GOT THE INSTRUCTIONS.
00:41:57   YOU COULD IMAGINE YOU PROPERTY SEVEN PLUS FIVE IN
00:41:59   A PYTHONEE SYNTAX AND SOME FRIENDLY COMPILER
00:42:03   GENERAL RAILS THE FOUR INSTRUCTIONS YOU SEE AT
00:42:04   THE BOTTOM.
00:42:05   OR IF YOU HAD A DIFFERENT COMPILER, YOU COULD
00:42:08   WRITE LISP SYNTAX AND GET THE INSTRUCTIONS AT THE
00:42:10   BOTTOM.
00:42:11   TODAY WE DON'T CARE.
00:42:12   THE INTERPRETER JUST CARES THERE IS A
00:42:13   WELL-INFORMED ARRANGE.
00:42:14   OF THESE THREE INSTRUCTIONS, AND THIS IS ONE THAT
00:42:17   IS WELL-FORMED.
00:42:19   SO NOW LET'S TALK ABOUT WHAT WE WANT THE
00:42:23   INSTRUCTIONS TO DO.
00:42:24   THE PYTHON INTERPRETER IS A STACK MACHINE SO IT'S
00:42:27   GOING TO MANIPULATE STACKS TO ADD TO NUMBERS.
00:42:28   IT WILL MANIPULATE STACKS TO DO EVERYTHING.
00:42:31   NOW, WHEN YOU HEAR ABOUT STACKS, YOU'RE PROBABLY
00:42:33   THINKING FIRST OF THE CALL STACK.
00:42:35   THAT IS NOT THE STACK THAT WE'RE TALKING ABOUT
00:42:37   RIGHT NOW, SO HOLD THAT THOUGHT.
00:42:38   WE WILL COME BACK TO THE CALL STACK IN A MINUTE
00:42:40   BUT FOR NOW, IGNORE IT COMPLETELY.
00:42:43   SO WE HAVE SOME STACK THAT CAN HOLD DATA.
00:42:45   AND WHEN THE INTERPRETER BEGINS, THE STACK IS
00:42:48   EMPTY.
00:42:49   IT EXECUTES THE FIRST INSTRUCTION, WHICH PUSHES
00:42:52   THE FIRST NUMBER ON TO THE STACK, THAT'S SEVEN.
00:42:54   THEN IT PUSHES THE SECOND NUMBER ON TO THE STACK,
00:42:56   THAT'S FIVE.
00:42:57   THEN IT ADDS THEM TOGETHER, PUSHES THE RESULT ON
00:43:00   TO THE STACK, THAT'S 12, AND THEN WHEN PRINT
00:43:03   ANSWER, WE'LL POP THE RESULT OFF THE STACK AND
00:43:05   PRINT IT.
00:43:05   SO THE MANIPULATION HERE IS LOAD VALUE IS
00:43:10   RESPONSIBLE FOR GETTING VALUES ON TO THE STACK.
00:43:12   ADD-20 VALUES IS RESPONSIBLE FOR POPPING THEM OFF
00:43:14   AND ADDING AND PRINT ANSWER CONSUMES WHATEVER IS
00:43:17   ON THE STACK AND PRINTS IT.
00:43:19   YOU MAY BE WONDERING AT THIS POINT WHY
00:43:21   INSTRUCTIONS OTHER THAN ADD-TO VALUES ARE
00:43:23   NECESSARY AT ALL.
00:43:24   AND ADMITTEDLY, FOR THE CASE WHERE WE JUST ADD
00:43:26   TWO VALUES, IT IS SLIGHTLY CONTRIVED.
00:43:29   BUT THIS CREATES A STRONG FRAMEWORK THAT WE CAN
00:43:31   USE TO ADD A LOT OF COMPLEXITY SO JUST WITH THE
00:43:36   INTERPRETER INSTRUCTIONS WE'VE DESIGNED SO FAR,
00:43:38   WE CAN ADD THREE VALUES, OR ANY NUMBER OF VALUES.
00:43:40   IF WE HAVE THIS WELL-INFORMED SET OF
00:43:42   INSTRUCTIONS.
00:43:42   AND THE STACK PROVIDES A REALLY CLEAN WAY TO
00:43:45   TRACK THE INTERPRETER STATE AND IT WILL SUPPORT A
00:43:47   LOT MORE COMPLEXITY AS WE GO ON.
00:43:49   SO THE NEXT QUESTION IS, WHERE DO THESE NUMBERS
00:43:54   COME FROM?
00:43:55   IN OUR EXAMPLE OF THE INSTRUCTIONS, IT JUST SAYS
00:43:58   LOAD VALUE BUT DOESN'T SAY WHAT VALUE TO LOAD.
00:44:00   SO WE HAVE TO TELL THE INTERPRETER THAT.
00:44:03   LET'S EXPAND OUR INSTRUCTIONS A LITTLE BIT.
00:44:04   INSTEAD OF HAVING JUST A LIST OF INSTRUCTIONS,
00:44:06   WE'LL HAVE THIS DICTIONARY, CALL WHAT TO EXECUTE.
00:44:09   THERE ARE TWO PIECES, THE INSTRUCTIONS THEMSELVES
00:44:12   AND THEN THE NUMBERS WHICH WE'LL ALSO NEED.
00:44:14   AND WE ALSO NEED TO LINK EACH NUMBER TO THE
00:44:16   CORRECT INSTRUCTION.
00:44:17   SO LOAD VALUE THE FIRST TIME SHOULD LOAD THE
00:44:20   FIRST NUMBER AND THEN THE SECOND TIME WILL LOAD
00:44:22   THE SECOND NUMBER.
00:44:23   IN PYTHON WHAT I'M CALLING INSTRUCTIONS HERE IS
00:44:26   THE BYTECODE ITSELF AND THE WHOLE WHAT TO EXECUTE
00:44:29   OBJECT IS ANALOGOUS TO THE CODES OBJECTS.
00:44:32   SO WHY NOT JUST PUT THE NUMBERS DIRECTLY INTO THE
00:44:34   INSTRUCTIONS?
00:44:35   IMAGINE IF WE WERE ADDING TOGETHER STRINGS
00:44:39   INSTEAD OF NUMBERS.
00:44:39   WE MIGHT NOT KNOW HOW LONG THOSE STRINGS ARE, AND
00:44:42   WE MIGHT NOT KNOW -- WE MIGHT WANT TO PACK THE
00:44:45   INSTRUCTIONS IN A WAY WHERE THE LENGTH IS ALREADY
00:44:47   PREDETERMINED.
00:44:48   THE OTHER ADVANTAGE TO THIS DESIGN IS IF WE'RE
00:44:50   ADDING 7 PLUS 7, INSTEAD OF 7 PLUS 5.
00:44:53   WE ALL NEED ONE COPY OF THE NUMBER 7 IN THE CODE
00:44:56   OBJECT.
00:44:56   THIS COMES IN HANDY IN A LOT OF PLACES.
00:44:58   OKAY, SO LET'S START WRITING OUR INTERPRETER
00:45:03   ITSELF.
00:45:03   WE KNOW THAT OUR INTERPRETER NEEDS A STACK.
00:45:06   RIGHT NOW THAT'S ALMOST THE ONLY THING THAT WE
00:45:08   NEED IN OUR INTERPRETER.
00:45:09   AND WE NEED TO IMPLEMENTS THE INSTRUCTIONS SO THE
00:45:11   INTERPRETER KNOWS WHAT TO DO WHEN IT HITS THAT
00:45:13   INSTRUCTION.
00:45:13   SO HERE WE HAVE THREE FUNCTIONS THAT ARE NAMED
00:45:16   ANALOGOUS TO THE INSTRUCTIONS, VALUE LOADER FOR
00:45:19   LOAD VALUE, ANSWER PRINTER FOR PRINT ANSWER AND
00:45:22   TWO VALUE ADDER FOR ADDING INSTRUCTIONS.
00:45:24   FOR ADDING THE VALUES.
00:45:27   YOU'LL NOTICE THAT EACH OF THESE INTERACT WITH A
00:45:29   STACK IN THE WAY WE JUST OUTLINED, THE VALUE
00:45:31   LOADER PUSHES SOMETHING ON TO THE STACK AND TWO
00:45:35   LOADER POPS SOMETHING OFF AND SO OPEN.
00:45:37   SO WE NEED ONE MORE PIECE, A WAY TO MAKE THE
00:45:39   THING GO.
00:45:39   HERE WE HAVE A METHOD CALLED RUN CODE WHICH TAKES
00:45:44   THAT WHAT TO EXECUTE OBJECT AND DOES WHAT IT SAYS
00:45:48   IN IT.
00:45:48   SO THE FIRST THING WE DO IS UNPACK INTO
00:45:50   INSTRUCTIONS AND NUMBERS, JUST FOR CLARITY AND
00:45:53   READABILITY.
00:45:53   THEN WE LOOP OVER THE INSTRUCTION.
00:45:56   WE PROCESS THE ARGUMENT TO THAT INSTRUCTION, IF
00:45:58   THERE IS ANY, WHICH THERE MIGHT NOT BE.
00:46:00   AND THEN WE CALL THE CORRESPONDING METHOD ON THE
00:46:02   INTERPRETER OBJECT.
00:46:03   AND WE JUST DO THAT WITH AN "F" STATEMENT.
00:46:06   WE HAVE A METHOD DEFINED FOR EACH INSTRUCTION.
00:46:08   WE SAY IN WE'RE LOOKING AT LOADS VALUE, CALL THE
00:46:11   VALUE LOADER WITH THE CORRECT ARGUMENT.
00:46:13   SO THIS INTERPRETER IS QUITE LIMITED, BUT THIS
00:46:15   PROCESS IS ALMOST EXACTLY HOW THE REAL PYTHON
00:46:18   INTERPRETER ADDS TWO NUMBERS.
00:46:20   AND THERE ARE A COUPLE OF THINGS WE CAN NOTICE
00:46:22   FROM THE SMALL EXAM WILL.
00:46:23   THE FIRST ONE IS THAT SOME INSTRUCTIONS DO NEED
00:46:26   ARGUMENTS, AND REAL PYTHON BYTECODE IS ABOUT HALF
00:46:28   THE INSTRUCTIONS THAT NEED ARGUMENTS AND HALF DO
00:46:30   NOT.
00:46:32   THE SECOND THING TO NOTICE IS THE ARGUMENTS TO
00:46:34   THE INSTRUCTION ARE PACKED IN WITH A BYTECODE
00:46:36   WHERE WE HAD LOAD VALUE ZERO, THAT'S BASICALLY
00:46:40   THE WAY THE BYTECODE IS STRUCTURED, AS WELL.
00:46:42   AND WE CAN NOTICE THAT THE ARGUMENTS TO THE
00:46:45   INSTRUCTIONS ARE DIFFERENT THAN THE ARGUMENTS TO
00:46:47   THE FUNCTION BEING CALLED.
00:46:50   SO FOR LOAD VALUE, WE NEED TO GO LOOK UP WHAT THE
00:46:53   CORRECT ARGUMENT IS, AND THEN PASS THAT NUMBER,
00:46:57   NOT THE INDEX INTO THE NUMBERS LIST THAT WE SAW
00:47:00   EARLIER, PASS THE ACTUAL NUMBER AT THAT POINT
00:47:02   INTO THE VALUE LOADER FUNCTION.
00:47:04   AND FINALLY, NOTICE THAT THE ADD-TO VALUES DID
00:47:08   NOT REQUIRE ANY ARGUMENTS SO THE INSTRUCTION
00:47:10   ITSELF JUST SAYS, TAKE WHATEVER IS ON THE TOP OF
00:47:12   THE STACK AND ADD IT TOGETHER.
00:47:14   THE TOP TWO THINGS ON THE STACK, ADD THAT
00:47:16   TOGETHER.
00:47:17   THIS IS THE DEFINING FEATURE OF A STACK-BASED
00:47:19   INTERPRETER, IS THAT WE WILL BE MANIPULATING THE
00:47:22   STACK AND ANY TIME WE'RE DOING A CALCULATION,
00:47:24   BASICALLY, THE VALUES HAVE BEEN ON THE STACK AT
00:47:26   SOME POINT.
00:47:27   SO LET'S NOW GRADUATE TO REAL PYTHON BYTECODE.
00:47:32   AS I MENTIONED, THESE INSTRUCTIONS SETS IN PYTHON
00:47:35   ARE CALLED BYTECODE AND THE OVERALL OBJECT IS
00:47:37   CALLED THE CODES OBJECT.
00:47:38   ONE GREAT THING ABOUT PYTHON IS IT EXPOSES A TON
00:47:41   OF INTERNAL IMPLEMENTATION DETAILS IN THE
00:47:43   WRAP-OUT SO IT'S EASY TO POKE AROUND AND EXPLORE
00:47:46   AND SEE WHAT'S GOING ON, SO IT WON'T BE TOO HARD
00:47:48   FOR US TO DO.
00:47:49   SO HERE'S A FUNCTION THAT WE CAN USE TO EXPLORE.
00:47:51   IT'S SIMPLE, CALLED MOD, TAKES TWO ARGUMENTS,
00:47:54   CALCULATES THE MODULUS OF ONE AGAINST THE OTHER,
00:47:56   AND THEN RETURNS THE RESULTS.
00:47:57   SO WE CAN GET A HANDLE ON THE FUNCTION OBJECT,
00:48:02   WHICH IS MOD.
00:48:03   ON THE MOD FUNCTIONS CODE OBJECT, WHICH IS
00:48:06   FUNCTION CODES, AND THEN WE CAN GET A HANDLE ON
00:48:08   THE BYTECODE WHICH IS STORED UNDER CODE CODE.
00:48:11   BYTECODE IS A SUBSET, NOT THE SAME THING AS A
00:48:13   CODE OBJECT.
00:48:14   SO LET'S LOOK AT THIS.
00:48:15   SO JUST PRINTING THIS DOESN'T FEEL VERY
00:48:20   ENLIGHTENING, BUT THERE IS IN FACT ONE THING THAT
00:48:22   WE CAN LEARN JUST FROM DOING THIS AND THAT IS
00:48:24   THAT BYTECODE IS A SERIES OF BYTES.
00:48:26   A SERIES OF NUMBERS BETWEEN 0 AND 255 AND IT
00:48:30   LOOKS A LITTLE FUNNY IN THE TERMINAL BECAUSE SOME
00:48:32   OF THEM ARE PRINTABLE AND SOME ARE NOT BUT WE
00:48:34   ALREADY KNOW SOMETHING ABOUT BYTES JUST FROM
00:48:35   THAT.
00:48:35   WE CAN MAKE THIS SLIGHTLY MORE INTELLIGIBLE BY
00:48:39   CONVERTING TO ORDINALS AND THIS REALLY SHOWS THIS
00:48:42   IS NUMBERS BETWEEN 0 AND 255 BUT STILL NOT
00:48:45   EXACTLY READABLE.
00:48:46   SO LUCKILY FOR US, THERE IS A TOOL WE CAN USE IN
00:48:49   THE STANDARD LIBRARY TO MAKE THIS INTELLIGIBLE.
00:48:51   YOU CAN JUST DIS, THE BYTECODE DISASSEMBLER AND
00:48:55   IN GENERAL, YOU WANT A DISASSEMBLER WHEN YOU HAVE
00:48:58   SOME SET OF INSTRUCTIONS INTENDED FOR A MACHINE
00:49:00   AND YOU WANT TO MAKE THEM READABLE FOR HUMANS.
00:49:02   SO ASSEMBLY LANGUAGE IS A CASE WHERE YOU WOULD
00:49:04   USE A DISASSEMBLER VERY OFTEN.
00:49:08   I CAN'T THINK OF A REASON WHY YOU WOULD WANT TO
00:49:10   USE DIS IN PRODUCTION, IN FACT, DIS DOESN'T EVEN
00:49:16   RETURN THIS OUTPUT, JUST PRINTS IT.
00:49:19   THIS IS INTENDED FOR OUR EYES AND NOT FOR MACHINE
00:49:21   CONSUMPTION.
00:49:21   SO WE RUN OUR FUNCTION THROUGH THE DISASSEMBLER,
00:49:24   WE GET THIS OUTPUT.
00:49:25   I'VE GOT THIS ANNOTATED SLIGHTLY JUST BELOW THE
00:49:28   CALL.
00:49:28   THE LEFT-HAND COLUMN IS THE LINE NUMBER IN THE
00:49:31   ORIGINAL SOURCE CODE SO OUR CODE WAS TWO LINES
00:49:33   AND THIS IS LINE TWO AND THREE FROM THE REPL.
00:49:36   THE SECOND COLUMN IS THE INDEX INTO THE BYTECODES
00:49:40   SO THIS IS TELLING US AT POSITION 0 IS LOAD FAST,
00:49:43   AT POSITION 7 IS STORE FAST AND SO ON.
00:49:44   THE THIRD COLUMN IS THE INSTRUCTION -- IS THE
00:49:49   BYTE MAPS TO A HUMAN-READABLE INSTRUCTION NAME,
00:49:51   SO 124 BECOMES LOAD FAST AND 22 BECOMES BINARY
00:49:55   MOD WHICH IS MUCH FRIENDLIER FOR US TO READ AS
00:49:59   HUMANS.
00:50:00   THE FOURTH COLUMN IS THE ARGUMENT TO THE
00:50:01   INSTRUCTION AND NOTICE AGAIN, HERE, THAT BINARY
00:50:03   MODULE LOAD DOES NOT TAKE ANY ARGUMENTS.
00:50:06   THE FIRST TIME I SAW THIS I WAS REALLY SURPRISED
00:50:08   AND CONFUSED BECAUSE I WOULD ASSUME THAT A BINARY
00:50:11   FUNCTION IS ONE THAT TAKES TWO ARGUMENTS, THAT
00:50:13   SEEMS DEFINITIONALLY TRUE, BUT IN BYTECODE, THOSE
00:50:16   ARGUMENTS WILL ALREADY BE ON THE STACK SO THE
00:50:18   INSTRUCTION ITSELF DOES NOT REQUIRE ARGUMENTS.
00:50:20   THE FIFTH COLUMN IS A HINT FROM ELSEWHERE ON THE
00:50:24   CODE OBJECT ABOUT WHAT THAT ARGUMENT MEANS, SO WE
00:50:26   CAN TELL THAT THE FIRST TIME YOU DO LOAD FAST,
00:50:28   YOU'RE GETTING A AND THE SECOND TIME YOU GET B
00:50:30   AND SO ON SO WHAT HAPPENS IN THE INTERPRETER WHEN
00:50:35   WE CALL THIS FUNCTION.
00:50:37   IT'S JUST LIKE OUR MINIATURE EXAMPLE BEFORE.
00:50:39   THE PYTHON INTERPRETER PUSHES THE VALUE OF A ON
00:50:41   TO THE STACK, THAT'S 7.
00:50:43   PUSHES THE VALUE OF B ON THE STACK, THAT'S FIVE.
00:50:45   THEN IT CALCULATES BINARY MOD OF ONE AGAINST THE
00:50:50   OTHER, GETS TWO AND PUSHES THAT ON TO THE STACK
00:50:52   AND THEN THE ANSWER GETS STORED BY THE STORE-FAST
00:50:55   INSTRUCTION WHICH MEANS THAT THE NAME ANSWER IN
00:50:57   OUR EXAMPLE WILL BE BOUND TO THE NUMBER TWO.
00:50:59   SO NOW WHAT?
00:51:04   WE COMPLETED THIS FIRST LINE OF CODE HERE, THE
00:51:07   ANSWER IS A MOD B AND DOWN TO LINE THREE.
00:51:09   WE KNOW WHAT LOAD FAST DOES, HERE IN POSITION 10,
00:51:12   SECOND LINE UP FROM THE BOTTOM.
00:51:13   THAT PUSHES THE VALUE ON TO STACK.
00:51:15   AND THEN THERE'S RETURN VALUE, WHICH PRESUMABLY
00:51:18   IS RELATED TO THIS RETURN STATEMENT BUT IN OUR
00:51:20   CURRENT MENTAL MODEL, THE INTERPRETER, THERE'S
00:51:22   NOWHERE TO RETURN TO.
00:51:23   SO AT THIS MOMENT, I WOULD LIKE YOU TO REMEMBER
00:51:26   THE CALL STACK THAT I ASKED YOU TO FORGET EARLIER
00:51:29   AND ZOOM OUT A LEVEL.
00:51:30   THE CALL STACK NOW IS MODEL TOP TO BOTTOM AND THE
00:51:36   DATA STACK, WHICH IS THE STACK WE'VE BEEN LOOKING
00:51:37   AT SO FAR IS GOING LEFT TO RIGHT.
00:51:41   THE STACK THAT THE INTERPRETER IS USING FOR
00:51:43   CALCULATIONS, I DON'T KNOW IF DATA STACK IS
00:51:45   COMMON TERMINOLOGY BUT CERTAINLY IT IS A STACK
00:51:47   THAT CONTAINS DATA SO THAT'S THE TERM I WILL BE
00:51:50   USING TODAY.
00:51:50   MEANWHILE, THE CALL STACK IS MADE UP OF FRAMES.
00:51:53   YOU HAVE ONE FRAME ON THE CALL STACK FOR EACH
00:51:56   LEVEL OF YOUR CODE, AND THIS IS SOMETHING THAT
00:51:58   YOU'RE PROBABLY VISCERALLY REALLY FAMILIAR WITH
00:52:00   BECAUSE YOU SEE IT ALL THE TIME IN TRACE-BACKS,
00:52:03   SO YOUR TRACE-BACK SAYS MOST RECENT CALL ASKED
00:52:05   AND THEN HAS SEVERAL LEVELS.
00:52:07   EACH ONE OF THOSE LEVELS CORRESPONDS TO A FRAME.
00:52:09   THE ONE FRAME FOR FUNCTION CALL, ONE FRAME FOR A
00:52:13   MODULE AND SO ON.
00:52:14   EACH FRAME HAS ITS OWN DATA STACK AND THEN ALSO
00:52:16   HAS ANOTHER STACK OF BLOCKS WHICH I WON'T TALK
00:52:18   ABOUT TODAY.
00:52:19   SO THIS IS WHAT THE INTERPRETER LOOKS LIKE IN THE
00:52:21   MIDDLE OF EXECUTING MOD, WHICH IS RIGHT BEFORE
00:52:23   THE BINARY MODULAR HAPPENS.
00:52:25   THERE'S TWO FRAMES ON THE STACK, ONE FOR THE MAIN
00:52:28   SCOPE AND ONE FOR OUR FUNCTION MOD.
00:52:32   AND WHEN RETURN VALUE IS EXECUTED, WHAT THAT'S
00:52:35   DOING IS IT TELLS THE INTERPRETER TO PASS A VALUE
00:52:38   FROM ONE FRAME TO ANOTHER.
00:52:39   NOW, RETURN VALUE IS ONE OF ONLY TWO WAYS TO
00:52:42   ACCOMPLISH THAT.
00:52:43   THE OTHER WAY IS WITH YIELD.
00:52:44   I WANT TO EMPHASIZE THAT THERE'S ONE FRAME ON THE
00:52:49   STACK FOR EACH FUNCTION CALL, NOT FOR EACH
00:52:51   FUNCTION OBJECT OR SOMETHING ELSE LIKE THAT.
00:52:53   AGAIN, PICTURE YOURSELF MAYBE HITTING THE
00:52:56   RECURSION LIMIT WHERE YOU GET A TRACE-BACK THAT
00:52:58   IS 500 FRAMES LONG, EVEN THOUGH THE SAME
00:53:01   FUNCTION.
00:53:02   SO WE HAD A RECURSIVE CALL, LIKE THIS FACTORIAL
00:53:06   CALCULATION AND IT WILL START OUT LOOKING LIKE
00:53:08   THIS.
00:53:08   I'M NOT SHOWING THE BYTECODES HERE BUT AT THIS
00:53:10   POINT WE'RE IN THE MIDDLE OF THE CALL TO FACTOR
00:53:12   OF 3 AND ABOUT TO CALCULATE THREE MINUS ONE, SO
00:53:14   WE DO THAT, GET THE ANSWER TWO.
00:53:17   AT THIS POINT, WE HAVE THE FUNCTION OBJECT
00:53:19   FACTORIAL ON THE PREVIOUS FRAME'S DATA STACK.
00:53:23   I KNOW THIS IS A LITTLE BIT WEIRD.
00:53:25   CALL A FUNCTION CONSUMES A FUNCTION OBJECT OFF OF
00:53:28   THE STACK IN THIS WAY AND WHEN IT'S ACTUALLY
00:53:31   CALLED, IT CREATES A NEW FRAME FOR THE DEEPER
00:53:34   RECURSIVE CALL.
00:53:35   SO THEN THE INTERPRETER IS LOADING UP N, WHICH IS
00:53:39   NOW TWO AND PUSHING THAT ON TO THE STACK.
00:53:41   NOTICE, ALSO, THAT THERE IS A VALUE LEFT ON THE
00:53:43   DATA STACK IN THE PREVIOUS FRAME.
00:53:45   SO THAT'S THE N IN THE RESULT THAT IS WAITING FOR
00:53:49   FACT OF N MINUS ONE TO FINISH EXECUTING SO WE CAN
00:53:52   COME BACK TO IT.
00:53:53   WE'LL NEED IT THERE TO MULTIPLY WHEN THE CALL
00:53:54   STACK IS UNWINDING.
00:53:56   SKIPPING AHEAD A LITTLE BIT, WE'LL HIT THE BASE
00:53:59   CASE AND WE START UNWINDING SO THAT ONE GETS
00:54:03   RETURNED FROM THE TOP FRAME DOWN TO THE NEXT ONE
00:54:04   DOWN AND MULTIPLIED, MULTIPLY IT AGAIN, GET SIX
00:54:07   AND PASS THAT BACK TO THE CALLING FRAME.
00:54:08   SO THESE ARE THE BASIC PIECES THAT WE NEED TO
00:54:15   IMPLEMENT A PYTHON INTERPRETER, OUR OWN VIRTUAL
00:54:18   MACHINE.
00:54:18   WE NEED SOME WAY TO CREATE FRAMES, WE NEED TO
00:54:20   PROVIDE A DATA STACK FOR THAT FRAME AND ALSO
00:54:22   BLOCK STACK, AND WE NEED TO DEFINE A WAY TO RUN
00:54:25   THE FRAMES, AND TO RUN THE FRAMES, WE NEED TO
00:54:27   DEFINE THE CORRECT OPERATIONS FOR EACH
00:54:30   INSTRUCTION THAT WE MAY HIT, JUST AS WE DID FOR
00:54:32   OUR TOY INTERPRETER AT THE BEGINNING.
00:54:34   THE ONLY DIFFERENCE IS NOW THERE ARE A LOT MORE
00:54:36   INSTRUCTIONS.
00:54:37   I'M OMITSING A COUPLE OF OTHER NECESSARY
00:54:40   INGREDIENTS, LIKE TRACKING THE EXCEPTION STATE
00:54:43   AND TRACKING NAME SPACES AND SCOPES AND THAT SORT
00:54:45   OF THING.
00:54:45   IF THERE'S TIME, I CAN TALK ABOUT THAT IN Q AND
00:54:47   A.
00:54:48   SO WE HAVE A LOT MORE INSTRUCTIONS TO DEFINE FOR
00:54:54   A REAL PYTHON INTERPRETER AND OF COURSE THE
00:54:56   COMPLEXITY OF EACH INSTRUCTION IS ALSO GREATER.
00:54:58   SO WE NEED TO WRITE THE OPERATIONS THAT THE
00:55:00   INTERPRETER SHOULD PERFORM FOR EACH OF THESE
00:55:02   INSTRUCTIONS FOR THIS TO BE ABLE TO EXECUTE.
00:55:04   SO WHAT SHOULD THOSE BE?
00:55:05   WELL, THE GOOD NEWS IS WE'RE NOT STARTING FROM
00:55:08   SCRATCH.
00:55:08   WE HAVE CPYTHON, THE REFERENCE IMPLEMENTATION AND
00:55:11   WE CAN LOOK AT HOW IT IS IMPLEMENTED IN THE
00:55:13   REFERENCE IMPLEMENTATION, IN THE ACTUAL C-PYTHON
00:55:17   INTERPRETER AND GET GUIDANCE.
00:55:19   THE MAIN LOOP IS IN THE C VAL.C.
00:55:25   I SAW ON TWITTER THE WAY TO GETS INTO THE CPYTHON
00:55:29   CODE BASE IS STARTED ON CCODE.C AND START FROM
00:55:33   THERE, SO TODAY WE'LL TWO TWO OF THOSE STEPS AND
00:55:36   HOPEFULLY THREE.
00:55:37   IN OUR TOY INTERPRETER...
00:55:38   CAN YOU SEE THIS OKAY IN THE BACK?
00:55:41   [ Laughter ]
00:55:41   IN OUR TOY INTERPRETER, WE HAD A BIG IF STATEMENT
00:55:46   OR WHAT WOULD HAVE BEEN A BIG IF STATEMENT, IF
00:55:48   THE INSTRUCTION IS THIS, DO THIS.
00:55:49   IF THE INSTRUCTION IS THIS, DO THIS.
00:55:52   CPYTHON IS IMPLEMENT HAD IN THE SAME WAY AND
00:55:56   THE...
00:55:57   THIS IS IT.
00:55:59   I LOVE THIS BECAUSE IT FEELS LIKE SUCH AN OBVIOUS
00:56:03   IMPLEMENTATION IN SOME WAYS, LIKE YOU CAN IMAGINE
00:56:05   SITTING IN THE NETHERLANDS IN 1989 AND SAYING,
00:56:08   OKAY, WE HAVE THESE INSTRUCTIONS AND EACH OF THEM
00:56:11   MAPS TO A SET OF THINGS THAT NEEDS TO BE DONE AND
00:56:14   WE'RE WRITING C, HOW SHOULD WE DO THAT?
00:56:16   HOW ABOUT A GIANT SWITCH STATEMENT AND THAT'S
00:56:18   EXACTLY HOW IT WORKS.
00:56:20   IN FACT, 1500 LINE SWITCH STATEMENT IS SO
00:56:28   LARGE -- SORRY -- 1500 SWITCH STATEMENT IS SO
00:56:34   LARGE IT BREAKS SOME C COMPILERS AND THERE IS A
00:56:37   MACRO YOU CAN TURN ON IF IT BREAKS IT, SO YOU CAN
00:56:41   TURN IT INTO TWO SWITCH STATEMENTS THAT ARE ONLY
00:56:42   750 LINES EACH.
00:56:43   [ Laughter ]
00:56:45   SO THE INTERPRETER IS BASICALLY TAKING EACH
00:56:47   INSTRUCTION AND THEN WHYSING A SWITCH STATEMENT
00:56:48   TO LOOK UP THE CORRECT THINGS TO DO AND THEN
00:56:50   DOING THOSE THINGS AND MOVING TO THE NEXT
00:56:52   INSTRUCTION.
00:56:52   IN PYTHON 3 AND UP, THIS IS NO LONGER LITERALLY A
00:56:56   SWITCH, IT IS COMPUTED GO-TOES INSTEAD BUT THE
00:56:59   IDEA REMAINS QUITE SIMILAR.
00:57:00   OKAY, SO THESE ARE IN THE INSTRUCTIONS THAT WE
00:57:04   NEED TO KNOW HOW TO IMPLEMENT FOR OUR PYTHON
00:57:07   INTERPRETER AND LET'S LOOK AT THAT
00:57:08   IMPLEMENTATION.
00:57:10   HERE'S LOAD FAST, THE FIRST INSTRUCTION TO FIND.
00:57:12   THE MOST COMMON INSTRUCTION IN MOOSE PYTHON CODE
00:57:15   BASES AND THE C IS PRETTY READABLE HERE.
00:57:18   YOU CAN SEE WE RUN THE MACRO GET LOCAL AND STORE
00:57:20   THE VALUE, AND IF ANYTHING GOES WRONG, THEN WE
00:57:24   THROW AN UNBOUND LOCAL ERROR -- HANDS-UP IF
00:57:28   YOU'VE THROWN AN UNBOUND LOCAL ERROR BEFORE.
00:57:30   SO THIS HAPPENS WHEN YOU TRY TO LOAD A LOCAL
00:57:32   VARIABLE AND SOMETHING HAPPENS.
00:57:33   BUT IN THE MEANTIME, IF SOMETHING HAS NOT FAILED,
00:57:36   THEN WE PUSH THE RESULT ON TO THE STACK AND MOVE
00:57:38   ON TO THE NEXT CODE.
00:57:40   SO HERE IS THE CODE THAT RAISES THAT ERROR, THE
00:57:42   ONLY PLACE IN THE CPYTHON CODES BASE WHERE THAT'S
00:57:46   RAISED, I THINK, THAT'S PRETTY COOL WE CAN FIND
00:57:48   THAT RIGHT THERE.
00:57:49   AND HERE'S BINARY MODULAR, SO WE POP TWO THINGS
00:57:53   OFF THE STACK, IN PRACTICE, IT'S NOT QUITE THAT
00:57:54   BUT CLOSE ENOUGH.
00:57:55   WE DO SOME STUFF, WE CALCULATE THE REMAINDER AND
00:57:58   THEN WE PUSH THE RESULT BACK ON TO THE STACK.
00:58:00   COOL.
00:58:00   SO I'VE DESCRIBED THE STRUCTURE OF CPYTHON AND BY
00:58:07   BY EXTENSION, THE EXTENSION OF BYTE RUN, BUT UP
00:58:09   UNTIL ONE YEAR AGO, WE HAD ONE THING REALLY WRONG
00:58:12   AND IN PARTICULAR WE ONLY HAD ONE DATA STACK FOR
00:58:14   THE ENTIRE INTERPRETER INSTEAD OF ONE DATA STACK
00:58:17   PER FRAME.
00:58:17   WHAT'S INTERESTING IS HOW MUCH IS POSSIBLE
00:58:20   DESPITE MAKING THAT ERROR.
00:58:22   IN THIS CASE, THE NESTING THE GENERATORS, PAUSES
00:58:25   AND RESUMPTION THE FRAME OF G SEVERAL TIMES, AND
00:58:28   IT HAS TO DO SOME WORK IN-BETWEEN PAUSING AND
00:58:31   RESUMING.
00:58:32   SO THAT WORK IS ALSO MANIPULATING THE STACK THAT
00:58:34   SHOULD BELONG TO THE SEPARATE FRAME BUT INSTEAD
00:58:36   WAS IN THE WRONG PLACE.
00:58:37   AND IT IS NONE APPEARED AND WE TRIED TO MULTIPLY
00:58:43   IT BECAUSE RESUMING THE GENERATOR PUSHES NONE ON
00:58:46   TO THE STACK AND THE GENERATOR FRAME KNOWS HOW TO
00:58:48   CONSUME THAT APPROPRIATELY.
00:58:49   UNDERSTANDING THE CORRECT STRUCTURE HERE THAT IN
00:58:51   FACT THERE IS ONE DATA STACK FOR EVERY FRAME,
00:58:53   GIVES US THE ABILITIES TO PAUSE AND RESUME
00:58:55   FRAMES, WHICH IS WHAT WE NEED FOR GENERATORS AND
00:58:57   BY CONTRAST, IF THE PYTHON INTERPRETER WERE
00:59:00   IMPLEMENTED WITH ONLY ONE DATA STACK, THE ONLY
00:59:02   FEATURE THAT YOU WOULD LOSE IS GENERATORS.
00:59:04   SO IN THE LAST COME OF MINUTE HERE BEFORE Q AND
00:59:10   A, I WANT TO TALK A LITTLE BIT ABOUT HOW PYTHON
00:59:12   IS DYNAMIC.
00:59:13   AND ONE THING YOU HEAR THIS A LOT, LIKE, OH,
00:59:15   PYTHON IS DYNAMIC LANGUAGE, HAS DYNAMIC TYPING
00:59:19   AND IF YOU LISTEN TO PETER'S KEYNOTE, I GUESS THE
00:59:22   CLOSING TALK TOMORROW, YOU'LL HEAR ABOUT THE
00:59:25   FUTURE OF TYPES AND PYTHON.
00:59:27   I THINK A LOT OF FOLKS, PARTICULARLY THOSE OF US
00:59:29   ON PYTHON 2, ARE NOT SUPER FAMILIAR WITH WHAT'S
00:59:31   GOING ON HERE.
00:59:32   BUT WITH THE CONTEXT THAT'S JUST -- WE'VE JUST
00:59:35   BUILT UP ABOUT THE INTERPRETER, WE CAN TAKE A
00:59:36   LOOK AT ONE OF THE PROBLEMS THAT THIS IS TRYING
00:59:38   TO SOLVE.
00:59:38   SO ONE THING IN THE DYNAMIC MEANS IS THAT A LOT
00:59:43   IS HAPPENING AT RUN TIME.
00:59:44   AND ANOTHER WAY OF PUTTING THIS IS THAT NOT A LOT
00:59:46   IS HAPPENING AT COMPILE TIME.
00:59:48   AND THE INTERPRETER HAS A LOT OF WORK TO DO.
00:59:50   SO LET'S LOOK AT ACTUALLY CALLING UP THIS
00:59:52   FUNCTION MOD.
00:59:53   IT'S PRETTY OBVIOUS WHAT'S GOING ON HERE, WE CALL
00:59:55   MOD ON 15 AND 4 AND WE GET THE RESULT 3.
00:59:57   ANY GUESSES FOR WHAT WILL HAPPEN WHEN WE CALL THE
01:00:01   FUNCTION LIKE THIS?
01:00:05   [ PYTHON.
01:00:08   >> RIGHT, GET PYCON RETURNED, SO THIS MIGHT LOOK
01:00:11   WEIRD TO YOU BUT YOU'VE ALMOST CERTAINLY SEEN IT
01:00:15   BEFORE, YOU'VE SEEN IT AS STRING FORM MATING.
01:00:17   DOING THAT WITH A MOD LIKE THIS IS INVOKING
01:00:20   BINARY MOD ON THE ARGUMENTS.
01:00:22   SO THIS IS THE BYTECODE FOR THIS FUNCTION AND
01:00:25   THIS IS ALWAYS THE BYTECODE FOR THIS FUNCTION.
01:00:27   THE ADVANTAGE IS THAT WE'VE BUILT THIS ONE AND
01:00:29   REUSE IT AGAIN AND AGAIN, SO NO MATTER WHAT
01:00:31   ARGUMENTS ARE PASSED TO IT, WE'RE GOING TO CALL
01:00:34   BINARY MODULO ON WHATEVER THE TOP TWO ITEMS ON
01:00:36   THE STACK ARE AND THEY MAY BE TWO INTEGERS OR
01:00:39   THEY MAY BE A 2PULL AND A STRING OR TWO STRINGS,
01:00:44   THE COMPILER DOESN'T KNOW AND DOESN'T CARE.
01:00:47   IT'S UP TO THE INTERPRETER TO DO THE RIGHT THING.
01:00:49   SO I WENT BY THIS KIND OF FAST, ON PURPOSE,
01:00:53   EARLIER.
01:00:54   BUT ONE THING THAT YOU NOTICE HERE IS THAT THERE
01:00:56   IS A F STATEMENT, SAYING IF V IS A STRING, THEN
01:01:00   DISPATCH TO STRING FORMATTING.
01:01:02   THIS KIND OF LOOKS LIKE IT'S TYPE-CHECKING, IT'S
01:01:05   WORSE THAN THAT.
01:01:06   THE TYPE-CHECKING HERE IS OPTIMIZATION.
01:01:10   BECAUSE OF COURSE WE COULD PASS ANYTHING TO OUR
01:01:13   MODULAR FUNCTIONING, DOESN'T HAVE TO BE EITHER A
01:01:16   STRING OR A NUMBER, AND SO THIS PY NUMBER
01:01:18   REMAINDER IS RESPONSIBLE FOR EVENTUALLY DOING
01:01:22   DISPATCH ON WHATEVER THE OBJECT IS.
01:01:24   SO THIS GETS EVEN WORSE THAN THIS, BECAUSE THIS
01:01:26   IS PYTHON, RIGHT?
01:01:27   SO WE CAN DEFINE OUR OWN TYPES AND WE CAN DEFINE
01:01:30   WHAT DIFFERENT OPERATIONS MEAN ON THOSE TYPES.
01:01:32   SO WE COULD WRITE AN OBJECT THAT HAS A SIDE
01:01:34   EFFECTING MOD FUNCTIONING.
01:01:37   SO HERE I'VE WRITTEN MOD THAT SAYS PRINT
01:01:39   SOMETHING, WHEN YOU PUT ONE MOD AGAINST ANOTHER.
01:01:42   I DON'T KNOW WHY YOU WOULD WANT TO DO THIS BUT
01:01:44   YOU COULD AND IT IS STRICTLY UP TO THE
01:01:46   INTERPRETER TO RESOLVE WHAT YOU MEAN BY BINARY
01:01:49   MOD ON THE OBJECT.
01:01:52   IT'S REALLY DEEP.
01:01:53   THERE IS THIS GREAT PAPER BY RUSSELL POWER AND
01:01:55   ALEX RUBINSTEIN CALLED "HOW FAST CAN WE MAKE
01:01:58   INTERPRETED PYTHON" AND THE CONCLUSION FROM THE
01:02:00   STRATEGIES THAT THEY TRIED WAS THAT IT'S VERY
01:02:02   CHALLENGING.
01:02:03   AND THE QUOTE HERE IS IN THE GENERAL ABSENCE OF
01:02:05   TYPE INFORMATION, ALMOST EVERY INSTRUCTION MUST
01:02:08   BE TREATED AS INVOKE ARBITRARY METHOD.
01:02:11   SO GIVEN THAT THE COMPILEER KNOWS SO LITTLE
01:02:13   WITHOUT RUNNING THE CODE, WE CAN'T REALLY
01:02:15   OPTIMIZE IT, WE DON'T KNOW WHAT INSTRUCTIONS WE
01:02:18   CAN TAKE OUT, WE CAN'T REASON ABOUT ITS
01:02:20   CORRECTNESS, ALL THOSE ARE VERY HARD TO DO
01:02:22   BECAUSE THE LANGUAGE IS SO DYNAMIC.
01:02:24   BUT NOTICE THE COPY OUT HERE, IN THE GENERAL
01:02:26   ABSENCE OF TYPE INFORMATION.
01:02:28   SO ONE WAY TO SOLVE THIS PROBLEM IS TO SAY, FINE,
01:02:31   LET'S ADD TYPE INFORMATION.
01:02:34   AND THERE'S A LOT OF NUANCE TO HOW YOU DO THAT
01:02:37   AND HOW TO MAKE THAT NOT BREAK FOR PEOPLE WHO ARE
01:02:39   NOT INTERESTED IN THOSE SORTS OF THINGS BUT IN
01:02:41   THE NEXT VERSION OF PYTHON, THIS IS BASICALLY
01:02:43   WHAT'S HAPPENING.
01:02:43   YOU CAN ADD OPTIONAL TYPE INFORMATION TO YOUR
01:02:45   PYTHON, AND THE STATIC ANALYSIS TOOLS WILL BE
01:02:49   MORE ROBUST BECAUSE OF IT.
01:02:50   AND IT OPENS UP A LOT OF INTERESTING
01:02:53   POSSIBILITIES THAT JUST AREN'T THERE WHEN
01:02:54   EVERYTHING IS SO DYNAMIC.
01:02:56   OKAY.
01:02:59   SO I'VE GOT -- I'LL PUT UP THE LINKS A LITTLE BIT
01:03:01   LATER, A COUPLE OF GREAT BLOGS, THERE ARE A
01:03:05   COUPLE OF GREAT ARTICLES ABOUT THE INTERPRETER
01:03:07   AND INTERNALS AND THE GO-TO STATEMENTS AND SO ON.
01:03:11   IN THE MEANTIME, I'LL GO AHEAD AND TAKE SOME
01:03:13   QUESTIONS.
01:03:14   [ Applause ]
01:03:26   >> THANK YOU, ALLISON.
01:03:27   IF ANYONE HAS ANY QUESTIONS, PLEASE COME TO THE
01:03:29   CENTER OF THE ROOM AND STAND BY THE MIC SO THE
01:03:31   VIDEO CAN PICK YOU UP.
01:03:33   >> AUDIENCE:  GREAT TALK, THANKS.
01:03:34   IS THERE ANY POSSIBILITY OF DOING, LIKE, DYNAMIC
01:03:37   OPTIMIZATIONS LIKE --
01:03:39   >> DOING WHAT SORT OF OPTIMIZATIONS?
01:03:42   >> AUDIENCE:  I'M NOT VERY AWARE OF THE INTERNALS
01:03:45   OF THE PYTHON INTERPRETER BUT CAN YOU DO LIKE --
01:03:51   LIKE THE EXAMPLE IN THE JAVA VM, IT WILL START
01:03:57   REWRITING THINGS AS IT'S RUNNING?
01:04:00   DOES PYTHON DO THAT?
01:04:01   >> YES, PYTHON DOES A COUPLE OF OPTIMIZATIONS
01:04:03   WHERE IT CAN, SO ONE IS CONSTANT FOLDING.
01:04:06   IF YOU HAVE A FUNCTION THAT SAYS RETURN THREE
01:04:07   PLUS TWO, THE PYTHON COMPILER WILL RETURN THAT
01:04:10   INTO RETURN 5.
01:04:11   BECAUSE PYTHON IS SO DYNAMIC, THERE'S VERY FEW
01:04:14   CASES WHERE UNDER THE CURRENT STRUCTURE YOU CAN'T
01:04:16   OPTIMIZE AND THE SOURCE IN THIS IS FAIRLY
01:04:20   READABLE, HAD A BLOG POST ABOUT CONSTANT FOLDING
01:04:23   AND THE WAY IT MESSES UP THE BYTECODE LEVEL
01:04:26   COVERAGE BECAUSE THE BYTECODE ENDS UP CHANGING
01:04:28   OUT FROM UNDER YOU, BUT IT HAPPENS A LITTLE BIT
01:04:31   BUT IT'S PRETTY LIMITED BECAUSE OF THE STRUCTURE.
01:04:35   >> AUDIENCE:  THANK YOU.
01:04:40   >> AUDIENCE:  HI.
01:04:41   I'M RESEARCHING ON INTERPRETERS AND JVMS AND
01:04:45   SMALL -- SO I'M NOT THAT VERY FAMILIAR WITH
01:04:49   CPYTHONS AND THE INTERPRETER BUT I WANTED TO
01:04:51   KNOW, IS IT REAL SIMPLE SWITCH CASE OR IS THERE
01:04:55   SMALL OPTIMIZATIONS LIKE TO DISPATCH OR DYNAMIC
01:04:59   THREADED DISPATCHES, SO THERE ARE MORE DIFFERENT
01:05:01   WAYS, SO IS IT JUST A SIMPLE SWITCH CASE OR IS IT
01:05:04   SOMETHING ELSE?
01:05:04   AND IS THERE A POSSIBILITY TO JIT THIS SCORE TO
01:05:09   OPTIMIZE IT LIKE PYPY DOES?
01:05:11   >> YEAH, SO TO THE FIRST QUESTION, IS THIS
01:05:14   LITERAL SWITCH STATEMENT, ARE THERE
01:05:16   OPTIMIZATIONS?
01:05:17   YES TO BOTH, SO THE CODE IS LIKE LITERALLY, YOU
01:05:20   KNOW, CASE LOAD FAST, CASE, SO ON.
01:05:23   IN PYTHON 2.
01:05:24   AND THERE ARE A COUPLE OF OPTIMIZATIONS WHERE IN
01:05:28   PARTICULAR THERE ARE PAIRS OF BYTES THAT OFTEN
01:05:30   FOLLOW EACH OTHER SO IF YOU HAVE LIKE A GET
01:05:34   ITTERS, THERE'S PROBABLY A 4 AFTER IT.
01:05:36   AND THE INTERPRETER IS SMART ENOUGH TO SAY OKAY,
01:05:38   CHECK FIRST AT THIS PARTICULAR BYTE AFTER IT.
01:05:44   THAT'S ONE OPTIMIZATION.
01:05:46   THERE ARE A NUMBER OF OTHERS, SOME WORK HAS TO BE
01:05:48   DONE IN-BETWEEN EACH INSTRUCTION, SOME WORK IS
01:05:50   DONE EVERY HUNDRED INSTRUCTIONS, THOSE SORTS OF
01:05:52   THINGS.
01:05:52   IN TERMS OF WHETHER THIS STRUCTURE CAN BE JITED,
01:05:56   I DON'T KNOW A WHOLE LOT ABOUT THE WAY THAT PYPY
01:05:58   IS IMPLEMENTED.
01:05:59   I THINK THAT PYPY IS SORT OF AN EXISTENCE PROOF
01:06:01   THAT THIS CANNOT.
01:06:03   LIKE YOU WOULDN'T HAVE TO GO THAT DIRECTION AND
01:06:05   SOLVE THAT PROBLEM WITH A COMPLETELY NEW
01:06:07   INTERPRETER AND A NEW SET OF BYTECODE IF THIS
01:06:09   WERE AMENABLE TO INCREMENTAL CHANGE.
01:06:13   >> AUDIENCE:  OKAY, THANK YOU.
01:06:17   >> AUDIENCE:  I'M SORRY, THIS MAY BE A STUPID
01:06:19   QUESTION BUT DO THE TYPE ANNOTATIONS HAVE
01:06:24   ANYTHING TO DO WITH JIT COMPILING?
01:06:28   >> NO, I THINK IS THE SHORT ANSWER.
01:06:30   THE TYPE ANNOTATIONS ARE DESIGNED TO HELP STATIC
01:06:33   ANALYSIS, SO WITHOUT RUNNING THE CODE WHAT, CAN
01:06:35   WE SAY ABOUT IT NOW?
01:06:35   DOING JIT COMPILATION I THINK IS MORE OR LESS A
01:06:46   SEPARATE PROBLEM.
01:06:48   >> AUDIENCE:  YOU ALLUDED TO THE BLOCK STACK A
01:06:50   COUPLE OF TIMES, CAN YOU EXPLAIN WHAT THAT IS?
01:06:52   >> IN SHORT, THE BLOCK STACK IS KEEPING TRACK OF
01:06:55   A DIFFERENT -- STATE IN A DIFFERENT WAY, SO THE
01:06:58   CLASSIC EXAMPLE IS FOR AN ITERATOR, IF YOU'RE ON
01:07:00   THE TOP INSTRUCTION OF AN ITERATOR, YOU'RE EITHER
01:07:03   GOING TO STEP TO THE NEXT INSTRUCTION, IF YOU'RE
01:07:05   IN THE BODY OF THE FORELOOP OR IF YOU'RE DONE,
01:07:07   YOU'RE GOING TO JUMP OUT OF THE FORELOOP.
01:07:09   SO THE BLOCK STACK IS RESPONSIBLE FOR KEENING
01:07:11   TRACK OF THAT.
01:07:11   IT'S USED FOR LOOPING AND EXCEPTION HANDLING AND
01:07:14   I THINK THAT'S PRETTY MUCH IT.
01:07:15   IT'S JUST LIKE ANOTHER WAY OF MANAGING STATE.
01:07:20   >> AUDIENCE:  OKAY.
01:07:24   >> AUDIENCE:  HI.
01:07:25   I NOTICED IN YOUR EXAMPLE OF MODULAR, YOU
01:07:30   ASSIGNED, LIKE, A MODULAR B TO ANSWER AND THEN
01:07:33   RETURN ANSWER.
01:07:34   IF YOU JUST DID LIKE RETURN A MODULAR B, IS
01:07:36   THERE -- DOES PYTHON, LIKE, CREATE A VARIABLE FOR
01:07:41   THAT STACK?
01:07:43   >> IT WOULD NOT CREATE A VARIABLE, YEAH, SO
01:07:46   YOU'RE TALKING ABOUT...
01:07:49   YEAH, SO WHAT WE WOULD SEE IN THAT CASE, IS YOU
01:07:51   WOULD HAVE BINARY MODULAR AND THEN IMMEDIATELY
01:07:55   RETURN VALUE BECAUSE ALL THE RETURN VALUE NEEDS
01:07:57   IS THE RESULT ON THE STACK.
01:07:58   SO THIS IS JUST FOR READABILITY, YEAH.
01:08:02   AND THE INTERESTING THING THERE IS THAT MY
01:08:06   BINDING A NAME ANSWER TO THIS IS WHAT MAKES
01:08:08   PYTHON SAY, OKAY, PULL THIS OFF THE STACK AND PUT
01:08:10   IT INTO THE ENVIRONMENT.
01:08:11   AND THEN IMMEDIATELY RETRIEVE IT FROM THE
01:08:13   ENVIRONMENT AND RETURN IT.
01:08:14   SO THERE'S -- THIS IS SOMETHING I DIDN'T GET INTO
01:08:17   TOO MUCH ABOUT THE WAY THAT THE FRAME ALSO HAS TO
01:08:19   MANAGE THE NAME SPACE, WHAT IS CURRENTLY IN THE
01:08:21   LOCAL SCOPE AND THAT GETS MODIFIED AS YOU DO
01:08:25   THINGS LIKE STORE FAST AND LOAD.
01:08:29   >> AUDIENCE:  THANK YOU.
01:08:34   >> THANK YOU VERY MUCH, ALLISON.
01:08:35   [ Applause ]
01:08:56   [ BREAK ]
01:08:57   [ MUSIC PLAYING ]
01:16:47   [ MUSIC PLAYING ]
01:53:41
02:32:48















